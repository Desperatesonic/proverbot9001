Require Import GeoCoq.Tarski_dev.Ch08_orthogonality.
-----
From Coq Require Import Relations.
-----
Section Grad.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.
-----
Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), Bet A B C
+++++
Proof.
-----
Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), Bet A B C
+++++
intros A B C HG.
-----
Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.
Proof.
intros A B C HG.

*****
HG : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
elim HG; clear HG A B C; [Between|eBetween].
-----
Lemma grad__bet : forall A B C, Grad A B C -> Bet A B C.
Proof.
intros A B C HG.
elim HG; clear HG A B C; [Between|eBetween].

*****

*****

+++++
Qed.
-----
Lemma grad__col : forall A B C, Grad A B C -> Col A B C.
-----
Lemma grad__col : forall A B C, Grad A B C -> Col A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), Col A B C
+++++
Proof.
-----
Lemma grad__col : forall A B C, Grad A B C -> Col A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), Col A B C
+++++
intros.
-----
Lemma grad__col : forall A B C, Grad A B C -> Col A B C.
Proof.
intros.

*****
H : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
apply bet_col, grad__bet.
-----
Lemma grad__col : forall A B C, Grad A B C -> Col A B C.
Proof.
intros.
apply bet_col, grad__bet.

*****
H : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C
+++++
assumption.
-----
Lemma grad__col : forall A B C, Grad A B C -> Col A B C.
Proof.
intros.
apply bet_col, grad__bet.
assumption.

*****

*****

+++++
Qed.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C) (_ : not (eq A B)), not (eq A C)
+++++
Proof.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C) (_ : not (eq A B)), not (eq A C)
+++++
intros A B C HG HAB Heq.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
Proof.
intros A B C HG HAB Heq.

*****
Heq : eq A C
HAB : not (eq A B)
HG : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst C.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
Proof.
intros A B C HG HAB Heq.
subst C.

*****
HAB : not (eq A B)
HG : Grad A B A
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HAB.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
Proof.
intros A B C HG HAB Heq.
subst C.
apply HAB.

*****
HAB : not (eq A B)
HG : Grad A B A
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
apply between_identity, grad__bet.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
Proof.
intros A B C HG HAB Heq.
subst C.
apply HAB.
apply between_identity, grad__bet.

*****
HAB : not (eq A B)
HG : Grad A B A
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B A
+++++
trivial.
-----
Lemma grad_neq__neq13 : forall A B C, Grad A B C -> A <> B -> A <> C.
Proof.
intros A B C HG HAB Heq.
subst C.
apply HAB.
apply between_identity, grad__bet.
trivial.

*****

*****

+++++
Qed.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C) (_ : not (eq A C)), not (eq A B)
+++++
Proof.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C) (_ : not (eq A C)), not (eq A B)
+++++
intros A B C HG.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.

*****
HG : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A C), not (eq A B)
+++++
elim HG.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.

*****
HG : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (eq A B)), not (eq A B)
+++++
clear HG A B C.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (eq A B)), not (eq A B)
+++++
intros.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.

*****
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
intro.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.
intro.

*****
H0 : eq A B
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.
intro.
treat_equalities.

*****
H : not (eq A A)
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.

*****
HG : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C C' : Tpoint) (_ : Grad A B C) (_ : forall _ : not (eq A C), not (eq A B)) (_ : Bet A C C') (_ : Cong A B C C') (_ : not (eq A C')), not (eq A B)
+++++
clear HG A B C.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C C' : Tpoint) (_ : Grad A B C) (_ : forall _ : not (eq A C), not (eq A B)) (_ : Bet A C C') (_ : Cong A B C C') (_ : not (eq A C')), not (eq A B)
+++++
intros.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.

*****
H3 : not (eq A C')
H2 : Cong A B C C'
H1 : Bet A C C'
H0 : forall _ : not (eq A C), not (eq A B)
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
intro.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.
intro.

*****
H4 : eq A B
H3 : not (eq A C')
H2 : Cong A B C C'
H1 : Bet A C C'
H0 : forall _ : not (eq A C), not (eq A B)
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.
intro.
treat_equalities.

*****
H3 : not (eq A C)
H : Grad A A C
H0 : forall _ : not (eq A C), not (eq A A)
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H0.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.
intro.
treat_equalities.
apply H0.

*****
H3 : not (eq A C)
H : Grad A A C
H0 : forall _ : not (eq A C), not (eq A A)
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
auto.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.
clear HG A B C.
intros.
intro.
treat_equalities.
apply H0.

*****
H3 : not (eq A C)
H : Grad A A C
H0 : forall _ : not (eq A C), not (eq A A)
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A A
+++++
auto.
-----
Lemma grad_neq__neq12 : forall A B C, Grad A B C -> A <> C -> A <> B.
Proof.
intros A B C HG.
elim HG.

*****

*****

+++++
Qed.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : Grad A A B), eq A B
+++++
Proof.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : Grad A A B), eq A B
+++++
intros A B HG.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.

*****
HG : Grad A A B
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
assert (HA' : exists A', A' = A /\ Grad A A' B).
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).

*****
HG : Grad A A B
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (eq A' A) (Grad A A' B))
+++++
exists A.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
exists A.

*****
HG : Grad A A B
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (eq A A) (Grad A A B)
+++++
auto.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).

*****
HA' : ex (fun A' : Tpoint => and (eq A' A) (Grad A A' B))
HG : Grad A A B
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
idtac.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.

*****
HA' : ex (fun A' : Tpoint => and (eq A' A) (Grad A A' B))
HG : Grad A A B
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
destruct HA' as [A' [Heq HG']].
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].

*****
HG' : Grad A A' B
Heq : eq A' A
A' : Tpoint
HG : Grad A A B
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
clear HG.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.

*****
HG' : Grad A A' B
Heq : eq A' A
A,B,A' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
revert Heq.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.

*****
HG' : Grad A A' B
A,B,A' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A' A, eq A B
+++++
elim HG'.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.
elim HG'.

*****
HG' : Grad A A' B
A,B,A' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : eq B A), eq A B
+++++
auto.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.
elim HG'.

*****
HG' : Grad A A' B
A,B,A' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C C' : Tpoint) (_ : Grad A B C) (_ : forall _ : eq B A, eq A C) (_ : Bet A C C') (_ : Cong A B C C') (_ : eq B A), eq A C'
+++++
auto.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.
elim HG'.
auto.

*****
HG' : Grad A A' B
A,B,A' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C C' : Tpoint) (_ : Grad A B C) (_ : forall _ : eq B A, eq A C) (_ : Bet A C C') (_ : Cong A B C C') (_ : eq B A), eq A C'
+++++
clear HG' A B A'.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.
elim HG'.
auto.
clear HG' A B A'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C C' : Tpoint) (_ : Grad A B C) (_ : forall _ : eq B A, eq A C) (_ : Bet A C C') (_ : Cong A B C C') (_ : eq B A), eq A C'
+++++
intros.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.
elim HG'.
auto.
clear HG' A B A'.
intros.

*****
Heq : eq B A
H2 : Cong A B C C'
H1 : Bet A C C'
H0 : forall _ : eq B A, eq A C
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A C'
+++++
treat_equalities.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).
idtac.
destruct HA' as [A' [Heq HG']].
clear HG.
revert Heq.
elim HG'.
auto.
clear HG' A B A'.
intros.
treat_equalities.

*****
H : Grad B B C
H0 : forall _ : eq B B, eq B C
B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B C
+++++
auto.
-----
Lemma grad112__eq : forall A B, Grad A A B -> A = B.
Proof.
intros A B HG.
assert (HA' : exists A', A' = A /\\ Grad A A' B).

*****

*****

+++++
Qed.
-----
Lemma grad121__eq : forall A B, Grad A B A -> A = B.
-----
Lemma grad121__eq : forall A B, Grad A B A -> A = B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : Grad A B A), eq A B
+++++
Proof.
-----
Lemma grad121__eq : forall A B, Grad A B A -> A = B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : Grad A B A), eq A B
+++++
intros A B HG.
-----
Lemma grad121__eq : forall A B, Grad A B A -> A = B.
Proof.
intros A B HG.

*****
HG : Grad A B A
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
apply between_identity, grad__bet.
-----
Lemma grad121__eq : forall A B, Grad A B A -> A = B.
Proof.
intros A B HG.
apply between_identity, grad__bet.

*****
HG : Grad A B A
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B A
+++++
trivial.
-----
Lemma grad121__eq : forall A B, Grad A B A -> A = B.
Proof.
intros A B HG.
apply between_identity, grad__bet.
trivial.

*****

*****

+++++
Qed.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), Le A B A C
+++++
Proof.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), Le A B A C
+++++
intros.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
Proof.
intros.

*****
H : Grad A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A C
+++++
apply grad__bet in H.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
Proof.
intros.
apply grad__bet in H.

*****
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A C
+++++
apply l5_12_a in H.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
Proof.
intros.
apply grad__bet in H.
apply l5_12_a in H.

*****
H : and (Le A B A C) (Le B C A C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A C
+++++
spliter.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
Proof.
intros.
apply grad__bet in H.
apply l5_12_a in H.
spliter.

*****
H0 : Le B C A C
H : Le A B A C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A C
+++++
auto.
-----
Lemma grad__le : forall A B C, Grad A B C -> Le A B A C.
Proof.
intros.
apply grad__bet in H.
apply l5_12_a in H.
spliter.
auto.

*****

*****

+++++
Qed.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : Grad2 A B C D E F), Grad A B C
+++++
Proof.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : Grad2 A B C D E F), Grad A B C
+++++
intros A B C D E F.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.

*****
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Grad2 A B C D E F, Grad A B C
+++++
induction 1.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.
induction 1.

*****
A,B,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B B
+++++
apply grad_init.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.
induction 1.

*****
IHGrad2 : Grad A B C
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C'
+++++
apply (grad_stab _ _ C).
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.
induction 1.
apply (grad_stab _ _ C).

*****
IHGrad2 : Grad A B C
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C
+++++
auto.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.
induction 1.
apply (grad_stab _ _ C).

*****
IHGrad2 : Grad A B C
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C'
+++++
auto.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.
induction 1.
apply (grad_stab _ _ C).

*****
IHGrad2 : Grad A B C
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C C'
+++++
auto.
-----
Lemma grad2__grad123 : forall A B C D E F, Grad2 A B C D E F -> Grad A B C.
Proof.
intros A B C D E F.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : Grad2 A B C D E F), Grad D E F
+++++
Proof.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : Grad2 A B C D E F), Grad D E F
+++++
intros A B C D E F.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.

*****
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Grad2 A B C D E F, Grad D E F
+++++
induction 1.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.
induction 1.

*****
A,B,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad D E E
+++++
apply grad_init.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.
induction 1.

*****
IHGrad2 : Grad D E F
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad D E F'
+++++
apply (grad_stab _ _ F).
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.
induction 1.
apply (grad_stab _ _ F).

*****
IHGrad2 : Grad D E F
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad D E F
+++++
auto.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.
induction 1.
apply (grad_stab _ _ F).

*****
IHGrad2 : Grad D E F
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D F F'
+++++
auto.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.
induction 1.
apply (grad_stab _ _ F).

*****
IHGrad2 : Grad D E F
H3 : Cong D E F F'
H2 : Bet D F F'
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D E F F'
+++++
auto.
-----
Lemma grad2__grad456 : forall A B C D E F, Grad2 A B C D E F -> Grad D E F.
Proof.
intros A B C D E F.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma grad_sum : forall A B C D E,\n  Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E ->\n  Grad A B E.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E : Tpoint) (_ : Grad A B C) (_ : Grad A B D) (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
Proof.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E : Tpoint) (_ : Grad A B C) (_ : Grad A B D) (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
intros A B C D E HGC HGD.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.

*****
HGD : Grad A B D
HGC : Grad A B C
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
elim (eq_dec_points A B).
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).

*****
HGD : Grad A B D
HGC : Grad A B C
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : eq A B) (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
intros.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.

*****
H1 : Cong A D C E
H0 : Bet A C E
H : eq A B
HGD : Grad A B D
HGC : Grad A B C
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E
+++++
subst B.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.

*****
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A E
+++++
assert(A = C).
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).

*****
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A C
+++++
apply grad112__eq.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
apply grad112__eq.

*****
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A C
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).

*****
H : eq A C
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A E
+++++
idtac.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
idtac.

*****
H : eq A C
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A E
+++++
assert(A = D).
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
idtac.
assert(A = D).

*****
H : eq A C
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A D
+++++
apply grad112__eq.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
idtac.
assert(A = D).
apply grad112__eq.

*****
H : eq A C
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A D
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
idtac.
assert(A = D).

*****
H2 : eq A D
H : eq A C
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A E
+++++
idtac.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
idtac.
assert(A = D).
idtac.

*****
H2 : eq A D
H : eq A C
H1 : Cong A D C E
H0 : Bet A C E
HGC : Grad A A C
HGD : Grad A A D
A,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A E
+++++
treat_equalities.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intros.
subst B.
assert(A = C).
idtac.
assert(A = D).
idtac.
treat_equalities.

*****
HGD : Grad A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A A A
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).

*****
HGD : Grad A B D
HGC : Grad A B C
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
intro HAB.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.

*****
HAB : not (eq A B)
HGD : Grad A B D
HGC : Grad A B C
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
revert E.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.

*****
HAB : not (eq A B)
HGD : Grad A B D
HGC : Grad A B C
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (E : Tpoint) (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
+++++
induction HGD.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.

*****
HAB : not (eq A B)
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (E : Tpoint) (_ : Bet A C E) (_ : Cong A B C E), Grad A B E
+++++
intro E.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
intro E.

*****
E : Tpoint
HAB : not (eq A B)
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Bet A C E) (_ : Cong A B C E), Grad A B E
+++++
apply grad_stab.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
intro E.
apply grad_stab.

*****
E : Tpoint
HAB : not (eq A B)
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.

*****
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A C0 C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B C0 C'
H : Bet A C0 C'
HGD : Grad A B C0
C0,C' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (E : Tpoint) (_ : Bet A C E) (_ : Cong A C' C E), Grad A B E
+++++
rename C0 into D.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.

*****
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D C'
H : Bet A D C'
HGD : Grad A B D
D,C' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (E : Tpoint) (_ : Bet A C E) (_ : Cong A C' C E), Grad A B E
+++++
rename C' into D'.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.

*****
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (E : Tpoint) (_ : Bet A C E) (_ : Cong A D' C E), Grad A B E
+++++
intros E' HBet' HCong'.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.

*****
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
destruct(segment_construction A C A D) as [E [HBet HCong]].
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].

*****
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
assert (HBet1 : Bet A B C).
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).

*****
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
apply grad__bet.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
apply grad__bet.

*****
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).

*****
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
idtac.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.

*****
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
assert (HBet2 : Bet A B D).
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).

*****
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B D
+++++
apply grad__bet.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
apply grad__bet.

*****
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B D
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
idtac.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
assert(HBet3 : Bet C E E').
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C E E'
+++++
apply l6_13_1.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C E E'
+++++
assert_diffs.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
assert_diffs.

*****
H8 : not (eq C E)
H7 : not (eq D D')
H6 : not (eq C E')
H5 : not (eq A E')
H4 : not (eq A E)
H3 : not (eq A C)
H2 : not (eq A D')
H1 : not (eq A D)
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C E E'
+++++
apply l6_2 with A.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
assert_diffs.
apply l6_2 with A.

*****
H8 : not (eq C E)
H7 : not (eq D D')
H6 : not (eq C E')
H5 : not (eq A E')
H4 : not (eq A E)
H3 : not (eq A C)
H2 : not (eq A D')
H1 : not (eq A D)
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E C)
+++++
Between.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
assert_diffs.
apply l6_2 with A.

*****
H8 : not (eq C E)
H7 : not (eq D D')
H6 : not (eq C E')
H5 : not (eq A E')
H4 : not (eq A E)
H3 : not (eq A C)
H2 : not (eq A D')
H1 : not (eq A D)
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E' C)
+++++
Between.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
assert_diffs.
apply l6_2 with A.

*****
H8 : not (eq C E)
H7 : not (eq D D')
H6 : not (eq C E')
H5 : not (eq A E')
H4 : not (eq A E)
H3 : not (eq A C)
H2 : not (eq A D')
H1 : not (eq A D)
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Between.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
assert_diffs.
apply l6_2 with A.

*****
H8 : not (eq C E)
H7 : not (eq D D')
H6 : not (eq C E')
H5 : not (eq A E')
H4 : not (eq A E)
H3 : not (eq A C)
H2 : not (eq A D')
H1 : not (eq A D)
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet E C A
+++++
Between.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
assert_diffs.
apply l6_2 with A.

*****
H8 : not (eq C E)
H7 : not (eq D D')
H6 : not (eq C E')
H5 : not (eq A E')
H4 : not (eq A E)
H3 : not (eq A C)
H2 : not (eq A D')
H1 : not (eq A D)
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet E' C A
+++++
Between.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C E C E'
+++++
apply (l5_6 A D A D').
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
apply (l5_6 A D A D').

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A D A D'
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
apply (l5_6 A D A D').
Cong.

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A D A D'
+++++
apply bet__le1213.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
apply (l5_6 A D A D').
Cong.
apply bet__le1213.

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D D'
+++++
trivial.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
apply (l5_6 A D A D').

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D C E
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply l6_13_1.
apply (l5_6 A D A D').

*****
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D' C E'
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E'
+++++
apply grad_stab with E.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B E
+++++
auto with cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A E E'
+++++
auto with cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A E E'
+++++
eBetween.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B E E'
+++++
auto with cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B E E'
+++++
eBetween.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B E E'
+++++
apply cong_transitivity with D D'.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B D D'
+++++
auto.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D D' E E'
+++++
auto.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.
auto.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D D' E E'
+++++
apply l4_3_1 with A C.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.
auto.
apply l4_3_1 with A C.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D D'
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.
auto.
apply l4_3_1 with A C.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C E E'
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.
auto.
apply l4_3_1 with A C.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D C E
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).
intro HAB.
revert E.
induction HGD.
rename C0 into D.
rename C' into D'.
intros E' HBet' HCong'.
destruct(segment_construction A C A D) as [E [HBet HCong]].
assert (HBet1 : Bet A B C).
idtac.
assert (HBet2 : Bet A B D).
idtac.
assert(HBet3 : Bet C E E').
apply grad_stab with E.
auto with cong.
eBetween.
apply cong_transitivity with D D'.
auto.
apply l4_3_1 with A C.

*****
HBet3 : Bet C E E'
HBet2 : Bet A B D
HBet1 : Bet A B C
HCong : Cong C E A D
HBet : Bet A C E
E : Tpoint
HCong' : Cong A D' C E'
HBet' : Bet A C E'
E' : Tpoint
IHHGD : forall (_ : Grad A B C) (_ : not (eq A B)) (E : Tpoint) \n (_ : Bet A C E) (_ : Cong A D C E), Grad A B E
HAB : not (eq A B)
H0 : Cong A B D D'
H : Bet A D D'
HGD : Grad A B D
D,D' : Tpoint
HGC : Grad A B C
C,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D' C E'
+++++
Cong.
-----
Lemma grad_sum : forall A B C D E, Grad A B C -> Grad A B D -> Bet A C E -> Cong A D C E -> Grad A B E.
Proof.
intros A B C D E HGC HGD.
elim (eq_dec_points A B).

*****

*****

+++++
Qed.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : GradExp A B C), Grad A B C
+++++
Proof.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : GradExp A B C), Grad A B C
+++++
induction 1.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B B
+++++
apply grad_init.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.

*****
IHGradExp : Grad A B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C'
+++++
apply grad_sum with C C.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.
apply grad_sum with C C.

*****
IHGradExp : Grad A B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C
+++++
auto.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.
apply grad_sum with C C.

*****
IHGradExp : Grad A B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C
+++++
auto.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.
apply grad_sum with C C.

*****
IHGradExp : Grad A B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C'
+++++
auto.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.
apply grad_sum with C C.

*****
IHGradExp : Grad A B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C C C'
+++++
auto.
-----
Lemma gradexp__grad : forall A B C, GradExp A B C -> Grad A B C.
Proof.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma gradexp_le__reach : forall A B C D B',\n  GradExp A B B' -> Le C D A B' ->\n  Reach A B C D.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D B' : Tpoint) (_ : GradExp A B B') (_ : Le C D A B'), Reach A B C D
+++++
Proof.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D B' : Tpoint) (_ : GradExp A B B') (_ : Le C D A B'), Reach A B C D
+++++
intros A B C D B' HGE HLe.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.

*****
HLe : Le C D A B'
HGE : GradExp A B B'
A,B,C,D,B' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reach A B C D
+++++
exists B'.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.
exists B'.

*****
HLe : Le C D A B'
HGE : GradExp A B B'
A,B,C,D,B' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Grad A B B') (Le C D A B')
+++++
split.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.
exists B'.
split.

*****
HLe : Le C D A B'
HGE : GradExp A B B'
A,B,C,D,B' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B B'
+++++
trivial.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.
exists B'.
split.
trivial.

*****
HLe : Le C D A B'
HGE : GradExp A B B'
A,B,C,D,B' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B B'
+++++
apply gradexp__grad.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.
exists B'.
split.
trivial.
apply gradexp__grad.

*****
HLe : Le C D A B'
HGE : GradExp A B B'
A,B,C,D,B' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B B'
+++++
trivial.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.
exists B'.
split.

*****
HLe : Le C D A B'
HGE : GradExp A B B'
A,B,C,D,B' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D A B'
+++++
trivial.
-----
Lemma gradexp_le__reach : forall A B C D B', GradExp A B B' -> Le C D A B' -> Reach A B C D.
Proof.
intros A B C D B' HGE HLe.
exists B'.
split.

*****

*****

+++++
Qed.
-----
Lemma grad__ex_gradexp_le : forall A B C,\n  Grad A B C ->\n  exists D, GradExp A B D /\ Le A C A D.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), ex (fun D : Tpoint => and (GradExp A B D) (Le A C A D))
+++++
Proof.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Grad A B C), ex (fun D : Tpoint => and (GradExp A B D) (Le A C A D))
+++++
intros A B C.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Grad A B C, ex (fun D : Tpoint => and (GradExp A B D) (Le A C A D))
+++++
induction 1.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => and (GradExp A B D) (Le A B A D))
+++++
exists B.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
exists B.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp A B B) (Le A B A B)
+++++
split.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
exists B.
split.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B B
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
exists B.
split.
Le.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B B
+++++
apply gradexp_init.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
exists B.
split.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A B
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.

*****
IHGrad : ex (fun D : Tpoint => and (GradExp A B D) (Le A C A D))
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => and (GradExp A B D) (Le A C' A D))
+++++
destruct IHGrad as [D [HGE HLe]].
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].

*****
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => and (GradExp A B D) (Le A C' A D))
+++++
destruct (segment_construction A D A D) as [D' [HBet HCong]].
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => and (GradExp A B D) (Le A C' A D))
+++++
exists D'.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp A B D') (Le A C' A D')
+++++
split.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B D'
+++++
apply gradexp_stab with D.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply gradexp_stab with D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B D
+++++
Cong.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply gradexp_stab with D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D D'
+++++
Cong.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply gradexp_stab with D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D D D'
+++++
Cong.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C' A D'
+++++
apply bet2_le2__le1346 with C D.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C'
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D D'
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C A D
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C C' D D'
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.
Le.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : GradExp A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C C' D D'
+++++
apply gradexp__grad, grad__bet in HGE.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.
Le.
apply gradexp__grad, grad__bet in HGE.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : Bet A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C C' D D'
+++++
apply l5_6 with A B A D.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.
Le.
apply gradexp__grad, grad__bet in HGE.
apply l5_6 with A B A D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : Bet A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A D
+++++
Cong.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.
Le.
apply gradexp__grad, grad__bet in HGE.
apply l5_6 with A B A D.
Cong.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : Bet A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A D
+++++
Le.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.
Le.
apply gradexp__grad, grad__bet in HGE.
apply l5_6 with A B A D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : Bet A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C C'
+++++
Cong.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.
destruct IHGrad as [D [HGE HLe]].
destruct (segment_construction A D A D) as [D' [HBet HCong]].
exists D'.
split.
apply bet2_le2__le1346 with C D.
Le.
apply gradexp__grad, grad__bet in HGE.
apply l5_6 with A B A D.

*****
HCong : Cong D D' A D
HBet : Bet A D D'
D' : Tpoint
HLe : Le A C A D
HGE : Bet A B D
D : Tpoint
H1 : Cong A B C C'
H0 : Bet A C C'
H : Grad A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D D D'
+++++
Cong.
-----
Lemma grad__ex_gradexp_le : forall A B C, Grad A B C -> exists D, GradExp A B D /\\ Le A C A D.
Proof.
intros A B C.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D ->\n  exists B', GradExp A B B' /\ Le C D A B'.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Reach A B C D), ex (fun B' : Tpoint => and (GradExp A B B') (Le C D A B'))
+++++
Proof.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Reach A B C D), ex (fun B' : Tpoint => and (GradExp A B B') (Le C D A B'))
+++++
intros A B C D HR.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.

*****
HR : Reach A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (GradExp A B B') (Le C D A B'))
+++++
destruct HR as [B0 [HG HLe]].
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].

*****
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (GradExp A B B') (Le C D A B'))
+++++
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (GradExp A B B') (Le C D A B'))
+++++
exists B'.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp A B B') (Le C D A B')
+++++
split.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.
split.

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B B'
+++++
trivial.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.
split.

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D A B'
+++++
trivial.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.
split.
trivial.

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D A B'
+++++
apply le_transitivity with A B0.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.
split.
trivial.
apply le_transitivity with A B0.

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D A B0
+++++
trivial.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.
split.
trivial.
apply le_transitivity with A B0.

*****
HLe2 : Le A B0 A B'
HG2 : GradExp A B B'
B' : Tpoint
HLe : Le C D A B0
HG : Grad A B B0
A,B,C,D,B0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B0 A B'
+++++
trivial.
-----
Lemma reach__ex_gradexp_le : forall A B C D, Reach A B C D -> exists B', GradExp A B B' /\\ Le C D A B'.
Proof.
intros A B C D HR.
destruct HR as [B0 [HG HLe]].
destruct (grad__ex_gradexp_le A B B0 HG) as [B' [HG2 HLe2]].
exists B'.
split.

*****

*****

+++++
Qed.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F,\n  GradExp2 A B C D E F ->\n  GradExp A B C.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradExp2 A B C D E F), GradExp A B C
+++++
Proof.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradExp2 A B C D E F), GradExp A B C
+++++
intros A B C D E F.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.

*****
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : GradExp2 A B C D E F, GradExp A B C
+++++
induction 1.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.
induction 1.

*****
A,B,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B B
+++++
apply gradexp_init.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.
induction 1.

*****
IHGradExp2 : GradExp A B C
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B C'
+++++
apply (gradexp_stab _ _ C).
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.
induction 1.
apply (gradexp_stab _ _ C).

*****
IHGradExp2 : GradExp A B C
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B C
+++++
auto.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.
induction 1.
apply (gradexp_stab _ _ C).

*****
IHGradExp2 : GradExp A B C
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C'
+++++
auto.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.
induction 1.
apply (gradexp_stab _ _ C).

*****
IHGradExp2 : GradExp A B C
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C C C'
+++++
auto.
-----
Lemma gradexp2__gradexp123 : forall A B C D E F, GradExp2 A B C D E F -> GradExp A B C.
Proof.
intros A B C D E F.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F,\n  GradExp2 A B C D E F ->\n  GradExp D E F.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradExp2 A B C D E F), GradExp D E F
+++++
Proof.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradExp2 A B C D E F), GradExp D E F
+++++
intros A B C D E F.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.

*****
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : GradExp2 A B C D E F, GradExp D E F
+++++
induction 1.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.
induction 1.

*****
A,B,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp D E E
+++++
apply gradexp_init.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.
induction 1.

*****
IHGradExp2 : GradExp D E F
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp D E F'
+++++
apply (gradexp_stab _ _ F).
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.
induction 1.
apply (gradexp_stab _ _ F).

*****
IHGradExp2 : GradExp D E F
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp D E F
+++++
auto.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.
induction 1.
apply (gradexp_stab _ _ F).

*****
IHGradExp2 : GradExp D E F
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D F F'
+++++
auto.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.
induction 1.
apply (gradexp_stab _ _ F).

*****
IHGradExp2 : GradExp D E F
H3 : Cong D F F F'
H2 : Bet D F F'
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp2 A B C D E F
A,B,C,C',D,E,F,F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D F F F'
+++++
auto.
-----
Lemma gradexp2__gradexp456 : forall A B C D E F, GradExp2 A B C D E F -> GradExp D E F.
Proof.
intros A B C D E F.
induction 1.

*****

*****

+++++
Qed.
-----
Inductive GradExpInv : Tpoint -> Tpoint -> Tpoint -> Prop :=\n    gradexpinv_init : forall A B, GradExpInv A B B\n  | gradexpinv_stab : forall A B B' C, Bet A B' B -> Cong A B' B' B -> GradExpInv A B C ->\n                    GradExpInv A B' C.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <->\n  clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (GradExp A B C) (clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
Proof.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (GradExp A B C) (clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
intros.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (GradExp A B C) (clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
split.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : GradExp A B C, clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
+++++
induction 1.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B B
+++++
constructor.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
IHGradExp : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C'
+++++
apply Relation_Operators.rtn1_trans with C.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rtn1_trans with C.

*****
IHGradExp : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint C A C'
+++++
split.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rtn1_trans with C.
split.

*****
IHGradExp : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C'
+++++
assumption.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rtn1_trans with C.
split.

*****
IHGradExp : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C C C'
+++++
assumption.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rtn1_trans with C.

*****
IHGradExp : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
+++++
idtac.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rtn1_trans with C.
idtac.

*****
IHGradExp : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : Cong A C C C'
H0 : Bet A C C'
H : GradExp A B C
A,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
+++++
assumption.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C, GradExp A B C
+++++
induction 1.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B B
+++++
constructor.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
IHclos_refl_trans_n1 : GradExp A B y
H0 : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B y
H : Midpoint y A z
A,B,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B z
+++++
apply gradexp_stab with y.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply gradexp_stab with y.

*****
IHclos_refl_trans_n1 : GradExp A B y
H0 : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B y
H : Midpoint y A z
A,B,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A B y
+++++
finish.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply gradexp_stab with y.

*****
IHclos_refl_trans_n1 : GradExp A B y
H0 : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B y
H : Midpoint y A z
A,B,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A y z
+++++
finish.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply gradexp_stab with y.

*****
IHclos_refl_trans_n1 : GradExp A B y
H0 : clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B y
H : Midpoint y A z
A,B,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A y y z
+++++
finish.
-----
Lemma gradexp_clos_trans : forall A B C, GradExp A B C <-> clos_refl_trans_n1 Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <->\n  clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (GradExpInv A B C) (clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
Proof.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (GradExpInv A B C) (clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
intros.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (GradExpInv A B C) (clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
split.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : GradExpInv A B C, clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
+++++
induction 1.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B B
+++++
constructor.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
IHGradExpInv : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : GradExpInv A B C
H0 : Cong A B' B' B
H : Bet A B' B
A,B,B',C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B' C
+++++
apply Relation_Operators.rt1n_trans with B.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rt1n_trans with B.

*****
IHGradExpInv : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : GradExpInv A B C
H0 : Cong A B' B' B
H : Bet A B' B
A,B,B',C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint B' A B
+++++
split.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rt1n_trans with B.
split.

*****
IHGradExpInv : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : GradExpInv A B C
H0 : Cong A B' B' B
H : Bet A B' B
A,B,B',C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B' B
+++++
assumption.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rt1n_trans with B.
split.

*****
IHGradExpInv : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : GradExpInv A B C
H0 : Cong A B' B' B
H : Bet A B' B
A,B,B',C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B' B' B
+++++
assumption.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rt1n_trans with B.

*****
IHGradExpInv : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : GradExpInv A B C
H0 : Cong A B' B' B
H : Bet A B' B
A,B,B',C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
+++++
idtac.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply Relation_Operators.rt1n_trans with B.
idtac.

*****
IHGradExpInv : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
H1 : GradExpInv A B C
H0 : Cong A B' B' B
H : Bet A B' B
A,B,B',C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C
+++++
assumption.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C, GradExpInv A B C
+++++
induction 1.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
A,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExpInv A x x
+++++
constructor.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.

*****
IHclos_refl_trans_1n : GradExpInv A y z
H0 : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) y z
H : Midpoint x A y
A,x,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExpInv A x z
+++++
apply gradexpinv_stab with y.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply gradexpinv_stab with y.

*****
IHclos_refl_trans_1n : GradExpInv A y z
H0 : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) y z
H : Midpoint x A y
A,x,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A x y
+++++
finish.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply gradexpinv_stab with y.

*****
IHclos_refl_trans_1n : GradExpInv A y z
H0 : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) y z
H : Midpoint x A y
A,x,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A x x y
+++++
finish.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.
induction 1.
apply gradexpinv_stab with y.

*****
IHclos_refl_trans_1n : GradExpInv A y z
H0 : clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) y z
H : Midpoint x A y
A,x,y,z : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExpInv A y z
+++++
finish.
-----
Lemma gradexpinv_clos_trans : forall A B C, GradExpInv A B C <-> clos_refl_trans_1n Tpoint (fun X Y => Midpoint X A Y) B C.
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (GradExp A B C) (GradExpInv A B C)
+++++
Proof.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (GradExp A B C) (GradExpInv A B C)
+++++
intros.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.
intros.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (GradExp A B C) (GradExpInv A B C)
+++++
rewrite gradexp_clos_trans.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.
intros.
rewrite gradexp_clos_trans.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C) (GradExpInv A B C)
+++++
rewrite gradexpinv_clos_trans.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.
intros.
rewrite gradexp_clos_trans.
rewrite gradexpinv_clos_trans.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C) (clos_refl_trans_1n Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
rewrite <- clos_rt_rt1n_iff.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.
intros.
rewrite gradexp_clos_trans.
rewrite gradexpinv_clos_trans.
rewrite <- clos_rt_rt1n_iff.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (clos_refl_trans_n1 Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C) (clos_refl_trans Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
rewrite <- clos_rt_rtn1_iff.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.
intros.
rewrite gradexp_clos_trans.
rewrite gradexpinv_clos_trans.
rewrite <- clos_rt_rt1n_iff.
rewrite <- clos_rt_rtn1_iff.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (clos_refl_trans Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C) (clos_refl_trans Tpoint (fun X Y : Tpoint => Midpoint X A Y) B C)
+++++
reflexivity.
-----
Lemma gradexp__gradexpinv : forall A B C, GradExp A B C <-> GradExpInv A B C.
Proof.
intros.
rewrite gradexp_clos_trans.
rewrite gradexpinv_clos_trans.
rewrite <- clos_rt_rt1n_iff.
rewrite <- clos_rt_rtn1_iff.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C ->\n  exists D E, Bet A D C /\ Grad A B D /\ E <> C /\ Bet A C E /\ Bet A D E /\ Cong A B D E.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (eq A B)) (_ : Bet A B C) (_ : Reach A B A C), ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
Proof.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (eq A B)) (_ : Bet A B C) (_ : Reach A B A C), ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
intros A B C HAB HBet HReach.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.

*****
HReach : Reach A B A C
HBet : Bet A B C
HAB : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
destruct HReach as [D [HD1 HD2]].
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].

*****
HD2 : Le A C A D
HD1 : Grad A B D
D : Tpoint
HBet : Bet A B C
HAB : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].

*****
HD2 : Bet A C D
HD1 : Grad A B D
D : Tpoint
HBet : Bet A B C
HAB : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
revert dependent C.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.

*****
HD1 : Grad A B D
D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Bet A B C) (_ : Bet A C D), ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
induction HD1.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.

*****
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Bet A B C) (_ : Bet A C B), ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.

*****
HD2,HBet : Bet A B B
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D B) (and (Grad A B D) (and (not (eq E B)) (and (Bet A B E) (and (Bet A D E) (Cong A B D E)))))))
+++++
destruct (segment_construction A B A B) as [C []].
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].

*****
H0 : Cong B C A B
H : Bet A B C
C : Tpoint
HD2,HBet : Bet A B B
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D B) (and (Grad A B D) (and (not (eq E B)) (and (Bet A B E) (and (Bet A D E) (Cong A B D E)))))))
+++++
assert_diffs.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.

*****
H2 : not (eq B C)
H1 : not (eq A C)
H0 : Cong B C A B
H : Bet A B C
C : Tpoint
HD2 : Bet A B B
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D B) (and (Grad A B D) (and (not (eq E B)) (and (Bet A B E) (and (Bet A D E) (Cong A B D E)))))))
+++++
exists B, C; repeat split; finish; constructor.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.

*****
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Bet A B C) (_ : Bet A C C'), ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C) (and (Grad A B D) (and (not (eq E C)) (and (Bet A C E) (and (Bet A D E) (Cong A B D E)))))))
+++++
intros; destruct (l5_3 A C0 C C'); trivial.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.

*****
H1 : Bet A C0 C
HD2 : Bet A C0 C'
HBet : Bet A B C0
C0 : Tpoint
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C0) (and (Grad A B D) (and (not (eq E C0)) (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
+++++
apply IHHD1; assumption.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.

*****
H1 : Bet A C C0
HD2 : Bet A C0 C'
HBet : Bet A B C0
C0 : Tpoint
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C0) (and (Grad A B D) (and (not (eq E C0)) (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
+++++
destruct (eq_dec_points C' C0).
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).

*****
H2 : eq C' C0
H1 : Bet A C C0
HD2 : Bet A C0 C'
HBet : Bet A B C0
C0 : Tpoint
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C0) (and (Grad A B D) (and (not (eq E C0)) (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
+++++
-
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-

*****
H2 : eq C' C0
H1 : Bet A C C0
HD2 : Bet A C0 C'
HBet : Bet A B C0
C0 : Tpoint
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C0) (and (Grad A B D) (and (not (eq E C0)) (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
+++++
subst C0.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.

*****
HBet : Bet A B C'
HD2 : Bet A C' C'
H1 : Bet A C C'
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C') (and (Grad A B D) (and (not (eq E C')) (and (Bet A C' E) (and (Bet A D E) (Cong A B D E)))))))
+++++
destruct (segment_construction A C' A B) as [C'' []].
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.
destruct (segment_construction A C' A B) as [C'' []].

*****
H3 : Cong C' C'' A B
H2 : Bet A C' C''
C'' : Tpoint
HBet : Bet A B C'
HD2 : Bet A C' C'
H1 : Bet A C C'
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C') (and (Grad A B D) (and (not (eq E C')) (and (Bet A C' E) (and (Bet A D E) (Cong A B D E)))))))
+++++
assert_diffs.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.
destruct (segment_construction A C' A B) as [C'' []].
assert_diffs.

*****
H6 : not (eq C' C'')
H5 : not (eq C C')
H1 : not (eq A C'')
H4 : not (eq A C')
H3 : Cong C' C'' A B
H2 : Bet A C' C''
C'' : Tpoint
HBet : Bet A B C'
HD2 : Bet A C' C'
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C') (and (Grad A B D) (and (not (eq E C')) (and (Bet A C' E) (and (Bet A D E) (Cong A B D E)))))))
+++++
exists C', C''; repeat split; Cong.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.
destruct (segment_construction A C' A B) as [C'' []].
assert_diffs.
exists C', C''; repeat split; Cong.

*****
H6 : not (eq C' C'')
H5 : not (eq C C')
H1 : not (eq A C'')
H4 : not (eq A C')
H3 : Cong C' C'' A B
H2 : Bet A C' C''
C'' : Tpoint
HBet : Bet A B C'
HD2 : Bet A C' C'
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad A B C'
+++++
apply grad_stab with C; assumption.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.
destruct (segment_construction A C' A B) as [C'' []].
assert_diffs.
exists C', C''; repeat split; Cong.
apply grad_stab with C; assumption.

*****

*****

+++++
-
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.
destruct (segment_construction A C' A B) as [C'' []].
assert_diffs.
exists C', C''; repeat split; Cong.
apply grad_stab with C; assumption.
-

*****
H2 : not (eq C' C0)
H1 : Bet A C C0
HD2 : Bet A C0 C'
HBet : Bet A B C0
C0 : Tpoint
IHHD1 : forall (_ : not (eq A B)) (C0 : Tpoint) (_ : Bet A B C0)\n (_ : Bet A C0 C),\nex\n (fun D : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Bet A D C0)\n (and (Grad A B D)\n (and (not (eq E C0))\n (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
H0 : Cong A B C C'
H : Bet A C C'
HD1 : Grad A B C
C,C' : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D : Tpoint => ex (fun E : Tpoint => and (Bet A D C0) (and (Grad A B D) (and (not (eq E C0)) (and (Bet A C0 E) (and (Bet A D E) (Cong A B D E)))))))
+++++
exists C, C'; repeat split; assumption.
-----
Lemma reach__grad_min : forall A B C, A <> B -> Bet A B C -> Reach A B A C -> exists D E, Bet A D C /\\ Grad A B D /\\ E <> C /\\ Bet A C E /\\ Bet A D E /\\ Cong A B D E.
Proof.
intros A B C HAB HBet HReach.
destruct HReach as [D [HD1 HD2]].
apply l6_13_1 in HD2; [|apply l6_7 with B; [apply l6_6|]; apply bet_out; auto; apply grad__bet, HD1].
revert dependent C.
induction HD1.
intros; assert (B = C) by (apply between_equality with A; Between); subst C.
destruct (segment_construction A B A B) as [C []].
assert_diffs.
exists B, C; repeat split; finish; constructor.
intros; destruct (l5_3 A C0 C C'); trivial.
apply IHHD1; assumption.
destruct (eq_dec_points C' C0).
-
subst C0.
destruct (segment_construction A C' A B) as [C'' []].
assert_diffs.
exists C', C''; repeat split; Cong.
apply grad_stab with C; assumption.
-
exists C, C'; repeat split; assumption.

*****

*****

+++++
Qed.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B ->\n  exists C, GradExp A C B /\ Lt A C P Q.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B P Q : Tpoint) (_ : not (eq A B)) (_ : Reach P Q A B), ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
Proof.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B P Q : Tpoint) (_ : not (eq A B)) (_ : Reach P Q A B), ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
intros A B P Q HAB HReach.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.

*****
HReach : Reach P Q A B
HAB : not (eq A B)
A,B,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
apply reach__ex_gradexp_le in HReach.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.

*****
HReach : ex (fun B' : Tpoint => and (GradExp P Q B') (Le A B P B'))
HAB : not (eq A B)
A,B,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
destruct HReach as [R [HR1 HR2]].
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].

*****
HR2 : Le A B P R
HR1 : GradExp P Q R
R : Tpoint
HAB : not (eq A B)
A,B,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
generalize dependent B.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.

*****
HR1 : GradExp P Q R
A,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R), ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
induction HR1.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.

*****
A,A0,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B0 : Tpoint) (_ : not (eq A B0)) (_ : Le A B0 A0 B), ex (fun C : Tpoint => and (GradExp A C B0) (Lt A C A0 B))
+++++
rename A0 into P, B into Q.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.

*****
A,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P Q), ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
intros.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.

*****
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
destruct (midpoint_existence A B) as [C []].
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
exists C.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp A C B) (Lt A C P Q)
+++++
split.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A C B
+++++
rewrite gradexp__gradexpinv.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
rewrite gradexp__gradexpinv.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExpInv A C B
+++++
apply gradexpinv_stab with B.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
rewrite gradexp__gradexpinv.
apply gradexpinv_stab with B.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C B
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
rewrite gradexp__gradexpinv.
apply gradexpinv_stab with B.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C C B
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
rewrite gradexp__gradexpinv.
apply gradexpinv_stab with B.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExpInv A B B
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
rewrite gradexp__gradexpinv.
apply gradexpinv_stab with B.
auto.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExpInv A B B
+++++
constructor.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A C P Q
+++++
apply le3456_lt__lt with A B.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A C A B
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A C A B
+++++
split.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C A B
+++++
Le.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong A C A B)
+++++
Le.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong A C A B)
+++++
intro.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.

*****
H1 : Cong A C A B
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (C = B).
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.
assert (C = B).

*****
H1 : Cong A C A B
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq C B
+++++
apply (between_cong A).
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.
assert (C = B).
apply (between_cong A).

*****
H1 : Cong A C A B
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C B
+++++
assumption.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.
assert (C = B).
apply (between_cong A).

*****
H1 : Cong A C A B
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C A B
+++++
assumption.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.
assert (C = B).

*****
H2 : eq C B
H1 : Cong A C A B
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.
assert (C = B).
idtac.

*****
H2 : eq C B
H1 : Cong A C A B
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.
trivial.
split.
Le.
intro.
assert (C = B).
idtac.
treat_equalities.

*****
HR2 : Le A A P Q
HAB : not (eq A A)
A,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
destruct (midpoint_existence A B) as [C []].
exists C.
split.
apply le3456_lt__lt with A B.

*****
H0 : Cong A C C B
H : Bet A C B
C : Tpoint
HR2 : Le A B P Q
HAB : not (eq A B)
A,P,Q,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B P Q
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.

*****
IHHR1 : forall (B0 : Tpoint) (_ : not (eq A B0)) (_ : Le A B0 A0 C),\nex (fun C : Tpoint => and (GradExp A C B0) (Lt A C A0 B))
H0 : Cong A0 C C C'
H : Bet A0 C C'
HR1 : GradExp A0 B C
A,A0,B,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B0 : Tpoint) (_ : not (eq A B0)) (_ : Le A B0 A0 C'), ex (fun C : Tpoint => and (GradExp A C B0) (Lt A C A0 B))
+++++
rename A0 into P, B into Q.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.

*****
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P C),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P C C C'
H : Bet P C C'
HR1 : GradExp P Q C
A,P,Q,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P C'), ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
intros.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.

*****
HR2 : Le A B P C'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P C),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P C C C'
H : Bet P C C'
HR1 : GradExp P Q C
A,P,Q,C,C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
rename C into R, C' into R'.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.

*****
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
destruct (midpoint_existence A B) as [M HM].
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].

*****
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
assert_diffs.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
destruct (IHHR1 M) as [C []].
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A M)
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A M P R
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A M P R
+++++
apply le_mid2__le12 with B R'.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint M A B
+++++
idtac.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.
idtac.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint M A B
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint R P R'
+++++
split.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.
split.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P R R'
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.
split.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P R R R'
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B P R'
+++++
idtac.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
apply le_mid2__le12 with B R'.
idtac.

*****
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B P R'
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
auto.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
+++++
exists C.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp A C B) (Lt A C P Q)
+++++
split.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A C B
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.
trivial.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A C B
+++++
destruct HM.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.
trivial.
destruct HM.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
H7 : Cong A M M B
H6 : Bet A M B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A C B
+++++
apply gradexp_stab with M.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.
trivial.
destruct HM.
apply gradexp_stab with M.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
H7 : Cong A M M B
H6 : Bet A M B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp A C M
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.
trivial.
destruct HM.
apply gradexp_stab with M.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
H7 : Cong A M M B
H6 : Bet A M B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.
trivial.
destruct HM.
apply gradexp_stab with M.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
H7 : Cong A M M B
H6 : Bet A M B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A M M B
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.
rename A0 into P, B into Q.
intros.
rename C into R, C' into R'.
destruct (midpoint_existence A B) as [M HM].
assert_diffs.
destruct (IHHR1 M) as [C []].
auto.
exists C.
split.

*****
H5 : Lt A C P Q
H2 : GradExp A C M
C : Tpoint
H4 : not (eq M B)
H3 : not (eq M A)
H1 : not (eq P R')
HM : Midpoint M A B
M : Tpoint
HR2 : Le A B P R'
HAB : not (eq A B)
B : Tpoint
IHHR1 : forall (B : Tpoint) (_ : not (eq A B)) (_ : Le A B P R),\nex (fun C : Tpoint => and (GradExp A C B) (Lt A C P Q))
H0 : Cong P R R R'
H : Bet P R R'
HR1 : GradExp P Q R
A,P,Q,R,R' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A C P Q
+++++
trivial.
-----
Lemma reach__ex_gradexp_lt : forall A B P Q, A <> B -> Reach P Q A B -> exists C, GradExp A C B /\\ Lt A C P Q.
Proof.
intros A B P Q HAB HReach.
apply reach__ex_gradexp_le in HReach.
destruct HReach as [R [HR1 HR2]].
generalize dependent B.
induction HR1.

*****

*****

+++++
Qed.
-----
End Grad.
-----
Hint Resolve grad__bet : between.
-----
Hint Resolve grad__col : col.
-----
