From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Global Set Asymmetric Patterns.
-----
Definition ad := N.
-----
Section MapDefs.
-----
Variable A : Type.
-----
Inductive Map :=\n    | M0 : Map\n    | M1 : ad -> A -> Map\n    | M2 : Map -> Map -> Map.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.

*****
A : Type
*****
forall o : option A, sumor (sig (fun y : A => eq o (Some y))) (eq o None)
+++++
Proof.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.

*****
A : Type
*****
forall o : option A, sumor (sig (fun y : A => eq o (Some y))) (eq o None)
+++++
simple induction o.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.
simple induction o.

*****
o : option A
A : Type
*****
forall a : A, sumor (sig (fun y : A => eq (Some a) (Some y))) (eq (Some a) None)
+++++
left.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.
simple induction o.
left.

*****
a : A
o : option A
A : Type
*****
sig (fun y : A => eq (Some a) (Some y))
+++++
split with a.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.
simple induction o.
left.
split with a.

*****
a : A
o : option A
A : Type
*****
eq (Some a) (Some a)
+++++
reflexivity.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.
simple induction o.

*****
o : option A
A : Type
*****
sumor (sig (fun y : A => eq None (Some y))) (eq None None)
+++++
right.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.
simple induction o.
right.

*****
o : option A
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.
Proof.
simple induction o.

*****

*****

+++++
Qed.
-----
Fixpoint MapGet (m:Map) : ad -> option A :=\n    match m with\n    | M0 => fun a:ad => None\n    | M1 x y => fun a:ad => if Neqb x a then Some y else None\n    | M2 m1 m2 =>\n        fun a:ad =>\n          match a with\n          | N0 => MapGet m1 N0\n          | Npos xH => MapGet m2 N0\n          | Npos (xO p) => MapGet m1 (Npos p)\n          | Npos (xI p) => MapGet m2 (Npos p)\n          end\n    end.
-----
Definition newMap := M0.
-----
Definition MapSingleton := M1.
-----
Definition eqm (g g':ad -> option A) := forall a:ad, g a = g' a.
-----
Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).
-----
Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).

*****
A : Type
*****
eqm (MapGet newMap) (fun _ : ad => None)
+++++
Proof.
-----
Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).
Proof.

*****
A : Type
*****
eqm (MapGet newMap) (fun _ : ad => None)
+++++
simpl in |- *.
-----
Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).
Proof.
simpl in |- *.

*****
A : Type
*****
eqm (fun _ : ad => None) (fun _ : ad => None)
+++++
unfold eqm in |- *.
-----
Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).
Proof.
simpl in |- *.
unfold eqm in |- *.

*****
A : Type
*****
forall _ : ad, eq None None
+++++
trivial.
-----
Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).
Proof.
simpl in |- *.
unfold eqm in |- *.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapSingleton_semantics :\n   forall (a:ad) (y:A),\n     eqm (MapGet (MapSingleton a y))\n       (fun a':ad => if Neqb a a' then Some y else None).
-----
Lemma MapSingleton_semantics : forall (a:ad) (y:A), eqm (MapGet (MapSingleton a y)) (fun a':ad => if Neqb a a' then Some y else None).

*****
A : Type
*****
forall (a : ad) (y : A), eqm (MapGet (MapSingleton a y)) (fun a' : ad => if N.eqb a a' then Some y else None)
+++++
Proof.
-----
Lemma MapSingleton_semantics : forall (a:ad) (y:A), eqm (MapGet (MapSingleton a y)) (fun a':ad => if Neqb a a' then Some y else None).
Proof.

*****
A : Type
*****
forall (a : ad) (y : A), eqm (MapGet (MapSingleton a y)) (fun a' : ad => if N.eqb a a' then Some y else None)
+++++
simpl in |- *.
-----
Lemma MapSingleton_semantics : forall (a:ad) (y:A), eqm (MapGet (MapSingleton a y)) (fun a':ad => if Neqb a a' then Some y else None).
Proof.
simpl in |- *.

*****
A : Type
*****
forall (a : ad) (y : A), eqm (fun a0 : ad => if N.eqb a a0 then Some y else None) (fun a' : ad => if N.eqb a a' then Some y else None)
+++++
unfold eqm in |- *.
-----
Lemma MapSingleton_semantics : forall (a:ad) (y:A), eqm (MapGet (MapSingleton a y)) (fun a':ad => if Neqb a a' then Some y else None).
Proof.
simpl in |- *.
unfold eqm in |- *.

*****
A : Type
*****
forall (a : ad) (y : A) (a0 : ad), eq (if N.eqb a a0 then Some y else None) (if N.eqb a a0 then Some y else None)
+++++
trivial.
-----
Lemma MapSingleton_semantics : forall (a:ad) (y:A), eqm (MapGet (MapSingleton a y)) (fun a':ad => if Neqb a a' then Some y else None).
Proof.
simpl in |- *.
unfold eqm in |- *.
trivial.

*****

*****

+++++
Qed.
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.

*****
A : Type
*****
forall (a : ad) (y : A), eq (MapGet (M1 a y) a) (Some y)
+++++
Proof.
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.
Proof.

*****
A : Type
*****
forall (a : ad) (y : A), eq (MapGet (M1 a y) a) (Some y)
+++++
unfold MapGet in |- *.
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.
Proof.
unfold MapGet in |- *.

*****
A : Type
*****
forall (a : ad) (y : A), eq (if N.eqb a a then Some y else None) (Some y)
+++++
intros.
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.
Proof.
unfold MapGet in |- *.
intros.

*****
y : A
a : ad
A : Type
*****
eq (if N.eqb a a then Some y else None) (Some y)
+++++
rewrite (Neqb_correct a).
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.
Proof.
unfold MapGet in |- *.
intros.
rewrite (Neqb_correct a).

*****
y : A
a : ad
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.
Proof.
unfold MapGet in |- *.
intros.
rewrite (Neqb_correct a).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma M1_semantics_2 :\n   forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.
-----
Lemma M1_semantics_2 : forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.

*****
A : Type
*****
forall (a a' : ad) (y : A) (_ : eq (N.eqb a a') false), eq (MapGet (M1 a y) a') None
+++++
Proof.
-----
Lemma M1_semantics_2 : forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.
Proof.

*****
A : Type
*****
forall (a a' : ad) (y : A) (_ : eq (N.eqb a a') false), eq (MapGet (M1 a y) a') None
+++++
intros.
-----
Lemma M1_semantics_2 : forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.
Proof.
intros.

*****
H : eq (N.eqb a a') false
y : A
a,a' : ad
A : Type
*****
eq (MapGet (M1 a y) a') None
+++++
simpl in |- *.
-----
Lemma M1_semantics_2 : forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.
Proof.
intros.
simpl in |- *.

*****
H : eq (N.eqb a a') false
y : A
a,a' : ad
A : Type
*****
eq (if N.eqb a a' then Some y else None) None
+++++
rewrite H.
-----
Lemma M1_semantics_2 : forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.
Proof.
intros.
simpl in |- *.
rewrite H.

*****
H : eq (N.eqb a a') false
y : A
a,a' : ad
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma M1_semantics_2 : forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.
Proof.
intros.
simpl in |- *.
rewrite H.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma Map2_semantics_1 :\n   forall m m':Map,\n     eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).
-----
Lemma Map2_semantics_1 : forall m m':Map, eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet m) (fun a : ad => MapGet (M2 m m') (N.double a))
+++++
Proof.
-----
Lemma Map2_semantics_1 : forall m m':Map, eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet m) (fun a : ad => MapGet (M2 m m') (N.double a))
+++++
unfold eqm in |- *.
-----
Lemma Map2_semantics_1 : forall m m':Map, eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet m a) (MapGet (M2 m m') (N.double a))
+++++
simple induction a.
-----
Lemma Map2_semantics_1 : forall m m':Map, eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).
Proof.
unfold eqm in |- *.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet m N0) (MapGet (M2 m m') (N.double N0))
+++++
trivial.
-----
Lemma Map2_semantics_1 : forall m m':Map, eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).
Proof.
unfold eqm in |- *.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall p : positive, eq (MapGet m (Npos p)) (MapGet (M2 m m') (N.double (Npos p)))
+++++
trivial.
-----
Lemma Map2_semantics_1 : forall m m':Map, eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).
Proof.
unfold eqm in |- *.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma Map2_semantics_1_eq :\n   forall (m m':Map) (f:ad -> option A),\n     eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).
-----
Lemma Map2_semantics_1_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).

*****
A : Type
*****
forall (m m' : Map) (f : forall _ : ad, option A) (_ : eqm (MapGet (M2 m m')) f), eqm (MapGet m) (fun a : ad => f (N.double a))
+++++
Proof.
-----
Lemma Map2_semantics_1_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).
Proof.

*****
A : Type
*****
forall (m m' : Map) (f : forall _ : ad, option A) (_ : eqm (MapGet (M2 m m')) f), eqm (MapGet m) (fun a : ad => f (N.double a))
+++++
unfold eqm in |- *.
-----
Lemma Map2_semantics_1_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (f : forall _ : ad, option A) (_ : forall a : ad, eq (MapGet (M2 m m') a) (f a)) (a : ad), eq (MapGet m a) (f (N.double a))
+++++
intros.
-----
Lemma Map2_semantics_1_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
H : forall a : ad, eq (MapGet (M2 m m') a) (f a)
f : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet m a) (f (N.double a))
+++++
rewrite <- (H (Ndouble a)).
-----
Lemma Map2_semantics_1_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndouble a)).

*****
a : ad
H : forall a : ad, eq (MapGet (M2 m m') a) (f a)
f : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet m a) (MapGet (M2 m m') (N.double a))
+++++
exact (Map2_semantics_1 m m' a).
-----
Lemma Map2_semantics_1_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndouble a)).
exact (Map2_semantics_1 m m' a).

*****

*****

+++++
Qed.
-----
Lemma Map2_semantics_2 :\n   forall m m':Map,\n     eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).
-----
Lemma Map2_semantics_2 : forall m m':Map, eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet m') (fun a : ad => MapGet (M2 m m') (N.succ_double a))
+++++
Proof.
-----
Lemma Map2_semantics_2 : forall m m':Map, eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet m') (fun a : ad => MapGet (M2 m m') (N.succ_double a))
+++++
unfold eqm in |- *.
-----
Lemma Map2_semantics_2 : forall m m':Map, eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet m' a) (MapGet (M2 m m') (N.succ_double a))
+++++
simple induction a.
-----
Lemma Map2_semantics_2 : forall m m':Map, eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet m' N0) (MapGet (M2 m m') (N.succ_double N0))
+++++
trivial.
-----
Lemma Map2_semantics_2 : forall m m':Map, eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall p : positive, eq (MapGet m' (Npos p)) (MapGet (M2 m m') (N.succ_double (Npos p)))
+++++
trivial.
-----
Lemma Map2_semantics_2 : forall m m':Map, eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma Map2_semantics_2_eq :\n   forall (m m':Map) (f:ad -> option A),\n     eqm (MapGet (M2 m m')) f ->\n     eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).
-----
Lemma Map2_semantics_2_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).

*****
A : Type
*****
forall (m m' : Map) (f : forall _ : ad, option A) (_ : eqm (MapGet (M2 m m')) f), eqm (MapGet m') (fun a : ad => f (N.succ_double a))
+++++
Proof.
-----
Lemma Map2_semantics_2_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).
Proof.

*****
A : Type
*****
forall (m m' : Map) (f : forall _ : ad, option A) (_ : eqm (MapGet (M2 m m')) f), eqm (MapGet m') (fun a : ad => f (N.succ_double a))
+++++
unfold eqm in |- *.
-----
Lemma Map2_semantics_2_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (f : forall _ : ad, option A) (_ : forall a : ad, eq (MapGet (M2 m m') a) (f a)) (a : ad), eq (MapGet m' a) (f (N.succ_double a))
+++++
intros.
-----
Lemma Map2_semantics_2_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
H : forall a : ad, eq (MapGet (M2 m m') a) (f a)
f : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet m' a) (f (N.succ_double a))
+++++
rewrite <- (H (Ndouble_plus_one a)).
-----
Lemma Map2_semantics_2_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndouble_plus_one a)).

*****
a : ad
H : forall a : ad, eq (MapGet (M2 m m') a) (f a)
f : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet m' a) (MapGet (M2 m m') (N.succ_double a))
+++++
exact (Map2_semantics_2 m m' a).
-----
Lemma Map2_semantics_2_eq : forall (m m':Map) (f:ad -> option A), eqm (MapGet (M2 m m')) f -> eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndouble_plus_one a)).
exact (Map2_semantics_2 m m' a).

*****

*****

+++++
Qed.
-----
Lemma MapGet_M2_bit_0_0 :\n   forall a:ad,\n     Nbit0 a = false ->\n     forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).

*****
A : Type
*****
forall (a : ad) (_ : eq (N.odd a) false) (m m' : Map), eq (MapGet (M2 m m') a) (MapGet m (N.div2 a))
+++++
Proof.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.

*****
A : Type
*****
forall (a : ad) (_ : eq (N.odd a) false) (m m' : Map), eq (MapGet (M2 m m') a) (MapGet m (N.div2 a))
+++++
simple induction a.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.

*****
a : ad
A : Type
*****
forall (_ : eq (N.odd N0) false) (m m' : Map), eq (MapGet (M2 m m') N0) (MapGet m (N.div2 N0))
+++++
trivial.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.

*****
a : ad
A : Type
*****
forall (p : positive) (_ : eq (N.odd (Npos p)) false) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m (N.div2 (Npos p)))
+++++
trivial.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.
trivial.

*****
a : ad
A : Type
*****
forall (p : positive) (_ : eq (N.odd (Npos p)) false) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m (N.div2 (Npos p)))
+++++
simple induction p.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.
trivial.
simple induction p.

*****
p : positive
a : ad
A : Type
*****
forall (p : positive) (_ : forall (_ : eq (N.odd (Npos p)) false) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m (N.div2 (Npos p)))) (_ : eq (N.odd (Npos (xI p))) false) (m m' : Map), eq (MapGet (M2 m m') (Npos (xI p))) (MapGet m (N.div2 (Npos (xI p))))
+++++
intros.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.
trivial.
simple induction p.
intros.

*****
m,m' : Map
H0 : eq (N.odd (Npos (xI p0))) false
H : forall (_ : eq (N.odd (Npos p0)) false) (m m' : Map),\neq (MapGet (M2 m m') (Npos p0)) (MapGet m (N.div2 (Npos p0)))
p,p0 : positive
a : ad
A : Type
*****
eq (MapGet (M2 m m') (Npos (xI p0))) (MapGet m (N.div2 (Npos (xI p0))))
+++++
discriminate H0.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.
trivial.
simple induction p.

*****
p : positive
a : ad
A : Type
*****
forall (p : positive) (_ : forall (_ : eq (N.odd (Npos p)) false) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m (N.div2 (Npos p)))) (_ : eq (N.odd (Npos (xO p))) false) (m m' : Map), eq (MapGet (M2 m m') (Npos (xO p))) (MapGet m (N.div2 (Npos (xO p))))
+++++
trivial.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.
trivial.
simple induction p.

*****
p : positive
a : ad
A : Type
*****
forall (_ : eq (N.odd (Npos xH)) false) (m m' : Map), eq (MapGet (M2 m m') (Npos xH)) (MapGet m (N.div2 (Npos xH)))
+++++
intros.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.
trivial.
simple induction p.
intros.

*****
m,m' : Map
H : eq (N.odd (Npos xH)) false
p : positive
a : ad
A : Type
*****
eq (MapGet (M2 m m') (Npos xH)) (MapGet m (N.div2 (Npos xH)))
+++++
discriminate H.
-----
Lemma MapGet_M2_bit_0_0 : forall a:ad, Nbit0 a = false -> forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).
Proof.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma MapGet_M2_bit_0_1 :\n   forall a:ad,\n     Nbit0 a = true ->\n     forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).

*****
A : Type
*****
forall (a : ad) (_ : eq (N.odd a) true) (m m' : Map), eq (MapGet (M2 m m') a) (MapGet m' (N.div2 a))
+++++
Proof.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.

*****
A : Type
*****
forall (a : ad) (_ : eq (N.odd a) true) (m m' : Map), eq (MapGet (M2 m m') a) (MapGet m' (N.div2 a))
+++++
simple induction a.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.

*****
a : ad
A : Type
*****
forall (_ : eq (N.odd N0) true) (m m' : Map), eq (MapGet (M2 m m') N0) (MapGet m' (N.div2 N0))
+++++
intros.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.
intros.

*****
m,m' : Map
H : eq (N.odd N0) true
a : ad
A : Type
*****
eq (MapGet (M2 m m') N0) (MapGet m' (N.div2 N0))
+++++
discriminate H.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.

*****
a : ad
A : Type
*****
forall (p : positive) (_ : eq (N.odd (Npos p)) true) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m' (N.div2 (Npos p)))
+++++
simple induction p.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
A : Type
*****
forall (p : positive) (_ : forall (_ : eq (N.odd (Npos p)) true) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m' (N.div2 (Npos p)))) (_ : eq (N.odd (Npos (xI p))) true) (m m' : Map), eq (MapGet (M2 m m') (Npos (xI p))) (MapGet m' (N.div2 (Npos (xI p))))
+++++
trivial.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
A : Type
*****
forall (p : positive) (_ : forall (_ : eq (N.odd (Npos p)) true) (m m' : Map), eq (MapGet (M2 m m') (Npos p)) (MapGet m' (N.div2 (Npos p)))) (_ : eq (N.odd (Npos (xO p))) true) (m m' : Map), eq (MapGet (M2 m m') (Npos (xO p))) (MapGet m' (N.div2 (Npos (xO p))))
+++++
intros.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.
simple induction p.
intros.

*****
m,m' : Map
H0 : eq (N.odd (Npos (xO p0))) true
H : forall (_ : eq (N.odd (Npos p0)) true) (m m' : Map),\neq (MapGet (M2 m m') (Npos p0)) (MapGet m' (N.div2 (Npos p0)))
p,p0 : positive
a : ad
A : Type
*****
eq (MapGet (M2 m m') (Npos (xO p0))) (MapGet m' (N.div2 (Npos (xO p0))))
+++++
discriminate H0.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
A : Type
*****
forall (_ : eq (N.odd (Npos xH)) true) (m m' : Map), eq (MapGet (M2 m m') (Npos xH)) (MapGet m' (N.div2 (Npos xH)))
+++++
trivial.
-----
Lemma MapGet_M2_bit_0_1 : forall a:ad, Nbit0 a = true -> forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).
Proof.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma MapGet_M2_bit_0_if :\n   forall (m m':Map) (a:ad),\n     MapGet (M2 m m') a =\n     (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
Proof.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
intros.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
intro H.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
rewrite H.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (MapGet m' (N.div2 a))
+++++
apply MapGet_M2_bit_0_1.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.
apply MapGet_M2_bit_0_1.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) true
+++++
assumption.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
intro H.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
rewrite H.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (MapGet m (N.div2 a))
+++++
apply MapGet_M2_bit_0_0.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.
apply MapGet_M2_bit_0_0.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) false
+++++
assumption.
-----
Lemma MapGet_M2_bit_0_if : forall (m m':Map) (a:ad), MapGet (M2 m m') a = (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****

*****

+++++
Qed.
-----
Lemma MapGet_M2_bit_0 :\n   forall (m m' m'':Map) (a:ad),\n     (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) =\n     MapGet m (Ndiv2 a).
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).

*****
A : Type
*****
forall (m m' m'' : Map) (a : ad), eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
Proof.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.

*****
A : Type
*****
forall (m m' m'' : Map) (a : ad), eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
intros.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.

*****
a : ad
m,m',m'' : Map
A : Type
*****
eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
a : ad
m,m',m'' : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
intro H.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.

*****
H : eq (N.odd a) true
a : ad
m,m',m'' : Map
A : Type
*****
eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
rewrite H.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.

*****
H : eq (N.odd a) true
a : ad
m,m',m'' : Map
A : Type
*****
eq (MapGet (M2 m' m) a) (MapGet m (N.div2 a))
+++++
apply MapGet_M2_bit_0_1.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.
apply MapGet_M2_bit_0_1.

*****
H : eq (N.odd a) true
a : ad
m,m',m'' : Map
A : Type
*****
eq (N.odd a) true
+++++
assumption.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
a : ad
m,m',m'' : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
intro H.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.

*****
H : eq (N.odd a) false
a : ad
m,m',m'' : Map
A : Type
*****
eq (if N.odd a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
rewrite H.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.

*****
H : eq (N.odd a) false
a : ad
m,m',m'' : Map
A : Type
*****
eq (MapGet (M2 m m'') a) (MapGet m (N.div2 a))
+++++
apply MapGet_M2_bit_0_0.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite H.
apply MapGet_M2_bit_0_0.

*****
H : eq (N.odd a) false
a : ad
m,m',m'' : Map
A : Type
*****
eq (N.odd a) false
+++++
assumption.
-----
Lemma MapGet_M2_bit_0 : forall (m m' m'':Map) (a:ad), (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) = MapGet m (Ndiv2 a).
Proof.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****

*****

+++++
Qed.
-----
Lemma Map2_semantics_3 :\n   forall m m':Map,\n     eqm (MapGet (M2 m m'))\n       (fun a:ad =>\n          match Nbit0 a with\n          | false => MapGet m (Ndiv2 a)\n          | true => MapGet m' (Ndiv2 a)\n          end).
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (M2 m m')) (fun a : ad => if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
Proof.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (M2 m m')) (fun a : ad => if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
unfold eqm in |- *.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
simple induction a.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') N0) (if N.odd N0 then MapGet m' (N.div2 N0) else MapGet m (N.div2 N0))
+++++
trivial.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall p : positive, eq (MapGet (M2 m m') (Npos p)) (if N.odd (Npos p) then MapGet m' (N.div2 (Npos p)) else MapGet m (N.div2 (Npos p)))
+++++
trivial.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.
trivial.

*****
a : ad
m,m' : Map
A : Type
*****
forall p : positive, eq (MapGet (M2 m m') (Npos p)) (if N.odd (Npos p) then MapGet m' (N.div2 (Npos p)) else MapGet m (N.div2 (Npos p)))
+++++
simple induction p.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.
trivial.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (_ : eq (MapGet (M2 m m') (Npos p)) (if N.odd (Npos p) then MapGet m' (N.div2 (Npos p)) else MapGet m (N.div2 (Npos p)))), eq (MapGet (M2 m m') (Npos (xI p))) (if N.odd (Npos (xI p)) then MapGet m' (N.div2 (Npos (xI p))) else MapGet m (N.div2 (Npos (xI p))))
+++++
trivial.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.
trivial.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (_ : eq (MapGet (M2 m m') (Npos p)) (if N.odd (Npos p) then MapGet m' (N.div2 (Npos p)) else MapGet m (N.div2 (Npos p)))), eq (MapGet (M2 m m') (Npos (xO p))) (if N.odd (Npos (xO p)) then MapGet m' (N.div2 (Npos (xO p))) else MapGet m (N.div2 (Npos (xO p))))
+++++
trivial.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.
trivial.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') (Npos xH)) (if N.odd (Npos xH) then MapGet m' (N.div2 (Npos xH)) else MapGet m (N.div2 (Npos xH)))
+++++
trivial.
-----
Lemma Map2_semantics_3 : forall m m':Map, eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => MapGet m (Ndiv2 a) | true => MapGet m' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma Map2_semantics_3_eq :\n   forall (m m':Map) (f f':ad -> option A),\n     eqm (MapGet m) f ->\n     eqm (MapGet m') f' ->\n     eqm (MapGet (M2 m m'))\n       (fun a:ad =>\n          match Nbit0 a with\n          | false => f (Ndiv2 a)\n          | true => f' (Ndiv2 a)\n          end).
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).

*****
A : Type
*****
forall (m m' : Map) (f f' : forall _ : ad, option A) (_ : eqm (MapGet m) f) (_ : eqm (MapGet m') f'), eqm (MapGet (M2 m m')) (fun a : ad => if N.odd a then f' (N.div2 a) else f (N.div2 a))
+++++
Proof.
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).
Proof.

*****
A : Type
*****
forall (m m' : Map) (f f' : forall _ : ad, option A) (_ : eqm (MapGet m) f) (_ : eqm (MapGet m') f'), eqm (MapGet (M2 m m')) (fun a : ad => if N.odd a then f' (N.div2 a) else f (N.div2 a))
+++++
unfold eqm in |- *.
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (f f' : forall _ : ad, option A) (_ : forall a : ad, eq (MapGet m a) (f a)) (_ : forall a : ad, eq (MapGet m' a) (f' a)) (a : ad), eq (MapGet (M2 m m') a) (if N.odd a then f' (N.div2 a) else f (N.div2 a))
+++++
intros.
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
H0 : forall a : ad, eq (MapGet m' a) (f' a)
H : forall a : ad, eq (MapGet m a) (f a)
f,f' : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (if N.odd a then f' (N.div2 a) else f (N.div2 a))
+++++
rewrite <- (H (Ndiv2 a)).
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndiv2 a)).

*****
a : ad
H0 : forall a : ad, eq (MapGet m' a) (f' a)
H : forall a : ad, eq (MapGet m a) (f a)
f,f' : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (if N.odd a then f' (N.div2 a) else MapGet m (N.div2 a))
+++++
rewrite <- (H0 (Ndiv2 a)).
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndiv2 a)).
rewrite <- (H0 (Ndiv2 a)).

*****
a : ad
H0 : forall a : ad, eq (MapGet m' a) (f' a)
H : forall a : ad, eq (MapGet m a) (f a)
f,f' : forall _ : ad, option A
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a))
+++++
exact (Map2_semantics_3 m m' a).
-----
Lemma Map2_semantics_3_eq : forall (m m':Map) (f f':ad -> option A), eqm (MapGet m) f -> eqm (MapGet m') f' -> eqm (MapGet (M2 m m')) (fun a:ad => match Nbit0 a with | false => f (Ndiv2 a) | true => f' (Ndiv2 a) end).
Proof.
unfold eqm in |- *.
intros.
rewrite <- (H (Ndiv2 a)).
rewrite <- (H0 (Ndiv2 a)).
exact (Map2_semantics_3 m m' a).

*****

*****

+++++
Qed.
-----
Fixpoint MapPut1 (a:ad) (y:A) (a':ad) (y':A) (p:positive) {struct p} :\n   Map :=\n    match p with\n    | xO p' =>\n        let m := MapPut1 (Ndiv2 a) y (Ndiv2 a') y' p' in\n        match Nbit0 a with\n        | false => M2 m M0\n        | true => M2 M0 m\n        end\n    | _ =>\n        match Nbit0 a with\n        | false => M2 (M1 (Ndiv2 a) y) (M1 (Ndiv2 a') y')\n        | true => M2 (M1 (Ndiv2 a') y') (M1 (Ndiv2 a) y)\n        end\n    end.
-----
Lemma MapGet_if_commute :\n   forall (b:bool) (m m':Map) (a:ad),\n     MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).
-----
Lemma MapGet_if_commute : forall (b:bool) (m m':Map) (a:ad), MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).

*****
A : Type
*****
forall (b : bool) (m m' : Map) (a : ad), eq (MapGet (if b then m else m') a) (if b then MapGet m a else MapGet m' a)
+++++
Proof.
-----
Lemma MapGet_if_commute : forall (b:bool) (m m':Map) (a:ad), MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).
Proof.

*****
A : Type
*****
forall (b : bool) (m m' : Map) (a : ad), eq (MapGet (if b then m else m') a) (if b then MapGet m a else MapGet m' a)
+++++
intros.
-----
Lemma MapGet_if_commute : forall (b:bool) (m m':Map) (a:ad), MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).
Proof.
intros.

*****
a : ad
m,m' : Map
b : bool
A : Type
*****
eq (MapGet (if b then m else m') a) (if b then MapGet m a else MapGet m' a)
+++++
case b.
-----
Lemma MapGet_if_commute : forall (b:bool) (m m':Map) (a:ad), MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).
Proof.
intros.
case b.

*****
a : ad
m,m' : Map
b : bool
A : Type
*****
eq (MapGet m a) (MapGet m a)
+++++
trivial.
-----
Lemma MapGet_if_commute : forall (b:bool) (m m':Map) (a:ad), MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).
Proof.
intros.
case b.

*****
a : ad
m,m' : Map
b : bool
A : Type
*****
eq (MapGet m' a) (MapGet m' a)
+++++
trivial.
-----
Lemma MapGet_if_commute : forall (b:bool) (m m':Map) (a:ad), MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).
Proof.
intros.
case b.

*****

*****

+++++
Qed.
-----
Lemma MapGet_if_same :\n   forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.
-----
Lemma MapGet_if_same : forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.

*****
A : Type
*****
forall (m : Map) (b : bool) (a : ad), eq (MapGet (if b then m else m) a) (MapGet m a)
+++++
Proof.
-----
Lemma MapGet_if_same : forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.
Proof.

*****
A : Type
*****
forall (m : Map) (b : bool) (a : ad), eq (MapGet (if b then m else m) a) (MapGet m a)
+++++
simple induction b.
-----
Lemma MapGet_if_same : forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.
Proof.
simple induction b.

*****
b : bool
m : Map
A : Type
*****
forall a : ad, eq (MapGet m a) (MapGet m a)
+++++
trivial.
-----
Lemma MapGet_if_same : forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.
Proof.
simple induction b.

*****
b : bool
m : Map
A : Type
*****
forall a : ad, eq (MapGet m a) (MapGet m a)
+++++
trivial.
-----
Lemma MapGet_if_same : forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.
Proof.
simple induction b.

*****

*****

+++++
Qed.
-----
Lemma MapGet_M2_bit_0_2 :\n   forall (m m' m'':Map) (a:ad),\n     MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a =\n     MapGet m' (Ndiv2 a).
-----
Lemma MapGet_M2_bit_0_2 : forall (m m' m'':Map) (a:ad), MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a = MapGet m' (Ndiv2 a).

*****
A : Type
*****
forall (m m' m'' : Map) (a : ad), eq (MapGet (if N.odd a then M2 m m' else M2 m' m'') a) (MapGet m' (N.div2 a))
+++++
Proof.
-----
Lemma MapGet_M2_bit_0_2 : forall (m m' m'':Map) (a:ad), MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a = MapGet m' (Ndiv2 a).
Proof.

*****
A : Type
*****
forall (m m' m'' : Map) (a : ad), eq (MapGet (if N.odd a then M2 m m' else M2 m' m'') a) (MapGet m' (N.div2 a))
+++++
intros.
-----
Lemma MapGet_M2_bit_0_2 : forall (m m' m'':Map) (a:ad), MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a = MapGet m' (Ndiv2 a).
Proof.
intros.

*****
a : ad
m,m',m'' : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m m' else M2 m' m'') a) (MapGet m' (N.div2 a))
+++++
rewrite MapGet_if_commute.
-----
Lemma MapGet_M2_bit_0_2 : forall (m m' m'':Map) (a:ad), MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a = MapGet m' (Ndiv2 a).
Proof.
intros.
rewrite MapGet_if_commute.

*****
a : ad
m,m',m'' : Map
A : Type
*****
eq (if N.odd a then MapGet (M2 m m') a else MapGet (M2 m' m'') a) (MapGet m' (N.div2 a))
+++++
apply MapGet_M2_bit_0.
-----
Lemma MapGet_M2_bit_0_2 : forall (m m' m'':Map) (a:ad), MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a = MapGet m' (Ndiv2 a).
Proof.
intros.
rewrite MapGet_if_commute.
apply MapGet_M2_bit_0.

*****

*****

+++++
Qed.
-----
Lemma MapPut1_semantics_1 :\n   forall (p:positive) (a a':ad) (y y':A),\n     Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a) (Some y)
+++++
Proof.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a) (Some y)
+++++
simple induction p.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a) (Some y)) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos (xI p))), eq (MapGet (MapPut1 a y a' y' (xI p)) a) (Some y)
+++++
intros.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' (xI p0)) a) (Some y)
+++++
unfold MapPut1 in |- *.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a) (Some y)
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite MapGet_M2_bit_0_2.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a)) (Some y)
+++++
apply M1_semantics_1.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a) (Some y)) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos (xO p))), eq (MapGet (MapPut1 a y a' y' (xO p)) a) (Some y)
+++++
intros.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' (xO p0)) a) (Some y)
+++++
simpl in |- *.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a) (Some y)
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite MapGet_M2_bit_0_2.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 (N.div2 a) y (N.div2 a') y' p0) (N.div2 a)) (Some y)
+++++
apply H.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite MapGet_M2_bit_0_2.
apply H.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
+++++
rewrite <- Nxor_div2.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite MapGet_M2_bit_0_2.
apply H.
rewrite <- Nxor_div2.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (N.div2 (N.lxor a a')) (Npos p0)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite MapGet_M2_bit_0_2.
apply H.
rewrite <- Nxor_div2.
rewrite H0.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a) (Some y)
p,p0 : positive
A : Type
*****
eq (N.div2 (Npos (xO p0))) (Npos p0)
+++++
reflexivity.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos xH)), eq (MapGet (MapPut1 a y a' y' xH) a) (Some y)
+++++
intros.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' xH) a) (Some y)
+++++
unfold MapPut1 in |- *.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a) (Some y)
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite MapGet_M2_bit_0_2.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a)) (Some y)
+++++
apply M1_semantics_1.
-----
Lemma MapPut1_semantics_1 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma MapPut1_semantics_2 :\n   forall (p:positive) (a a':ad) (y y':A),\n     Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a') (Some y')
+++++
Proof.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a') (Some y')
+++++
simple induction p.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a') (Some y')) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos (xI p))), eq (MapGet (MapPut1 a y a' y' (xI p)) a') (Some y')
+++++
intros.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' (xI p0)) a') (Some y')
+++++
unfold MapPut1 in |- *.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a') (Some y')
+++++
rewrite (Nneg_bit0_2 a a' p0 H0).
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite (Nneg_bit0_2 a a' p0 H0).

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (if negb (N.odd a') then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a') (Some y')
+++++
rewrite if_negb.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite (Nneg_bit0_2 a a' p0 H0).
rewrite if_negb.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a' then M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y') else M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y)) a') (Some y')
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite (Nneg_bit0_2 a a' p0 H0).
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.

*****
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a')) (Some y')
+++++
apply M1_semantics_1.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut1 a y a' y' p) a') (Some y')) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos (xO p))), eq (MapGet (MapPut1 a y a' y' (xO p)) a') (Some y')
+++++
intros.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' (xO p0)) a') (Some y')
+++++
simpl in |- *.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a') (Some y')
+++++
rewrite (Nsame_bit0 a a' p0 H0).
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite (Nsame_bit0 a a' p0 H0).

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a' then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a') (Some y')
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite MapGet_M2_bit_0_2.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 (N.div2 a) y (N.div2 a') y' p0) (N.div2 a')) (Some y')
+++++
apply H.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite MapGet_M2_bit_0_2.
apply H.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
+++++
rewrite <- Nxor_div2.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite MapGet_M2_bit_0_2.
apply H.
rewrite <- Nxor_div2.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (N.div2 (N.lxor a a')) (Npos p0)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
simpl in |- *.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite MapGet_M2_bit_0_2.
apply H.
rewrite <- Nxor_div2.
rewrite H0.

*****
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0)),\neq (MapGet (MapPut1 a y a' y' p0) a') (Some y')
p,p0 : positive
A : Type
*****
eq (N.div2 (Npos (xO p0))) (Npos p0)
+++++
reflexivity.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos xH)), eq (MapGet (MapPut1 a y a' y' xH) a') (Some y')
+++++
intros.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' xH) a') (Some y')
+++++
unfold MapPut1 in |- *.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a') (Some y')
+++++
rewrite (Nneg_bit0_1 a a' H).
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite (Nneg_bit0_1 a a' H).

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (if negb (N.odd a') then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a') (Some y')
+++++
rewrite if_negb.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite (Nneg_bit0_1 a a' H).
rewrite if_negb.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a' then M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y') else M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y)) a') (Some y')
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
rewrite (Nneg_bit0_1 a a' H).
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.

*****
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a')) (Some y')
+++++
apply M1_semantics_1.
-----
Lemma MapPut1_semantics_2 : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma MapGet_M2_both_None :\n   forall (m m':Map) (a:ad),\n     MapGet m (Ndiv2 a) = None ->\n     MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (_ : eq (MapGet m (N.div2 a)) None) (_ : eq (MapGet m' (N.div2 a)) None), eq (MapGet (M2 m m') a) None
+++++
Proof.
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (_ : eq (MapGet m (N.div2 a)) None) (_ : eq (MapGet m' (N.div2 a)) None), eq (MapGet (M2 m m') a) None
+++++
intros.
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
Proof.
intros.

*****
H0 : eq (MapGet m' (N.div2 a)) None
H : eq (MapGet m (N.div2 a)) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m m') a) None
+++++
rewrite (Map2_semantics_3 m m' a).
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
Proof.
intros.
rewrite (Map2_semantics_3 m m' a).

*****
H0 : eq (MapGet m' (N.div2 a)) None
H : eq (MapGet m (N.div2 a)) None
a : ad
m,m' : Map
A : Type
*****
eq (if N.odd a then MapGet m' (N.div2 a) else MapGet m (N.div2 a)) None
+++++
case (Nbit0 a).
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
Proof.
intros.
rewrite (Map2_semantics_3 m m' a).
case (Nbit0 a).

*****
H0 : eq (MapGet m' (N.div2 a)) None
H : eq (MapGet m (N.div2 a)) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet m' (N.div2 a)) None
+++++
assumption.
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
Proof.
intros.
rewrite (Map2_semantics_3 m m' a).
case (Nbit0 a).

*****
H0 : eq (MapGet m' (N.div2 a)) None
H : eq (MapGet m (N.div2 a)) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet m (N.div2 a)) None
+++++
assumption.
-----
Lemma MapGet_M2_both_None : forall (m m':Map) (a:ad), MapGet m (Ndiv2 a) = None -> MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
Proof.
intros.
rewrite (Map2_semantics_3 m m' a).
case (Nbit0 a).

*****

*****

+++++
Qed.
-----
Lemma MapPut1_semantics_3 :\n   forall (p:positive) (a a' a0:ad) (y y':A),\n     Nxor a a' = Npos p ->\n     Neqb a a0 = false ->\n     Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.

*****
A : Type
*****
forall (p : positive) (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' p) a0) None
+++++
Proof.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.

*****
A : Type
*****
forall (p : positive) (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' p) a0) None
+++++
simple induction p.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' p) a0) None) (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos (xI p))) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' (xI p)) a0) None
+++++
intros.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' (xI p0)) a0) None
+++++
unfold MapPut1 in |- *.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
elim (Nneq_elim a a0 H1).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.odd a) (negb (N.odd a0)), eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite H3.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if negb (N.odd a0) then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite if_negb.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a0 then M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y') else M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y)) a0) None
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
apply Ndiv2_bit_neq.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb a' a0) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.odd a') (N.odd a0)
+++++
rewrite (Nneg_bit0_2 a a' p0 H0) in H3.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_2 a a' p0 H0) in H3.

*****
H3 : eq (negb (N.odd a')) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.odd a') (N.odd a0)
+++++
rewrite (negb_intro (Nbit0 a')).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_2 a a' p0 H0) in H3.
rewrite (negb_intro (Nbit0 a')).

*****
H3 : eq (negb (N.odd a')) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (negb (negb (N.odd a'))) (N.odd a0)
+++++
rewrite (negb_intro (Nbit0 a0)).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_2 a a' p0 H0) in H3.
rewrite (negb_intro (Nbit0 a')).
rewrite (negb_intro (Nbit0 a0)).

*****
H3 : eq (negb (N.odd a')) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (negb (negb (N.odd a'))) (negb (negb (N.odd a0)))
+++++
rewrite H3.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_2 a a' p0 H0) in H3.
rewrite (negb_intro (Nbit0 a')).
rewrite (negb_intro (Nbit0 a0)).
rewrite H3.

*****
H3 : eq (negb (N.odd a')) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (negb (negb (N.odd a0))) (negb (negb (N.odd a0)))
+++++
reflexivity.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.eqb (N.div2 a) (N.div2 a0)) false, eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.

*****
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
elim (Nneq_elim a' a0 H2).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).

*****
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.odd a') (negb (N.odd a0)), eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite (Nneg_bit0_2 a a' p0 H0).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nneg_bit0_2 a a' p0 H0).

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if negb (N.odd a') then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite H4.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nneg_bit0_2 a a' p0 H0).
rewrite H4.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if negb (negb (N.odd a0)) then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite (negb_elim (Nbit0 a0)).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nneg_bit0_2 a a' p0 H0).
rewrite H4.
rewrite (negb_elim (Nbit0 a0)).

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a0 then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nneg_bit0_2 a a' p0 H0).
rewrite H4.
rewrite (negb_elim (Nbit0 a0)).
rewrite MapGet_M2_bit_0_2.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nneg_bit0_2 a a' p0 H0).
rewrite H4.
rewrite (negb_elim (Nbit0 a0)).
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).

*****
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.eqb (N.div2 a') (N.div2 a0)) false, eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
case (Nbit0 a).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y)) a0) None
+++++
apply MapGet_M2_both_None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
apply MapGet_M2_both_None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
unfold MapPut1 in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xI p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (p : positive) (_ : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' p) a0) None) (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos (xO p))) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' (xO p)) a0) None
+++++
intros.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' (xO p0)) a0) None
+++++
simpl in |- *.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
elim (Nneq_elim a a0 H1).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.odd a) (negb (N.odd a0)), eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
rewrite H3.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if negb (N.odd a0) then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
rewrite if_negb.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a0 then M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0 else M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0)) a0) None
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
rewrite H3.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.

*****
H3 : eq (N.odd a) (negb (N.odd a0))
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet M0 (N.div2 a0)) None
+++++
reflexivity.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).

*****
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.eqb (N.div2 a) (N.div2 a0)) false, eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.

*****
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
elim (Nneq_elim a' a0 H2).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).

*****
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.odd a') (negb (N.odd a0)), eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
rewrite (Nsame_bit0 a a' p0 H0).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nsame_bit0 a a' p0 H0).

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a' then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
rewrite H4.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite H4.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if negb (N.odd a0) then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
rewrite if_negb.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite H4.
rewrite if_negb.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a0 then M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0 else M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0)) a0) None
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
rewrite (Nsame_bit0 a a' p0 H0).
rewrite H4.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.

*****
H4 : eq (N.odd a') (negb (N.odd a0))
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet M0 (N.div2 a0)) None
+++++
reflexivity.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).

*****
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.eqb (N.div2 a') (N.div2 a0)) false, eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
forall _ : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0), eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) else M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
case (Nbit0 a).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M2 M0 (MapPut1 (N.div2 a) y (N.div2 a') y' p0)) a0) None
+++++
apply MapGet_M2_both_None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet M0 (N.div2 a0)) None
+++++
trivial.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 (N.div2 a) y (N.div2 a') y' p0) (N.div2 a0)) None
+++++
trivial.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 (N.div2 a) y (N.div2 a') y' p0) (N.div2 a0)) None
+++++
apply H.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.
apply H.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.
apply H.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.
apply H.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (M2 (MapPut1 (N.div2 a) y (N.div2 a') y' p0) M0) a0) None
+++++
apply MapGet_M2_both_None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 (N.div2 a) y (N.div2 a') y' p0) (N.div2 a0)) None
+++++
trivial.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet (MapPut1 (N.div2 a) y (N.div2 a') y' p0) (N.div2 a0)) None
+++++
apply H.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.
apply H.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.
apply H.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
trivial.
apply H.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H5 : eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (MapGet M0 (N.div2 a0)) None
+++++
trivial.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.lxor (N.div2 a) (N.div2 a')) (Npos p0)
+++++
rewrite <- Nxor_div2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
rewrite <- Nxor_div2.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.div2 (N.lxor a a')) (Npos p0)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H1).
intro.
elim (Nneq_elim a' a0 H2).
intro.
cut (Nxor (Ndiv2 a) (Ndiv2 a') = Npos p0).
rewrite <- Nxor_div2.
rewrite H0.

*****
H4 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H3 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H2 : eq (N.eqb a' a0) false
H1 : eq (N.eqb a a0) false
H0 : eq (N.lxor a a') (Npos (xO p0))
y,y' : A
a,a',a0 : ad
H : forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p0))\n (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false),\neq (MapGet (MapPut1 a y a' y' p0) a0) None
p,p0 : positive
A : Type
*****
eq (N.div2 (Npos (xO p0))) (Npos p0)
+++++
reflexivity.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.

*****
p : positive
A : Type
*****
forall (a a' a0 : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos xH)) (_ : eq (N.eqb a a0) false) (_ : eq (N.eqb a' a0) false), eq (MapGet (MapPut1 a y a' y' xH) a0) None
+++++
intros.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.

*****
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' xH) a0) None
+++++
simpl in |- *.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
elim (Nneq_elim a a0 H0).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).

*****
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
forall _ : eq (N.odd a) (negb (N.odd a0)), eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite H2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if negb (N.odd a0) then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite if_negb.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a0 then M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y') else M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y)) a0) None
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
apply Ndiv2_bit_neq.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb a' a0) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.

*****
H2 : eq (N.odd a) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.odd a') (N.odd a0)
+++++
rewrite (Nneg_bit0_1 a a' H) in H2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_1 a a' H) in H2.

*****
H2 : eq (negb (N.odd a')) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.odd a') (N.odd a0)
+++++
rewrite (negb_intro (Nbit0 a')).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_1 a a' H) in H2.
rewrite (negb_intro (Nbit0 a')).

*****
H2 : eq (negb (N.odd a')) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (negb (negb (N.odd a'))) (N.odd a0)
+++++
rewrite (negb_intro (Nbit0 a0)).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_1 a a' H) in H2.
rewrite (negb_intro (Nbit0 a')).
rewrite (negb_intro (Nbit0 a0)).

*****
H2 : eq (negb (N.odd a')) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (negb (negb (N.odd a'))) (negb (negb (N.odd a0)))
+++++
rewrite H2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
rewrite H2.
rewrite if_negb.
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.
apply Ndiv2_bit_neq.
rewrite (Nneg_bit0_1 a a' H) in H2.
rewrite (negb_intro (Nbit0 a')).
rewrite (negb_intro (Nbit0 a0)).
rewrite H2.

*****
H2 : eq (negb (N.odd a')) (negb (N.odd a0))
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (negb (negb (N.odd a0))) (negb (negb (N.odd a0)))
+++++
reflexivity.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).

*****
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb (N.div2 a) (N.div2 a0)) false, eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.

*****
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
elim (Nneq_elim a' a0 H1).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).

*****
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
forall _ : eq (N.odd a') (negb (N.odd a0)), eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.

*****
H3 : eq (N.odd a') (negb (N.odd a0))
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite (Nneg_bit0_1 a a' H).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
rewrite (Nneg_bit0_1 a a' H).

*****
H3 : eq (N.odd a') (negb (N.odd a0))
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if negb (N.odd a') then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite H3.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
rewrite (Nneg_bit0_1 a a' H).
rewrite H3.

*****
H3 : eq (N.odd a') (negb (N.odd a0))
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if negb (negb (N.odd a0)) then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite (negb_elim (Nbit0 a0)).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
rewrite (Nneg_bit0_1 a a' H).
rewrite H3.
rewrite (negb_elim (Nbit0 a0)).

*****
H3 : eq (N.odd a') (negb (N.odd a0))
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a0 then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
rewrite MapGet_M2_bit_0_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
rewrite (Nneg_bit0_1 a a' H).
rewrite H3.
rewrite (negb_elim (Nbit0 a0)).
rewrite MapGet_M2_bit_0_2.

*****
H3 : eq (N.odd a') (negb (N.odd a0))
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
rewrite (Nneg_bit0_1 a a' H).
rewrite H3.
rewrite (negb_elim (Nbit0 a0)).
rewrite MapGet_M2_bit_0_2.
apply M1_semantics_2.

*****
H3 : eq (N.odd a') (negb (N.odd a0))
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).

*****
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb (N.div2 a') (N.div2 a0)) false, eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
intro.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (if N.odd a then M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y) else M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
case (Nbit0 a).
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M2 (M1 (N.div2 a') y') (M1 (N.div2 a) y)) a0) None
+++++
apply MapGet_M2_both_None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M2 (M1 (N.div2 a) y) (M1 (N.div2 a') y')) a0) None
+++++
apply MapGet_M2_both_None.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a) y) (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (MapGet (M1 (N.div2 a') y') (N.div2 a0)) None
+++++
apply M1_semantics_2.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.
intros.
simpl in |- *.
elim (Nneq_elim a a0 H0).
intro.
elim (Nneq_elim a' a0 H1).
intro.
case (Nbit0 a).
apply MapGet_M2_both_None.
apply M1_semantics_2.

*****
H3 : eq (N.eqb (N.div2 a') (N.div2 a0)) false
H2 : eq (N.eqb (N.div2 a) (N.div2 a0)) false
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos xH)
y,y' : A
a,a',a0 : ad
p : positive
A : Type
*****
eq (N.eqb (N.div2 a') (N.div2 a0)) false
+++++
assumption.
-----
Lemma MapPut1_semantics_3 : forall (p:positive) (a a' a0:ad) (y y':A), Nxor a a' = Npos p -> Neqb a a0 = false -> Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma MapPut1_semantics :\n   forall (p:positive) (a a':ad) (y y':A),\n     Nxor a a' = Npos p ->\n     eqm (MapGet (MapPut1 a y a' y' p))\n       (fun a0:ad =>\n          if Neqb a a0\n          then Some y\n          else if Neqb a' a0 then Some y' else None).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eqm (MapGet (MapPut1 a y a' y' p)) (fun a0 : ad => if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
Proof.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eqm (MapGet (MapPut1 a y a' y' p)) (fun a0 : ad => if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
unfold eqm in |- *.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)) (a0 : ad), eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
intros.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
intro H0.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (Some y)
+++++
rewrite <- (Neqb_complete _ _ H0).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a) (Some y)
+++++
exact (MapPut1_semantics_1 p a a' y y' H).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
intro H0.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else None)
+++++
elim (sumbool_of_bool (Neqb a' a0)).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb a' a0) true, eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else None)
+++++
intro H1.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).
intro H1.

*****
H1 : eq (N.eqb a' a0) true
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else None)
+++++
rewrite <- (Neqb_complete _ _ H1).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).
intro H1.
rewrite <- (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a' a0) true
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a') (if N.eqb a' a' then Some y' else None)
+++++
rewrite (Neqb_correct a').
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).
intro H1.
rewrite <- (Neqb_complete _ _ H1).
rewrite (Neqb_correct a').

*****
H1 : eq (N.eqb a' a0) true
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a') (Some y')
+++++
exact (MapPut1_semantics_2 p a a' y y' H).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb a' a0) false, eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else None)
+++++
intro H1.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).
intro H1.

*****
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else None)
+++++
rewrite H1.
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb a' a0)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a' a0) false
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) None
+++++
exact (MapPut1_semantics_3 p a a' a0 y y' H H0 H1).
-----
Lemma MapPut1_semantics : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a a0 then Some y else if Neqb a' a0 then Some y' else None).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma MapPut1_semantics' :\n   forall (p:positive) (a a':ad) (y y':A),\n     Nxor a a' = Npos p ->\n     eqm (MapGet (MapPut1 a y a' y' p))\n       (fun a0:ad =>\n          if Neqb a' a0\n          then Some y'\n          else if Neqb a a0 then Some y else None).
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eqm (MapGet (MapPut1 a y a' y' p)) (fun a0 : ad => if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
Proof.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)), eqm (MapGet (MapPut1 a y a' y' p)) (fun a0 : ad => if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
unfold eqm in |- *.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (p : positive) (a a' : ad) (y y' : A) (_ : eq (N.lxor a a') (Npos p)) (a0 : ad), eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intros.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite (MapPut1_semantics p a a' y y' H a0).
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intro H0.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (Some y) (if N.eqb a' a0 then Some y' else Some y)
+++++
rewrite <- (Neqb_complete a a0 H0).
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete a a0 H0).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (Some y) (if N.eqb a' a then Some y' else Some y)
+++++
rewrite (Neqb_comm a' a).
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete a a0 H0).
rewrite (Neqb_comm a' a).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (Some y) (if N.eqb a a' then Some y' else Some y)
+++++
rewrite (Nxor_eq_false a a' p H).
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete a a0 H0).
rewrite (Neqb_comm a' a).
rewrite (Nxor_eq_false a a' p H).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intro H0.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite H0.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : eq (N.lxor a a') (Npos p)
y,y' : A
a,a' : ad
p : positive
A : Type
*****
eq (if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else None)
+++++
reflexivity.
-----
Lemma MapPut1_semantics' : forall (p:positive) (a a':ad) (y y':A), Nxor a a' = Npos p -> eqm (MapGet (MapPut1 a y a' y' p)) (fun a0:ad => if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
unfold eqm in |- *.
intros.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Fixpoint MapPut (m:Map) : ad -> A -> Map :=\n    match m with\n    | M0 => M1\n    | M1 a y =>\n        fun (a':ad) (y':A) =>\n          match Nxor a a' with\n          | N0 => M1 a' y'\n          | Npos p => MapPut1 a y a' y' p\n          end\n    | M2 m1 m2 =>\n        fun (a:ad) (y:A) =>\n          match a with\n          | N0 => M2 (MapPut m1 N0 y) m2\n          | Npos xH => M2 m1 (MapPut m2 N0 y)\n          | Npos (xO p) => M2 (MapPut m1 (Npos p) y) m2\n          | Npos (xI p) => M2 m1 (MapPut m2 (Npos p) y)\n          end\n    end.
-----
Lemma MapPut_semantics_1 :\n   forall (a:ad) (y:A) (a0:ad),\n     MapGet (MapPut M0 a y) a0 = MapGet (M1 a y) a0.
-----
Lemma MapPut_semantics_1 : forall (a:ad) (y:A) (a0:ad), MapGet (MapPut M0 a y) a0 = MapGet (M1 a y) a0.

*****
A : Type
*****
forall (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut M0 a y) a0) (MapGet (M1 a y) a0)
+++++
Proof.
-----
Lemma MapPut_semantics_1 : forall (a:ad) (y:A) (a0:ad), MapGet (MapPut M0 a y) a0 = MapGet (M1 a y) a0.
Proof.

*****
A : Type
*****
forall (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut M0 a y) a0) (MapGet (M1 a y) a0)
+++++
trivial.
-----
Lemma MapPut_semantics_1 : forall (a:ad) (y:A) (a0:ad), MapGet (MapPut M0 a y) a0 = MapGet (M1 a y) a0.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapPut_semantics_2_1 :\n   forall (a:ad) (y y':A) (a0:ad),\n     MapGet (MapPut (M1 a y) a y') a0 =\n     (if Neqb a a0 then Some y' else None).
-----
Lemma MapPut_semantics_2_1 : forall (a:ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a y') a0 = (if Neqb a a0 then Some y' else None).

*****
A : Type
*****
forall (a : ad) (y y' : A) (a0 : ad), eq (MapGet (MapPut (M1 a y) a y') a0) (if N.eqb a a0 then Some y' else None)
+++++
Proof.
-----
Lemma MapPut_semantics_2_1 : forall (a:ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a y') a0 = (if Neqb a a0 then Some y' else None).
Proof.

*****
A : Type
*****
forall (a : ad) (y y' : A) (a0 : ad), eq (MapGet (MapPut (M1 a y) a y') a0) (if N.eqb a a0 then Some y' else None)
+++++
simpl in |- *.
-----
Lemma MapPut_semantics_2_1 : forall (a:ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a y') a0 = (if Neqb a a0 then Some y' else None).
Proof.
simpl in |- *.

*****
A : Type
*****
forall (a : ad) (y y' : A) (a0 : ad), eq (MapGet match N.lxor a a with | N0 => M1 a y' | Npos p => MapPut1 a y a y' p end a0) (if N.eqb a a0 then Some y' else None)
+++++
intros.
-----
Lemma MapPut_semantics_2_1 : forall (a:ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a y') a0 = (if Neqb a a0 then Some y' else None).
Proof.
simpl in |- *.
intros.

*****
a0 : ad
y,y' : A
a : ad
A : Type
*****
eq (MapGet match N.lxor a a with | N0 => M1 a y' | Npos p => MapPut1 a y a y' p end a0) (if N.eqb a a0 then Some y' else None)
+++++
rewrite (Nxor_nilpotent a).
-----
Lemma MapPut_semantics_2_1 : forall (a:ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a y') a0 = (if Neqb a a0 then Some y' else None).
Proof.
simpl in |- *.
intros.
rewrite (Nxor_nilpotent a).

*****
a0 : ad
y,y' : A
a : ad
A : Type
*****
eq (MapGet (M1 a y') a0) (if N.eqb a a0 then Some y' else None)
+++++
trivial.
-----
Lemma MapPut_semantics_2_1 : forall (a:ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a y') a0 = (if Neqb a a0 then Some y' else None).
Proof.
simpl in |- *.
intros.
rewrite (Nxor_nilpotent a).
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapPut_semantics_2_2 :\n   forall (a a':ad) (y y':A) (a0 a'':ad),\n     Nxor a a' = a'' ->\n     MapGet (MapPut (M1 a y) a' y') a0 =\n     (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).

*****
A : Type
*****
forall (a a' : ad) (y y' : A) (a0 a'' : ad) (_ : eq (N.lxor a a') a''), eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
Proof.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.

*****
A : Type
*****
forall (a a' : ad) (y y' : A) (a0 a'' : ad) (_ : eq (N.lxor a a') a''), eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
simple induction a''.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.

*****
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
forall _ : eq (N.lxor a a') N0, eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intro.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intro.

*****
H : eq (N.lxor a a') N0
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite (Nxor_eq _ _ H).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intro.
rewrite (Nxor_eq _ _ H).

*****
H : eq (N.lxor a a') N0
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (MapGet (MapPut (M1 a' y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a' a0 then Some y else None)
+++++
rewrite MapPut_semantics_2_1.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intro.
rewrite (Nxor_eq _ _ H).
rewrite MapPut_semantics_2_1.

*****
H : eq (N.lxor a a') N0
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a' a0 then Some y else None)
+++++
case (Neqb a' a0).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intro.
rewrite (Nxor_eq _ _ H).
rewrite MapPut_semantics_2_1.
case (Neqb a' a0).

*****
H : eq (N.lxor a a') N0
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (Some y') (Some y')
+++++
trivial.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intro.
rewrite (Nxor_eq _ _ H).
rewrite MapPut_semantics_2_1.
case (Neqb a' a0).

*****
H : eq (N.lxor a a') N0
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.

*****
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
forall (p : positive) (_ : eq (N.lxor a a') (Npos p)), eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intros.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.

*****
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
simpl in |- *.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.

*****
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite H.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.

*****
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite (MapPut1_semantics p a a' y y' H a0).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).

*****
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intro H0.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite H0.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) true
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (Some y) (if N.eqb a' a0 then Some y' else Some y)
+++++
rewrite <- (Neqb_complete _ _ H0).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a a0) true
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (Some y) (if N.eqb a' a then Some y' else Some y)
+++++
rewrite (Neqb_comm a' a).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
rewrite (Neqb_comm a' a).

*****
H0 : eq (N.eqb a a0) true
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (Some y) (if N.eqb a a' then Some y' else Some y)
+++++
rewrite (Nxor_eq_false _ _ _ H).
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
rewrite (Neqb_comm a' a).
rewrite (Nxor_eq_false _ _ _ H).

*****
H0 : eq (N.eqb a a0) true
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intro H0.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (if N.eqb a a0 then Some y else if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
rewrite H0.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.
intros.
simpl in |- *.
rewrite H.
rewrite (MapPut1_semantics p a a' y y' H a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) false
H : eq (N.lxor a a') (Npos p)
p : positive
a0,a'' : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (if N.eqb a' a0 then Some y' else None) (if N.eqb a' a0 then Some y' else None)
+++++
reflexivity.
-----
Lemma MapPut_semantics_2_2 : forall (a a':ad) (y y':A) (a0 a'':ad), Nxor a a' = a'' -> MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
simple induction a''.

*****

*****

+++++
Qed.
-----
Lemma MapPut_semantics_2 :\n   forall (a a':ad) (y y':A) (a0:ad),\n     MapGet (MapPut (M1 a y) a' y') a0 =\n     (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
-----
Lemma MapPut_semantics_2 : forall (a a':ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).

*****
A : Type
*****
forall (a a' : ad) (y y' : A) (a0 : ad), eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
Proof.
-----
Lemma MapPut_semantics_2 : forall (a a':ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.

*****
A : Type
*****
forall (a a' : ad) (y y' : A) (a0 : ad), eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
intros.
-----
Lemma MapPut_semantics_2 : forall (a a':ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
intros.

*****
a0 : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (MapGet (MapPut (M1 a y) a' y') a0) (if N.eqb a' a0 then Some y' else if N.eqb a a0 then Some y else None)
+++++
apply MapPut_semantics_2_2 with (a'' := Nxor a a').
-----
Lemma MapPut_semantics_2 : forall (a a':ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
intros.
apply MapPut_semantics_2_2 with (a'' := Nxor a a').

*****
a0 : ad
y,y' : A
a,a' : ad
A : Type
*****
eq (N.lxor a a') (N.lxor a a')
+++++
trivial.
-----
Lemma MapPut_semantics_2 : forall (a a':ad) (y y':A) (a0:ad), MapGet (MapPut (M1 a y) a' y') a0 = (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).
Proof.
intros.
apply MapPut_semantics_2_2 with (a'' := Nxor a a').
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapPut_semantics_3_1 :\n   forall (m m':Map) (a:ad) (y:A),\n     MapPut (M2 m m') a y =\n     (if Nbit0 a\n      then M2 m (MapPut m' (Ndiv2 a) y)\n      else M2 (MapPut m (Ndiv2 a) y) m').
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y : A), eq (MapPut (M2 m m') a y) (if N.odd a then M2 m (MapPut m' (N.div2 a) y) else M2 (MapPut m (N.div2 a) y) m')
+++++
Proof.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y : A), eq (MapPut (M2 m m') a y) (if N.odd a then M2 m (MapPut m' (N.div2 a) y) else M2 (MapPut m (N.div2 a) y) m')
+++++
simple induction a.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall y : A, eq (MapPut (M2 m m') N0 y) (if N.odd N0 then M2 m (MapPut m' (N.div2 N0) y) else M2 (MapPut m (N.div2 N0) y) m')
+++++
trivial.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (y : A), eq (MapPut (M2 m m') (Npos p) y) (if N.odd (Npos p) then M2 m (MapPut m' (N.div2 (Npos p)) y) else M2 (MapPut m (N.div2 (Npos p)) y) m')
+++++
simple induction p.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (_ : forall y : A, eq (MapPut (M2 m m') (Npos p) y) (if N.odd (Npos p) then M2 m (MapPut m' (N.div2 (Npos p)) y) else M2 (MapPut m (N.div2 (Npos p)) y) m')) (y : A), eq (MapPut (M2 m m') (Npos (xI p)) y) (if N.odd (Npos (xI p)) then M2 m (MapPut m' (N.div2 (Npos (xI p))) y) else M2 (MapPut m (N.div2 (Npos (xI p))) y) m')
+++++
trivial.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (_ : forall y : A, eq (MapPut (M2 m m') (Npos p) y) (if N.odd (Npos p) then M2 m (MapPut m' (N.div2 (Npos p)) y) else M2 (MapPut m (N.div2 (Npos p)) y) m')) (y : A), eq (MapPut (M2 m m') (Npos (xO p)) y) (if N.odd (Npos (xO p)) then M2 m (MapPut m' (N.div2 (Npos (xO p))) y) else M2 (MapPut m (N.div2 (Npos (xO p))) y) m')
+++++
trivial.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall y : A, eq (MapPut (M2 m m') (Npos xH) y) (if N.odd (Npos xH) then M2 m (MapPut m' (N.div2 (Npos xH)) y) else M2 (MapPut m (N.div2 (Npos xH)) y) m')
+++++
trivial.
-----
Lemma MapPut_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut (M2 m m') a y = (if Nbit0 a then M2 m (MapPut m' (Ndiv2 a) y) else M2 (MapPut m (Ndiv2 a) y) m').
Proof.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma MapPut_semantics :\n   forall (m:Map) (a:ad) (y:A),\n     eqm (MapGet (MapPut m a y))\n       (fun a':ad => if Neqb a a' then Some y else MapGet m a').
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A), eqm (MapGet (MapPut m a y)) (fun a' : ad => if N.eqb a a' then Some y else MapGet m a')
+++++
Proof.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A), eqm (MapGet (MapPut m a y)) (fun a' : ad => if N.eqb a a' then Some y else MapGet m a')
+++++
unfold eqm in |- *.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut m a y) a0) (if N.eqb a a0 then Some y else MapGet m a0)
+++++
simple induction m.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut M0 a y) a0) (if N.eqb a a0 then Some y else MapGet M0 a0)
+++++
exact MapPut_semantics_1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (a2 : ad), eq (MapGet (MapPut (M1 a a0) a1 y) a2) (if N.eqb a1 a2 then Some y else MapGet (M1 a a0) a2)
+++++
intros.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a2 : ad
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut (M1 a a0) a1 y) a2) (if N.eqb a1 a2 then Some y else MapGet (M1 a a0) a2)
+++++
unfold MapGet at 2 in |- *.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
unfold MapGet at 2 in |- *.

*****
a2 : ad
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut (M1 a a0) a1 y) a2) (if N.eqb a1 a2 then Some y else if N.eqb a a2 then Some a0 else None)
+++++
apply MapPut_semantics_2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut m a y) a0) (if N.eqb a a0 then Some y else MapGet m a0)) (m0 : Map) (_ : forall (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut m0 a y) a0) (if N.eqb a a0 then Some y else MapGet m0 a0)) (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut (M2 m m0) a y) a0) (if N.eqb a a0 then Some y else MapGet (M2 m m0) a0)
+++++
intros.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut (M2 m0 m1) a y) a0) (if N.eqb a a0 then Some y else MapGet (M2 m0 m1) a0)
+++++
rewrite MapPut_semantics_3_1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.

*****
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else MapGet (M2 m0 m1) a0)
+++++
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).

*****
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).

*****
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.

*****
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 (MapPut m1 (N.div2 a) y)) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.

*****
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
elim (sumbool_of_bool (Nbit0 a0)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) true, eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (Some y)
+++++
rewrite (Ndiv2_eq _ _ H3).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite (Ndiv2_eq _ _ H3).

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
rewrite <- H2 in H1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) (N.odd a0)
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
rewrite (Ndiv2_bit_neq _ _ H3 H1).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H0 (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.
rewrite (Ndiv2_bit_neq _ _ H3 H1).

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) (N.odd a0)
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) false, eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
rewrite (Neqb_comm a a0).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (Neqb_comm a a0).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (if N.eqb a0 a then Some y else MapGet m0 (N.div2 a0))
+++++
rewrite (Nbit0_neq a0 a H2 H1).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (Neqb_comm a a0).
rewrite (Nbit0_neq a0 a H2 H1).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).

*****
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.

*****
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapPut m0 (N.div2 a) y) m1) a0) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.

*****
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
elim (sumbool_of_bool (Nbit0 a0)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) true, eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m1 (N.div2 a0))
+++++
rewrite (Nbit0_neq a a0 H1 H2).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (Nbit0_neq a a0 H1 H2).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) false, eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H2.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (Some y)
+++++
rewrite (Ndiv2_eq a a0 H3).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite (Ndiv2_eq a a0 H3).

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then Some y else MapGet m0 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
rewrite <- H2 in H1.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) (N.odd a0)
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then Some y else MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
rewrite (Ndiv2_bit_neq a a0 H3 H1).
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a0).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite H2.
rewrite (H (Ndiv2 a) y (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.
rewrite (Ndiv2_bit_neq a a0 H3 H1).

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) (N.odd a0)
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m1 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m1 a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad),\neq (MapGet (MapPut m0 a y) a0)\n (if N.eqb a a0 then Some y else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapPut_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut m a y)) (fun a':ad => if Neqb a a' then Some y else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****

*****

+++++
Qed.
-----
Fixpoint MapPut_behind (m:Map) : ad -> A -> Map :=\n    match m with\n    | M0 => M1\n    | M1 a y =>\n        fun (a':ad) (y':A) =>\n          match Nxor a a' with\n          | N0 => m\n          | Npos p => MapPut1 a y a' y' p\n          end\n    | M2 m1 m2 =>\n        fun (a:ad) (y:A) =>\n          match a with\n          | N0 => M2 (MapPut_behind m1 N0 y) m2\n          | Npos xH => M2 m1 (MapPut_behind m2 N0 y)\n          | Npos (xO p) => M2 (MapPut_behind m1 (Npos p) y) m2\n          | Npos (xI p) => M2 m1 (MapPut_behind m2 (Npos p) y)\n          end\n    end.
-----
Lemma MapPut_behind_semantics_3_1 :\n   forall (m m':Map) (a:ad) (y:A),\n     MapPut_behind (M2 m m') a y =\n     (if Nbit0 a\n      then M2 m (MapPut_behind m' (Ndiv2 a) y)\n      else M2 (MapPut_behind m (Ndiv2 a) y) m').
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y : A), eq (MapPut_behind (M2 m m') a y) (if N.odd a then M2 m (MapPut_behind m' (N.div2 a) y) else M2 (MapPut_behind m (N.div2 a) y) m')
+++++
Proof.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y : A), eq (MapPut_behind (M2 m m') a y) (if N.odd a then M2 m (MapPut_behind m' (N.div2 a) y) else M2 (MapPut_behind m (N.div2 a) y) m')
+++++
simple induction a.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall y : A, eq (MapPut_behind (M2 m m') N0 y) (if N.odd N0 then M2 m (MapPut_behind m' (N.div2 N0) y) else M2 (MapPut_behind m (N.div2 N0) y) m')
+++++
trivial.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.
simple induction a.

*****
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (y : A), eq (MapPut_behind (M2 m m') (Npos p) y) (if N.odd (Npos p) then M2 m (MapPut_behind m' (N.div2 (Npos p)) y) else M2 (MapPut_behind m (N.div2 (Npos p)) y) m')
+++++
simple induction p.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (_ : forall y : A, eq (MapPut_behind (M2 m m') (Npos p) y) (if N.odd (Npos p) then M2 m (MapPut_behind m' (N.div2 (Npos p)) y) else M2 (MapPut_behind m (N.div2 (Npos p)) y) m')) (y : A), eq (MapPut_behind (M2 m m') (Npos (xI p)) y) (if N.odd (Npos (xI p)) then M2 m (MapPut_behind m' (N.div2 (Npos (xI p))) y) else M2 (MapPut_behind m (N.div2 (Npos (xI p))) y) m')
+++++
trivial.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall (p : positive) (_ : forall y : A, eq (MapPut_behind (M2 m m') (Npos p) y) (if N.odd (Npos p) then M2 m (MapPut_behind m' (N.div2 (Npos p)) y) else M2 (MapPut_behind m (N.div2 (Npos p)) y) m')) (y : A), eq (MapPut_behind (M2 m m') (Npos (xO p)) y) (if N.odd (Npos (xO p)) then M2 m (MapPut_behind m' (N.div2 (Npos (xO p))) y) else M2 (MapPut_behind m (N.div2 (Npos (xO p))) y) m')
+++++
trivial.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.
simple induction a.
simple induction p.

*****
p : positive
a : ad
m,m' : Map
A : Type
*****
forall y : A, eq (MapPut_behind (M2 m m') (Npos xH) y) (if N.odd (Npos xH) then M2 m (MapPut_behind m' (N.div2 (Npos xH)) y) else M2 (MapPut_behind m (N.div2 (Npos xH)) y) m')
+++++
trivial.
-----
Lemma MapPut_behind_semantics_3_1 : forall (m m':Map) (a:ad) (y:A), MapPut_behind (M2 m m') a y = (if Nbit0 a then M2 m (MapPut_behind m' (Ndiv2 a) y) else M2 (MapPut_behind m (Ndiv2 a) y) m').
Proof.
simple induction a.

*****

*****

+++++
Qed.
-----
Lemma MapPut_behind_as_before_1 :\n   forall a a' a0:ad,\n     Neqb a' a0 = false ->\n     forall y y':A,\n       MapGet (MapPut (M1 a y) a' y') a0 =\n       MapGet (MapPut_behind (M1 a y) a' y') a0.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.

*****
A : Type
*****
forall (a a' a0 : ad) (_ : eq (N.eqb a' a0) false) (y y' : A), eq (MapGet (MapPut (M1 a y) a' y') a0) (MapGet (MapPut_behind (M1 a y) a' y') a0)
+++++
Proof.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.

*****
A : Type
*****
forall (a a' a0 : ad) (_ : eq (N.eqb a' a0) false) (y y' : A), eq (MapGet (MapPut (M1 a y) a' y') a0) (MapGet (MapPut_behind (M1 a y) a' y') a0)
+++++
intros a a' a0.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.

*****
a,a',a0 : ad
A : Type
*****
forall (_ : eq (N.eqb a' a0) false) (y y' : A), eq (MapGet (MapPut (M1 a y) a' y') a0) (MapGet (MapPut_behind (M1 a y) a' y') a0)
+++++
simpl in |- *.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.

*****
a,a',a0 : ad
A : Type
*****
forall (_ : eq (N.eqb a' a0) false) (y y' : A), eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
intros H y y'.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.

*****
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
elim (Ndiscr (Nxor a a')).
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).

*****
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
forall _ : sig (fun p : positive => eq (N.lxor a a') (Npos p)), eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
intro H0.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.

*****
H0 : sig (fun p : positive => eq (N.lxor a a') (Npos p))
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
elim H0.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.
elim H0.

*****
H0 : sig (fun p : positive => eq (N.lxor a a') (Npos p))
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
forall (x : positive) (_ : eq (N.lxor a a') (Npos x)), eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p0 => MapPut1 a y a' y' p0 end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p0 => MapPut1 a y a' y' p0 end a0)
+++++
intros p H1.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.
elim H0.
intros p H1.

*****
H1 : eq (N.lxor a a') (Npos p)
p : positive
H0 : sig (fun p : positive => eq (N.lxor a a') (Npos p))
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
rewrite H1.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.
elim H0.
intros p H1.
rewrite H1.

*****
H1 : eq (N.lxor a a') (Npos p)
p : positive
H0 : sig (fun p : positive => eq (N.lxor a a') (Npos p))
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet (MapPut1 a y a' y' p) a0) (MapGet (MapPut1 a y a' y' p) a0)
+++++
reflexivity.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).

*****
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
forall _ : eq (N.lxor a a') N0, eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
intro H0.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.

*****
H0 : eq (N.lxor a a') N0
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet match N.lxor a a' with | N0 => M1 a' y' | Npos p => MapPut1 a y a' y' p end a0) (MapGet match N.lxor a a' with | N0 => M1 a y | Npos p => MapPut1 a y a' y' p end a0)
+++++
rewrite H0.
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.
rewrite H0.

*****
H0 : eq (N.lxor a a') N0
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet (M1 a' y') a0) (MapGet (M1 a y) a0)
+++++
rewrite (Nxor_eq _ _ H0).
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.
rewrite H0.
rewrite (Nxor_eq _ _ H0).

*****
H0 : eq (N.lxor a a') N0
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet (M1 a' y') a0) (MapGet (M1 a' y) a0)
+++++
rewrite (M1_semantics_2 a' a0 y H).
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).
intro H0.
rewrite H0.
rewrite (Nxor_eq _ _ H0).
rewrite (M1_semantics_2 a' a0 y H).

*****
H0 : eq (N.lxor a a') N0
y,y' : A
H : eq (N.eqb a' a0) false
a,a',a0 : ad
A : Type
*****
eq (MapGet (M1 a' y') a0) None
+++++
exact (M1_semantics_2 a' a0 y' H).
-----
Lemma MapPut_behind_as_before_1 : forall a a' a0:ad, Neqb a' a0 = false -> forall y y':A, MapGet (MapPut (M1 a y) a' y') a0 = MapGet (MapPut_behind (M1 a y) a' y') a0.
Proof.
intros a a' a0.
simpl in |- *.
intros H y y'.
elim (Ndiscr (Nxor a a')).

*****

*****

+++++
Qed.
-----
Lemma MapPut_behind_as_before :\n   forall (m:Map) (a:ad) (y:A) (a0:ad),\n     Neqb a a0 = false ->\n     MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false), eq (MapGet (MapPut m a y) a0) (MapGet (MapPut_behind m a y) a0)
+++++
Proof.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false), eq (MapGet (MapPut m a y) a0) (MapGet (MapPut_behind m a y) a0)
+++++
simple induction m.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false), eq (MapGet (MapPut M0 a y) a0) (MapGet (MapPut_behind M0 a y) a0)
+++++
trivial.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (a2 : ad) (_ : eq (N.eqb a1 a2) false), eq (MapGet (MapPut (M1 a a0) a1 y) a2) (MapGet (MapPut_behind (M1 a a0) a1 y) a2)
+++++
intros a y a' y' a0 H.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros a y a' y' a0 H.

*****
H : eq (N.eqb a' a0) false
a0 : ad
y' : A
a' : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut (M1 a y) a' y') a0) (MapGet (MapPut_behind (M1 a y) a' y') a0)
+++++
exact (MapPut_behind_as_before_1 a a' a0 H y y').
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false), eq (MapGet (MapPut m a y) a0) (MapGet (MapPut_behind m a y) a0)) (m0 : Map) (_ : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false), eq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)) (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false), eq (MapGet (MapPut (M2 m m0) a y) a0) (MapGet (MapPut_behind (M2 m m0) a y) a0)
+++++
intros.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.

*****
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut (M2 m0 m1) a y) a0) (MapGet (MapPut_behind (M2 m0 m1) a y) a0)
+++++
rewrite MapPut_semantics_3_1.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.

*****
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (MapPut_behind (M2 m0 m1) a y) a0)
+++++
rewrite MapPut_behind_semantics_3_1.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.

*****
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
intro H2.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
rewrite H2.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.

*****
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 (MapPut m1 (N.div2 a) y)) a0) (MapGet (M2 m0 (MapPut_behind m1 (N.div2 a) y)) a0)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.

*****
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (MapGet (M2 m0 (MapPut_behind m1 (N.div2 a) y)) a0)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.

*****
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.odd a0 then MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
elim (sumbool_of_bool (Nbit0 a0)).
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) true, eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.odd a0 then MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.

*****
H3 : eq (N.odd a0) true
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.odd a0 then MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.odd a0) true
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0)) (MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a0))
+++++
apply H0.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.
apply H0.

*****
H3 : eq (N.odd a0) true
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
rewrite <- H3 in H2.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.
apply H0.
rewrite <- H3 in H2.

*****
H3 : eq (N.odd a0) true
H2 : eq (N.odd a) (N.odd a0)
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
exact (Ndiv2_bit_neq a a0 H1 H2).
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) false, eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.odd a0 then MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.

*****
H3 : eq (N.odd a0) false
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet (MapPut m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0)) (if N.odd a0 then MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a0) else MapGet m0 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.odd a0) false
H2 : eq (N.odd a) true
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
intro H2.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut m1 (N.div2 a) y) else M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
rewrite H2.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.

*****
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapPut m0 (N.div2 a) y) m1) a0) (MapGet (M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.

*****
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (MapGet (M2 (MapPut_behind m0 (N.div2 a) y) m1) a0)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.

*****
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a0))
+++++
elim (sumbool_of_bool (Nbit0 a0)).
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) true, eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.

*****
H3 : eq (N.odd a0) true
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.odd a0) true
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).

*****
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) false, eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a0))
+++++
intro H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.

*****
H3 : eq (N.odd a0) false
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (if N.odd a0 then MapGet m1 (N.div2 a0) else MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.odd a0) false
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut m0 (N.div2 a) y) (N.div2 a0)) (MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a0))
+++++
apply H.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.
apply H.

*****
H3 : eq (N.odd a0) false
H2 : eq (N.odd a) false
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
rewrite <- H3 in H2.
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.
intros.
rewrite MapPut_semantics_3_1.
rewrite MapPut_behind_semantics_3_1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2.
rewrite MapGet_M2_bit_0_if.
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a0)).
intro H3.
rewrite H3.
apply H.
rewrite <- H3 in H2.

*****
H3 : eq (N.odd a0) false
H2 : eq (N.odd a) (N.odd a0)
H1 : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m1 a y) a0) (MapGet (MapPut_behind m1 a y) a0)
m1 : Map
H : forall (a : ad) (y : A) (a0 : ad) (_ : eq (N.eqb a a0) false),\neq (MapGet (MapPut m0 a y) a0) (MapGet (MapPut_behind m0 a y) a0)
m,m0 : Map
A : Type
*****
eq (N.eqb (N.div2 a) (N.div2 a0)) false
+++++
exact (Ndiv2_bit_neq a a0 H1 H2).
-----
Lemma MapPut_behind_as_before : forall (m:Map) (a:ad) (y:A) (a0:ad), Neqb a a0 = false -> MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapPut_behind_new :\n   forall (m:Map) (a:ad) (y:A),\n     MapGet (MapPut_behind m a y) a =\n     match MapGet m a with\n     | Some y' => Some y'\n     | _ => Some y\n     end.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A), eq (MapGet (MapPut_behind m a y) a) match MapGet m a with | Some y' => Some y' | None => Some y end
+++++
Proof.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A), eq (MapGet (MapPut_behind m a y) a) match MapGet m a with | Some y' => Some y' | None => Some y end
+++++
simple induction m.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (y : A), eq (MapGet (MapPut_behind M0 a y) a) match MapGet M0 a with | Some y' => Some y' | None => Some y end
+++++
simpl in |- *.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map
A : Type
*****
forall (a : ad) (y : A), eq (if N.eqb a a then Some y else None) (Some y)
+++++
intros.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
y : A
a : ad
m : Map
A : Type
*****
eq (if N.eqb a a then Some y else None) (Some y)
+++++
rewrite (Neqb_correct a).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (Neqb_correct a).

*****
y : A
a : ad
m : Map
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A), eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
intros.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.

*****
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
elim (Ndiscr (Nxor a a1)).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).

*****
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : sig (fun p : positive => eq (N.lxor a a1) (Npos p)), eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
intro H.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.

*****
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
elim H.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
elim H.

*****
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall (x : positive) (_ : eq (N.lxor a a1) (Npos x)), eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
intros p H0.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
elim H.
intros p H0.

*****
H0 : eq (N.lxor a a1) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
simpl in |- *.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
elim H.
intros p H0.
simpl in |- *.

*****
H0 : eq (N.lxor a a1) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match N.lxor a a1 with | N0 => M1 a a0 | Npos p => MapPut1 a a0 a1 y p end a1) match (if N.eqb a a1 then Some a0 else None) with | Some y' => Some y' | None => Some y end
+++++
rewrite H0.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
elim H.
intros p H0.
simpl in |- *.
rewrite H0.

*****
H0 : eq (N.lxor a a1) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut1 a a0 a1 y p) a1) match (if N.eqb a a1 then Some a0 else None) with | Some y' => Some y' | None => Some y end
+++++
rewrite (Nxor_eq_false a a1 p).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
elim H.
intros p H0.
simpl in |- *.
rewrite H0.
rewrite (Nxor_eq_false a a1 p).

*****
H0 : eq (N.lxor a a1) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut1 a a0 a1 y p) a1) (Some y)
+++++
exact (MapPut1_semantics_2 p a a1 a0 y H0).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
elim H.
intros p H0.
simpl in |- *.
rewrite H0.
rewrite (Nxor_eq_false a a1 p).

*****
H0 : eq (N.lxor a a1) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a1) (Npos p))
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (N.lxor a a1) (Npos p)
+++++
assumption.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).

*****
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.lxor a a1) N0, eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
intro H.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.

*****
H : eq (N.lxor a a1) N0
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind (M1 a a0) a1 y) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => Some y end
+++++
simpl in |- *.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
simpl in |- *.

*****
H : eq (N.lxor a a1) N0
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match N.lxor a a1 with | N0 => M1 a a0 | Npos p => MapPut1 a a0 a1 y p end a1) match (if N.eqb a a1 then Some a0 else None) with | Some y' => Some y' | None => Some y end
+++++
rewrite H.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
simpl in |- *.
rewrite H.

*****
H : eq (N.lxor a a1) N0
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a1) match (if N.eqb a a1 then Some a0 else None) with | Some y' => Some y' | None => Some y end
+++++
rewrite <- (Nxor_eq _ _ H).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
simpl in |- *.
rewrite H.
rewrite <- (Nxor_eq _ _ H).

*****
H : eq (N.lxor a a1) N0
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a) match (if N.eqb a a then Some a0 else None) with | Some y' => Some y' | None => Some y end
+++++
rewrite (Neqb_correct a).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
elim (Ndiscr (Nxor a a1)).
intro H.
simpl in |- *.
rewrite H.
rewrite <- (Nxor_eq _ _ H).
rewrite (Neqb_correct a).

*****
H : eq (N.lxor a a1) N0
y : A
a1 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a) (Some a0)
+++++
exact (M1_semantics_1 a a0).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (a : ad) (y : A), eq (MapGet (MapPut_behind m a y) a) match MapGet m a with | Some y' => Some y' | None => Some y end) (m0 : Map) (_ : forall (a : ad) (y : A), eq (MapGet (MapPut_behind m0 a y) a) match MapGet m0 a with | Some y' => Some y' | None => Some y end) (a : ad) (y : A), eq (MapGet (MapPut_behind (M2 m m0) a y) a) match MapGet (M2 m m0) a with | Some y' => Some y' | None => Some y end
+++++
intros.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut_behind (M2 m0 m1) a y) a) match MapGet (M2 m0 m1) a with | Some y' => Some y' | None => Some y end
+++++
rewrite MapPut_behind_semantics_3_1.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match MapGet (M2 m0 m1) a with | Some y' => Some y' | None => Some y end
+++++
rewrite (MapGet_M2_bit_0_if m0 m1 a).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match (if N.odd a then MapGet m1 (N.div2 a) else MapGet m0 (N.div2 a)) with | Some y' => Some y' | None => Some y end
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match (if N.odd a then MapGet m1 (N.div2 a) else MapGet m0 (N.div2 a)) with | Some y' => Some y' | None => Some y end
+++++
intro H1.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.

*****
H1 : eq (N.odd a) true
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match (if N.odd a then MapGet m1 (N.div2 a) else MapGet m0 (N.div2 a)) with | Some y' => Some y' | None => Some y end
+++++
rewrite H1.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a) true
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 (MapPut_behind m1 (N.div2 a) y)) a) match MapGet m1 (N.div2 a) with | Some y' => Some y' | None => Some y end
+++++
rewrite (MapGet_M2_bit_0_1 a H1).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (MapGet_M2_bit_0_1 a H1).

*****
H1 : eq (N.odd a) true
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut_behind m1 (N.div2 a) y) (N.div2 a)) match MapGet m1 (N.div2 a) with | Some y' => Some y' | None => Some y end
+++++
exact (H0 (Ndiv2 a) y).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match (if N.odd a then MapGet m1 (N.div2 a) else MapGet m0 (N.div2 a)) with | Some y' => Some y' | None => Some y end
+++++
intro H1.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.

*****
H1 : eq (N.odd a) false
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then M2 m0 (MapPut_behind m1 (N.div2 a) y) else M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match (if N.odd a then MapGet m1 (N.div2 a) else MapGet m0 (N.div2 a)) with | Some y' => Some y' | None => Some y end
+++++
rewrite H1.
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a) false
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapPut_behind m0 (N.div2 a) y) m1) a) match MapGet m0 (N.div2 a) with | Some y' => Some y' | None => Some y end
+++++
rewrite (MapGet_M2_bit_0_0 a H1).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.
intros.
rewrite MapPut_behind_semantics_3_1.
rewrite (MapGet_M2_bit_0_if m0 m1 a).
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (MapGet_M2_bit_0_0 a H1).

*****
H1 : eq (N.odd a) false
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m1 a y) a)\n match MapGet m1 a with\n | Some y' => Some y'\n | None => Some y\n end
m1 : Map
H : forall (a : ad) (y : A),\neq (MapGet (MapPut_behind m0 a y) a)\n match MapGet m0 a with\n | Some y' => Some y'\n | None => Some y\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut_behind m0 (N.div2 a) y) (N.div2 a)) match MapGet m0 (N.div2 a) with | Some y' => Some y' | None => Some y end
+++++
exact (H (Ndiv2 a) y).
-----
Lemma MapPut_behind_new : forall (m:Map) (a:ad) (y:A), MapGet (MapPut_behind m a y) a = match MapGet m a with | Some y' => Some y' | _ => Some y end.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapPut_behind_semantics :\n   forall (m:Map) (a:ad) (y:A),\n     eqm (MapGet (MapPut_behind m a y))\n       (fun a':ad =>\n          match MapGet m a' with\n          | Some y' => Some y'\n          | _ => if Neqb a a' then Some y else None\n          end).
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A), eqm (MapGet (MapPut_behind m a y)) (fun a' : ad => match MapGet m a' with | Some y' => Some y' | None => if N.eqb a a' then Some y else None end)
+++++
Proof.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A), eqm (MapGet (MapPut_behind m a y)) (fun a' : ad => match MapGet m a' with | Some y' => Some y' | None => if N.eqb a a' then Some y else None end)
+++++
unfold eqm in |- *.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m : Map) (a : ad) (y : A) (a0 : ad), eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => if N.eqb a a0 then Some y else None end
+++++
intros.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.

*****
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => if N.eqb a a0 then Some y else None end
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => if N.eqb a a0 then Some y else None end
+++++
intro H.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) true
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => if N.eqb a a0 then Some y else None end
+++++
rewrite H.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) true
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => Some y end
+++++
rewrite (Neqb_complete _ _ H).
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite (Neqb_complete _ _ H).

*****
H : eq (N.eqb a a0) true
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m a0 y) a0) match MapGet m a0 with | Some y' => Some y' | None => Some y end
+++++
apply MapPut_behind_new.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => if N.eqb a a0 then Some y else None end
+++++
intro H.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => if N.eqb a a0 then Some y else None end
+++++
rewrite H.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => None end
+++++
rewrite <- (MapPut_behind_as_before m a y a0 H).
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite <- (MapPut_behind_as_before m a y a0 H).

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut m a y) a0) match MapGet m a0 with | Some y' => Some y' | None => None end
+++++
rewrite (MapPut_semantics m a y a0).
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite <- (MapPut_behind_as_before m a y a0 H).
rewrite (MapPut_semantics m a y a0).

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (if N.eqb a a0 then Some y else MapGet m a0) match MapGet m a0 with | Some y' => Some y' | None => None end
+++++
rewrite H.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite <- (MapPut_behind_as_before m a y a0 H).
rewrite (MapPut_semantics m a y a0).
rewrite H.

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq (MapGet m a0) match MapGet m a0 with | Some y' => Some y' | None => None end
+++++
case (MapGet m a0).
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite <- (MapPut_behind_as_before m a y a0 H).
rewrite (MapPut_semantics m a y a0).
rewrite H.
case (MapGet m a0).

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
forall a : A, eq (Some a) (Some a)
+++++
trivial.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H.
rewrite H.
rewrite <- (MapPut_behind_as_before m a y a0 H).
rewrite (MapPut_semantics m a y a0).
rewrite H.
case (MapGet m a0).

*****
H : eq (N.eqb a a0) false
a0 : ad
y : A
a : ad
m : Map
A : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapPut_behind_semantics : forall (m:Map) (a:ad) (y:A), eqm (MapGet (MapPut_behind m a y)) (fun a':ad => match MapGet m a' with | Some y' => Some y' | _ => if Neqb a a' then Some y else None end).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Definition makeM2 (m m':Map) :=\n    match m, m' with\n    | M0, M0 => M0\n    | M0, M1 a y => M1 (Ndouble_plus_one a) y\n    | M1 a y, M0 => M1 (Ndouble a) y\n    | _, _ => M2 m m'\n    end.
-----
Lemma makeM2_M2 :\n   forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m'))
+++++
Proof.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m'))
+++++
unfold eqm in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (makeM2 m m') a) (MapGet (M2 m m') a)
+++++
intros.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m m') a) (MapGet (M2 m m') a)
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet (makeM2 m m') a) (MapGet (M2 m m') a)
+++++
intro H.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m m') a) (MapGet (M2 m m') a)
+++++
rewrite (MapGet_M2_bit_0_1 a H m m').
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m m') a) (MapGet m' (N.div2 a))
+++++
case m'.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m M0) a) (MapGet M0 (N.div2 a))
+++++
case m.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 M0 M0) a) (MapGet M0 (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A), eq (MapGet (makeM2 (M1 a0 a1) M0) a) (MapGet M0 (N.div2 a))
+++++
intros a0 y.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M1 a0 y) M0) a) (MapGet M0 (N.div2 a))
+++++
simpl in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double a0) a then Some y else None) None
+++++
rewrite (Nodd_not_double a H a0).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
rewrite (Nodd_not_double a H a0).

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall m m0 : Map, eq (MapGet (makeM2 (M2 m m0) M0) a) (MapGet M0 (N.div2 a))
+++++
intros m1 m2.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M2 m1 m2) M0) a) (MapGet M0 (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2.
unfold makeM2 in |- *.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 (M2 m1 m2) M0) a) (MapGet M0 (N.div2 a))
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_1.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet M0 (N.div2 a)) (MapGet M0 (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_1.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) true
+++++
assumption.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A), eq (MapGet (makeM2 m (M1 a0 a1)) a) (MapGet (M1 a0 a1) (N.div2 a))
+++++
case m.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A), eq (MapGet (makeM2 M0 (M1 a0 a1)) a) (MapGet (M1 a0 a1) (N.div2 a))
+++++
intros a0 y.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 M0 (M1 a0 y)) a) (MapGet (M1 a0 y) (N.div2 a))
+++++
simpl in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.eqb a0 (N.div2 a)) true, eq (if N.eqb (N.succ_double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
intro H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
rewrite H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) (Some y)
+++++
rewrite (Neqb_complete _ _ H0).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double (N.div2 a)) a then Some y else None) (Some y)
+++++
rewrite (Ndiv2_double_plus_one a H).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (Ndiv2_double_plus_one a H).

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb a a then Some y else None) (Some y)
+++++
rewrite (Neqb_correct a).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (Ndiv2_double_plus_one a H).
rewrite (Neqb_correct a).

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).

*****
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.eqb a0 (N.div2 a)) false, eq (if N.eqb (N.succ_double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
intro H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) false
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
rewrite H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) false
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) None
+++++
rewrite (Neqb_comm a0 (Ndiv2 a)) in H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_comm a0 (Ndiv2 a)) in H0.

*****
H0 : eq (N.eqb (N.div2 a) a0) false
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) None
+++++
rewrite (Nnot_div2_not_double_plus_one a a0 H0).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_comm a0 (Ndiv2 a)) in H0.
rewrite (Nnot_div2_not_double_plus_one a a0 H0).

*****
H0 : eq (N.eqb (N.div2 a) a0) false
y : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A) (a2 : ad) (a3 : A), eq (MapGet (makeM2 (M1 a0 a1) (M1 a2 a3)) a) (MapGet (M1 a2 a3) (N.div2 a))
+++++
intros a0 y0 a1 y1.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y0 a1 y1.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M1 a0 y0) (M1 a1 y1)) a) (MapGet (M1 a1 y1) (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y0 a1 y1.
unfold makeM2 in |- *.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 (M1 a0 y0) (M1 a1 y1)) a) (MapGet (M1 a1 y1) (N.div2 a))
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y0 a1 y1.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_1.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M1 a1 y1) (N.div2 a)) (MapGet (M1 a1 y1) (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros a0 y0 a1 y1.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_1.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) true
+++++
assumption.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (m m0 : Map) (a0 : ad) (a1 : A), eq (MapGet (makeM2 (M2 m m0) (M1 a0 a1)) a) (MapGet (M1 a0 a1) (N.div2 a))
+++++
intros m1 m2 a0 y.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2 a0 y.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M2 m1 m2) (M1 a0 y)) a) (MapGet (M1 a0 y) (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2 a0 y.
unfold makeM2 in |- *.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 (M2 m1 m2) (M1 a0 y)) a) (MapGet (M1 a0 y) (N.div2 a))
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2 a0 y.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_1.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M1 a0 y) (N.div2 a)) (MapGet (M1 a0 y) (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
case m.
intros m1 m2 a0 y.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_1.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) true
+++++
assumption.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.

*****
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall m0 m1 : Map, eq (MapGet (makeM2 m (M2 m0 m1)) a) (MapGet (M2 m0 m1) (N.div2 a))
+++++
intros m1 m2.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.
unfold makeM2 in |- *.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet match m with | M0 | _ => M2 m (M2 m1 m2) end a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
cut (MapGet (M2 m (M2 m1 m2)) a = MapGet (M2 m1 m2) (Ndiv2 a)).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.
unfold makeM2 in |- *.
cut (MapGet (M2 m (M2 m1 m2)) a = MapGet (M2 m1 m2) (Ndiv2 a)).

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (MapGet (M2 m (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a)), eq (MapGet match m with | M0 | _ => M2 m (M2 m1 m2) end a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
case m.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.
unfold makeM2 in |- *.
cut (MapGet (M2 m (M2 m1 m2)) a = MapGet (M2 m1 m2) (Ndiv2 a)).
case m.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (MapGet (M2 M0 (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a)), eq (MapGet (M2 M0 (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
trivial.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.
unfold makeM2 in |- *.
cut (MapGet (M2 m (M2 m1 m2)) a = MapGet (M2 m1 m2) (Ndiv2 a)).
case m.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A) (_ : eq (MapGet (M2 (M1 a0 a1) (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))), eq (MapGet (M2 (M1 a0 a1) (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
trivial.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.
unfold makeM2 in |- *.
cut (MapGet (M2 m (M2 m1 m2)) a = MapGet (M2 m1 m2) (Ndiv2 a)).
case m.

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
forall (m m0 : Map) (_ : eq (MapGet (M2 (M2 m m0) (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))), eq (MapGet (M2 (M2 m m0) (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
trivial.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_1 a H m m').
case m'.
intros m1 m2.
unfold makeM2 in |- *.
cut (MapGet (M2 m (M2 m1 m2)) a = MapGet (M2 m1 m2) (Ndiv2 a)).

*****
m1,m2 : Map
H : eq (N.odd a) true
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 m (M2 m1 m2)) a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
exact (MapGet_M2_bit_0_1 a H m (M2 m1 m2)).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet (makeM2 m m') a) (MapGet (M2 m m') a)
+++++
intro H.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m m') a) (MapGet (M2 m m') a)
+++++
rewrite (MapGet_M2_bit_0_0 a H m m').
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 m m') a) (MapGet m (N.div2 a))
+++++
case m.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 M0 m') a) (MapGet M0 (N.div2 a))
+++++
case m'.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 M0 M0) a) (MapGet M0 (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A), eq (MapGet (makeM2 M0 (M1 a0 a1)) a) (MapGet M0 (N.div2 a))
+++++
intros a0 y.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 M0 (M1 a0 y)) a) (MapGet M0 (N.div2 a))
+++++
simpl in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.succ_double a0) a then Some y else None) None
+++++
rewrite (Neven_not_double_plus_one a H a0).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
rewrite (Neven_not_double_plus_one a H a0).

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall m m0 : Map, eq (MapGet (makeM2 M0 (M2 m m0)) a) (MapGet M0 (N.div2 a))
+++++
intros m1 m2.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2.

*****
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 M0 (M2 m1 m2)) a) (MapGet M0 (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2.
unfold makeM2 in |- *.

*****
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 M0 (M2 m1 m2)) a) (MapGet M0 (N.div2 a))
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_0.

*****
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet M0 (N.div2 a)) (MapGet M0 (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_0.

*****
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) false
+++++
assumption.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A), eq (MapGet (makeM2 (M1 a0 a1) m') a) (MapGet (M1 a0 a1) (N.div2 a))
+++++
case m'.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A), eq (MapGet (makeM2 (M1 a0 a1) M0) a) (MapGet (M1 a0 a1) (N.div2 a))
+++++
intros a0 y.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M1 a0 y) M0) a) (MapGet (M1 a0 y) (N.div2 a))
+++++
simpl in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.eqb a0 (N.div2 a)) true, eq (if N.eqb (N.double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
intro H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
rewrite H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double a0) a then Some y else None) (Some y)
+++++
rewrite (Neqb_complete _ _ H0).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double (N.div2 a)) a then Some y else None) (Some y)
+++++
rewrite (Ndiv2_double a H).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (Ndiv2_double a H).

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb a a then Some y else None) (Some y)
+++++
rewrite (Neqb_correct a).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (Ndiv2_double a H).
rewrite (Neqb_correct a).

*****
H0 : eq (N.eqb a0 (N.div2 a)) true
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).

*****
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (N.eqb a0 (N.div2 a)) false, eq (if N.eqb (N.double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
intro H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) false
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double a0) a then Some y else None) (if N.eqb a0 (N.div2 a) then Some y else None)
+++++
rewrite H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a0 (N.div2 a)) false
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb (N.double a0) a then Some y else None) None
+++++
rewrite (Neqb_comm (Ndouble a0) a).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_comm (Ndouble a0) a).

*****
H0 : eq (N.eqb a0 (N.div2 a)) false
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb a (N.double a0) then Some y else None) None
+++++
rewrite (Neqb_comm a0 (Ndiv2 a)) in H0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_comm (Ndouble a0) a).
rewrite (Neqb_comm a0 (Ndiv2 a)) in H0.

*****
H0 : eq (N.eqb (N.div2 a) a0) false
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (if N.eqb a (N.double a0) then Some y else None) None
+++++
rewrite (Nnot_div2_not_double a a0 H0).
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 (Ndiv2 a))).
intro H0.
rewrite H0.
rewrite (Neqb_comm (Ndouble a0) a).
rewrite (Neqb_comm a0 (Ndiv2 a)) in H0.
rewrite (Nnot_div2_not_double a a0 H0).

*****
H0 : eq (N.eqb (N.div2 a) a0) false
y : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall (a0 : ad) (a1 : A) (a2 : ad) (a3 : A), eq (MapGet (makeM2 (M1 a2 a3) (M1 a0 a1)) a) (MapGet (M1 a2 a3) (N.div2 a))
+++++
intros a0 y0 a1 y1.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y0 a1 y1.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M1 a1 y1) (M1 a0 y0)) a) (MapGet (M1 a1 y1) (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y0 a1 y1.
unfold makeM2 in |- *.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 (M1 a1 y1) (M1 a0 y0)) a) (MapGet (M1 a1 y1) (N.div2 a))
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y0 a1 y1.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_0.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M1 a1 y1) (N.div2 a)) (MapGet (M1 a1 y1) (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros a0 y0 a1 y1.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_0.

*****
y1 : A
a1 : ad
y0 : A
a0 : ad
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) false
+++++
assumption.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall (m m0 : Map) (a0 : ad) (a1 : A), eq (MapGet (makeM2 (M1 a0 a1) (M2 m m0)) a) (MapGet (M1 a0 a1) (N.div2 a))
+++++
intros m1 m2 a0 y.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2 a0 y.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M1 a0 y) (M2 m1 m2)) a) (MapGet (M1 a0 y) (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2 a0 y.
unfold makeM2 in |- *.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 (M1 a0 y) (M2 m1 m2)) a) (MapGet (M1 a0 y) (N.div2 a))
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2 a0 y.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_0.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M1 a0 y) (N.div2 a)) (MapGet (M1 a0 y) (N.div2 a))
+++++
reflexivity.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
case m'.
intros m1 m2 a0 y.
unfold makeM2 in |- *.
rewrite MapGet_M2_bit_0_0.

*****
y : A
a0 : ad
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (N.odd a) false
+++++
assumption.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.

*****
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
forall m m0 : Map, eq (MapGet (makeM2 (M2 m m0) m') a) (MapGet (M2 m m0) (N.div2 a))
+++++
intros m1 m2.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
intros m1 m2.

*****
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (makeM2 (M2 m1 m2) m') a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
unfold makeM2 in |- *.
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H.
rewrite (MapGet_M2_bit_0_0 a H m m').
case m.
intros m1 m2.
unfold makeM2 in |- *.

*****
m1,m2 : Map
H : eq (N.odd a) false
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (M2 (M2 m1 m2) m') a) (MapGet (M2 m1 m2) (N.div2 a))
+++++
exact (MapGet_M2_bit_0_0 a H (M2 m1 m2) m').
-----
Lemma makeM2_M2 : forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****

*****

+++++
Qed.
-----
Fixpoint MapRemove (m:Map) : ad -> Map :=\n    match m with\n    | M0 => fun _:ad => M0\n    | M1 a y =>\n        fun a':ad => match Neqb a a' with\n                     | true => M0\n                     | false => m\n                     end\n    | M2 m1 m2 =>\n        fun a:ad =>\n          if Nbit0 a\n          then makeM2 m1 (MapRemove m2 (Ndiv2 a))\n          else makeM2 (MapRemove m1 (Ndiv2 a)) m2\n    end.
-----
Lemma MapRemove_semantics :\n   forall (m:Map) (a:ad),\n     eqm (MapGet (MapRemove m a))\n       (fun a':ad => if Neqb a a' then None else MapGet m a').
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').

*****
A : Type
*****
forall (m : Map) (a : ad), eqm (MapGet (MapRemove m a)) (fun a' : ad => if N.eqb a a' then None else MapGet m a')
+++++
Proof.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.

*****
A : Type
*****
forall (m : Map) (a : ad), eqm (MapGet (MapRemove m a)) (fun a' : ad => if N.eqb a a' then None else MapGet m a')
+++++
unfold eqm in |- *.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m : Map) (a a0 : ad), eq (MapGet (MapRemove m a) a0) (if N.eqb a a0 then None else MapGet m a0)
+++++
simple induction m.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall a a0 : ad, eq (MapGet (MapRemove M0 a) a0) (if N.eqb a a0 then None else MapGet M0 a0)
+++++
simpl in |- *.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.

*****
m : Map
A : Type
*****
forall a a0 : ad, eq None (if N.eqb a a0 then None else None)
+++++
intros.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.

*****
a,a0 : ad
m : Map
A : Type
*****
eq None (if N.eqb a a0 then None else None)
+++++
case (Neqb a a0).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.
case (Neqb a a0).

*****
a,a0 : ad
m : Map
A : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
simpl in |- *.
intros.
case (Neqb a a0).

*****
a,a0 : ad
m : Map
A : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 a2 : ad), eq (MapGet (MapRemove (M1 a a0) a1) a2) (if N.eqb a1 a2 then None else MapGet (M1 a a0) a2)
+++++
intros.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapRemove (M1 a a0) a1) a2) (if N.eqb a1 a2 then None else MapGet (M1 a a0) a2)
+++++
simpl in |- *.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.

*****
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
elim (sumbool_of_bool (Neqb a1 a2)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).

*****
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a1 a2) true, eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
intro H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.

*****
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
rewrite H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.

*****
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) None
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).

*****
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) None
+++++
intro H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) None
+++++
rewrite H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet M0 a2) None
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).

*****
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) None
+++++
intro H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) false
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) None
+++++
rewrite H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a1) false
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a2) None
+++++
rewrite (Neqb_complete _ _ H) in H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
rewrite H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H) in H0.

*****
H0 : eq (N.eqb a a2) false
H : eq (N.eqb a1 a2) true
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a2) None
+++++
exact (M1_semantics_2 a a2 a0 H0).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).

*****
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a1 a2) false, eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
intro H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.

*****
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).

*****
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
intro H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
rewrite H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet M0 a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
rewrite H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite H.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet M0 a2) (if N.eqb a a2 then Some a0 else None)
+++++
rewrite <- (Neqb_complete _ _ H0) in H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite H.
rewrite <- (Neqb_complete _ _ H0) in H.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet M0 a2) (if N.eqb a a2 then Some a0 else None)
+++++
rewrite H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite H.
rewrite <- (Neqb_complete _ _ H0) in H.
rewrite H.

*****
H0 : eq (N.eqb a a1) true
H : eq (N.eqb a a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet M0 a2) None
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).

*****
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
intro H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) false
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a1 then M0 else M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
rewrite H0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a1) false
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a2) (if N.eqb a1 a2 then None else if N.eqb a a2 then Some a0 else None)
+++++
rewrite H.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a1 a2)).
intro H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite H.

*****
H0 : eq (N.eqb a a1) false
H : eq (N.eqb a1 a2) false
a1,a2 : ad
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a a0) a2) (if N.eqb a a2 then Some a0 else None)
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall a a0 : ad, eq (MapGet (MapRemove m a) a0) (if N.eqb a a0 then None else MapGet m a0)) (m0 : Map) (_ : forall a a0 : ad, eq (MapGet (MapRemove m0 a) a0) (if N.eqb a a0 then None else MapGet m0 a0)) (a a0 : ad), eq (MapGet (MapRemove (M2 m m0) a) a0) (if N.eqb a a0 then None else MapGet (M2 m m0) a0)
+++++
intros.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapRemove (M2 m0 m1) a) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.

*****
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then makeM2 m0 (MapRemove m1 (N.div2 a)) else makeM2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).

*****
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet (if N.odd a then makeM2 m0 (MapRemove m1 (N.div2 a)) else makeM2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.

*****
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then makeM2 m0 (MapRemove m1 (N.div2 a)) else makeM2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite H1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (makeM2 m0 (MapRemove m1 (N.div2 a))) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).

*****
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 (MapRemove m1 (N.div2 a))) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
elim (sumbool_of_bool (Nbit0 a0)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) true, eq (MapGet (M2 m0 (MapRemove m1 (N.div2 a))) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H2.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 (MapRemove m1 (N.div2 a))) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapRemove m1 (N.div2 a)) (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) None
+++++
rewrite (Ndiv2_eq _ _ H3).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite (Ndiv2_eq _ _ H3).

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (MapGet (M2 m0 m1) a0)
+++++
rewrite <- H2 in H1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) (N.odd a0)
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m1 (N.div2 a0)) (MapGet (M2 m0 m1) a0)
+++++
rewrite (Ndiv2_bit_neq _ _ H3 H1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.
rewrite (Ndiv2_bit_neq _ _ H3 H1).

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) (N.odd a0)
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (MapGet (M2 m0 m1) a0)
+++++
rewrite (MapGet_M2_bit_0_1 a0 H2 m0 m1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (H0 (Ndiv2 a) (Ndiv2 a0)).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.
rewrite (Ndiv2_bit_neq _ _ H3 H1).
rewrite (MapGet_M2_bit_0_1 a0 H2 m0 m1).

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) (N.odd a0)
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (N.odd a0) true
+++++
assumption.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) false, eq (MapGet (M2 m0 (MapRemove m1 (N.div2 a))) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H2.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 (MapRemove m1 (N.div2 a))) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 (MapRemove m1 (Ndiv2 a))).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 (MapRemove m1 (Ndiv2 a))).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (Neqb_comm a a0).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 (MapRemove m1 (Ndiv2 a))).
rewrite (Neqb_comm a a0).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (if N.eqb a0 a then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (Nbit0_neq _ _ H2 H1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 (MapRemove m1 (Ndiv2 a))).
rewrite (Neqb_comm a a0).
rewrite (Nbit0_neq _ _ H2 H1).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (MapGet (M2 m0 m1) a0)
+++++
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 m0 (MapRemove m1 (Ndiv2 a)) a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 (MapRemove m1 (Ndiv2 a))).
rewrite (Neqb_comm a a0).
rewrite (Nbit0_neq _ _ H2 H1).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) true
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).

*****
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet (if N.odd a then makeM2 m0 (MapRemove m1 (N.div2 a)) else makeM2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.

*****
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (if N.odd a then makeM2 m0 (MapRemove m1 (N.div2 a)) else makeM2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite H1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (makeM2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).

*****
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
elim (sumbool_of_bool (Nbit0 a0)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) true, eq (MapGet (M2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H2.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (MapGet_M2_bit_0_1 a0 H2 m0 m1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (MapGet_M2_bit_0_1 a0 H2 m0 m1).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (if N.eqb a a0 then None else MapGet m1 (N.div2 a0))
+++++
rewrite (Nbit0_neq a a0 H1 H2).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.
rewrite (MapGet_M2_bit_0_1 a0 H2 m0 m1).
rewrite (Nbit0_neq a a0 H1 H2).

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a0)) (MapGet m1 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_1.

*****
H2 : eq (N.odd a0) true
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (N.odd a0) true
+++++
assumption.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).

*****
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a0) false, eq (MapGet (M2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
intro H2.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapRemove m0 (N.div2 a)) m1) a0) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet (MapRemove m0 (N.div2 a)) (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet (M2 m0 m1) a0)
+++++
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet m0 (N.div2 a0))
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet m0 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet m0 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) None
+++++
rewrite (Ndiv2_eq _ _ H3).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite (Ndiv2_eq _ _ H3).

*****
H3 : eq (N.eqb a a0) true
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet m0 (N.div2 a0))
+++++
intro H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (if N.eqb a a0 then None else MapGet m0 (N.div2 a0))
+++++
rewrite H3.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
rewrite <- H2 in H1.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) (N.odd a0)
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (if N.eqb (N.div2 a) (N.div2 a0) then None else MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
rewrite (Ndiv2_bit_neq _ _ H3 H1).
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.
rewrite (H (Ndiv2 a) (Ndiv2 a0)).
rewrite (MapGet_M2_bit_0_0 a0 H2 m0 m1).
elim (sumbool_of_bool (Neqb a a0)).
intro H3.
rewrite H3.
rewrite <- H2 in H1.
rewrite (Ndiv2_bit_neq _ _ H3 H1).

*****
H3 : eq (N.eqb a a0) false
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) (N.odd a0)
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a0)) (MapGet m0 (N.div2 a0))
+++++
reflexivity.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.
intros.
change (MapGet (if Nbit0 a then makeM2 m0 (MapRemove m1 (Ndiv2 a)) else makeM2 (MapRemove m0 (Ndiv2 a)) m1) a0 = (if Neqb a a0 then None else MapGet (M2 m0 m1) a0)) in |- *.
elim (sumbool_of_bool (Nbit0 a)).
intro H1.
rewrite H1.
rewrite (makeM2_M2 (MapRemove m0 (Ndiv2 a)) m1 a0).
elim (sumbool_of_bool (Nbit0 a0)).
intro H2.
rewrite MapGet_M2_bit_0_0.

*****
H2 : eq (N.odd a0) false
H1 : eq (N.odd a) false
a,a0 : ad
H0 : forall a a0 : ad,\neq (MapGet (MapRemove m1 a) a0)\n (if N.eqb a a0 then None else MapGet m1 a0)
m1 : Map
H : forall a a0 : ad,\neq (MapGet (MapRemove m0 a) a0)\n (if N.eqb a a0 then None else MapGet m0 a0)
m,m0 : Map
A : Type
*****
eq (N.odd a0) false
+++++
assumption.
-----
Lemma MapRemove_semantics : forall (m:Map) (a:ad), eqm (MapGet (MapRemove m a)) (fun a':ad => if Neqb a a' then None else MapGet m a').
Proof.
unfold eqm in |- *.
simple induction m.

*****

*****

+++++
Qed.
-----
Fixpoint MapCard (m:Map) : nat :=\n    match m with\n    | M0 => 0\n    | M1 _ _ => 1\n    | M2 m m' => MapCard m + MapCard m'\n    end.
-----
Fixpoint MapMerge (m:Map) : Map -> Map :=\n    match m with\n    | M0 => fun m':Map => m'\n    | M1 a y => fun m':Map => MapPut_behind m' a y\n    | M2 m1 m2 =>\n        fun m':Map =>\n          match m' with\n          | M0 => m\n          | M1 a' y' => MapPut m a' y'\n          | M2 m'1 m'2 => M2 (MapMerge m1 m'1) (MapMerge m2 m'2)\n          end\n    end.
-----
Lemma MapMerge_semantics :\n   forall m m':Map,\n     eqm (MapGet (MapMerge m m'))\n       (fun a0:ad =>\n          match MapGet m' a0 with\n          | Some y' => Some y'\n          | None => MapGet m a0\n          end).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (MapMerge m m')) (fun a0 : ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end)
+++++
Proof.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (MapMerge m m')) (fun a0 : ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end)
+++++
unfold eqm in |- *.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (MapMerge m m') a) match MapGet m' a with | Some y' => Some y' | None => MapGet m a end
+++++
simple induction m.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (m' : Map) (a : ad), eq (MapGet (MapMerge M0 m') a) match MapGet m' a with | Some y' => Some y' | None => MapGet M0 a end
+++++
intros.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapMerge M0 m') a) match MapGet m' a with | Some y' => Some y' | None => MapGet M0 a end
+++++
simpl in |- *.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet m' a) match MapGet m' a with | Some y' => Some y' | None => None end
+++++
case (MapGet m' a).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
case (MapGet m' a).

*****
a : ad
m,m' : Map
A : Type
*****
forall a : A, eq (Some a) (Some a)
+++++
trivial.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
case (MapGet m' a).

*****
a : ad
m,m' : Map
A : Type
*****
eq None None
+++++
trivial.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map) (a1 : ad), eq (MapGet (MapMerge (M1 a a0) m') a1) match MapGet m' a1 with | Some y' => Some y' | None => MapGet (M1 a a0) a1 end
+++++
intros.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.

*****
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapMerge (M1 a a0) m') a1) match MapGet m' a1 with | Some y' => Some y' | None => MapGet (M1 a a0) a1 end
+++++
simpl in |- *.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.

*****
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut_behind m' a a0) a1) match MapGet m' a1 with | Some y' => Some y' | None => if N.eqb a a1 then Some a0 else None end
+++++
rewrite (MapPut_behind_semantics m' a a0 a1).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
intros.
simpl in |- *.
rewrite (MapPut_behind_semantics m' a a0 a1).

*****
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq match MapGet m' a1 with | Some y' => Some y' | None => if N.eqb a a1 then Some a0 else None end match MapGet m' a1 with | Some y' => Some y' | None => if N.eqb a a1 then Some a0 else None end
+++++
reflexivity.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (m' : Map) (a : ad), eq (MapGet (MapMerge m m') a) match MapGet m' a with | Some y' => Some y' | None => MapGet m a end) (m0 : Map) (_ : forall (m' : Map) (a : ad), eq (MapGet (MapMerge m0 m') a) match MapGet m' a with | Some y' => Some y' | None => MapGet m0 a end) (m' : Map) (a : ad), eq (MapGet (MapMerge (M2 m m0) m') a) match MapGet m' a with | Some y' => Some y' | None => MapGet (M2 m m0) a end
+++++
simple induction m'.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
forall a : ad, eq (MapGet (MapMerge (M2 m0 m1) M0) a) match MapGet M0 a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
trivial.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad), eq (MapGet (MapMerge (M2 m0 m1) (M1 a a0)) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
intros.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.

*****
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapMerge (M2 m0 m1) (M1 a a0)) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
unfold MapMerge in |- *.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.

*****
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapPut (M2 m0 m1) a a0) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).

*****
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.eqb a a1 then Some a0 else MapGet (M2 m0 m1) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a1) true, eq (if N.eqb a a1 then Some a0 else MapGet (M2 m0 m1) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
intro H1.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.eqb a a1 then Some a0 else MapGet (M2 m0 m1) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
rewrite H1.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (Some a0) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (Some a0) match MapGet (M1 a1 a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
rewrite (M1_semantics_1 a1 a0).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.
rewrite (Neqb_complete _ _ H1).
rewrite (M1_semantics_1 a1 a0).

*****
H1 : eq (N.eqb a a1) true
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (Some a0) (Some a0)
+++++
reflexivity.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
forall _ : eq (N.eqb a a1) false, eq (if N.eqb a a1 then Some a0 else MapGet (M2 m0 m1) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
intro H1.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.eqb a a1 then Some a0 else MapGet (M2 m0 m1) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
rewrite H1.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a1) match MapGet (M1 a a0) a1 with | Some y' => Some y' | None => MapGet (M2 m0 m1) a1 end
+++++
rewrite (M1_semantics_2 a a1 a0 H1).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
unfold MapMerge in |- *.
rewrite (MapPut_semantics (M2 m0 m1) a a0 a1).
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite H1.
rewrite (M1_semantics_2 a a1 a0 H1).

*****
H1 : eq (N.eqb a a1) false
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a1) (MapGet (M2 m0 m1) a1)
+++++
reflexivity.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
forall (m : Map) (_ : forall a : ad, eq (MapGet (MapMerge (M2 m0 m1) m) a) match MapGet m a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end) (m2 : Map) (_ : forall a : ad, eq (MapGet (MapMerge (M2 m0 m1) m2) a) match MapGet m2 a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end) (a : ad), eq (MapGet (MapMerge (M2 m0 m1) (M2 m m2)) a) match MapGet (M2 m m2) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
intros.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapMerge (M2 m0 m1) (M2 m2 m3)) a) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
forall _ : eq (MapMerge (M2 m0 m1) (M2 m2 m3)) (M2 (MapMerge m0 m2) (MapMerge m1 m3)), eq (MapGet (MapMerge (M2 m0 m1) (M2 m2 m3)) a) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
intro.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (MapMerge (M2 m0 m1) (M2 m2 m3)) a) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
rewrite H3.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapMerge m0 m2) (MapMerge m1 m3)) a) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapMerge m1 m3) (N.div2 a) else MapGet (MapMerge m0 m2) (N.div2 a)) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
rewrite (H0 m3 (Ndiv2 a)).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.odd a then match MapGet m3 (N.div2 a) with | Some y' => Some y' | None => MapGet m1 (N.div2 a) end else MapGet (MapMerge m0 m2) (N.div2 a)) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
rewrite (H m2 (Ndiv2 a)).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.odd a then match MapGet m3 (N.div2 a) with | Some y' => Some y' | None => MapGet m1 (N.div2 a) end else match MapGet m2 (N.div2 a) with | Some y' => Some y' | None => MapGet m0 (N.div2 a) end) match MapGet (M2 m2 m3) a with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
rewrite (MapGet_M2_bit_0_if m2 m3 a).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if m2 m3 a).

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.odd a then match MapGet m3 (N.div2 a) with | Some y' => Some y' | None => MapGet m1 (N.div2 a) end else match MapGet m2 (N.div2 a) with | Some y' => Some y' | None => MapGet m0 (N.div2 a) end) match (if N.odd a then MapGet m3 (N.div2 a) else MapGet m2 (N.div2 a)) with | Some y' => Some y' | None => MapGet (M2 m0 m1) a end
+++++
rewrite (MapGet_M2_bit_0_if m0 m1 a).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if m2 m3 a).
rewrite (MapGet_M2_bit_0_if m0 m1 a).

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (if N.odd a then match MapGet m3 (N.div2 a) with | Some y' => Some y' | None => MapGet m1 (N.div2 a) end else match MapGet m2 (N.div2 a) with | Some y' => Some y' | None => MapGet m0 (N.div2 a) end) match (if N.odd a then MapGet m3 (N.div2 a) else MapGet m2 (N.div2 a)) with | Some y' => Some y' | None => if N.odd a then MapGet m1 (N.div2 a) else MapGet m0 (N.div2 a) end
+++++
case (Nbit0 a).
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if m2 m3 a).
rewrite (MapGet_M2_bit_0_if m0 m1 a).
case (Nbit0 a).

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq match MapGet m3 (N.div2 a) with | Some y' => Some y' | None => MapGet m1 (N.div2 a) end match MapGet m3 (N.div2 a) with | Some y' => Some y' | None => MapGet m1 (N.div2 a) end
+++++
trivial.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).
intro.
rewrite H3.
rewrite MapGet_M2_bit_0_if.
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).
rewrite (MapGet_M2_bit_0_if m2 m3 a).
rewrite (MapGet_M2_bit_0_if m0 m1 a).
case (Nbit0 a).

*****
H3 : eq (MapMerge (M2 m0 m1) (M2 m2 m3))\n (M2 (MapMerge m0 m2) (MapMerge m1 m3))
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq match MapGet m2 (N.div2 a) with | Some y' => Some y' | None => MapGet m0 (N.div2 a) end match MapGet m2 (N.div2 a) with | Some y' => Some y' | None => MapGet m0 (N.div2 a) end
+++++
trivial.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
cut (MapMerge (M2 m0 m1) (M2 m2 m3) = M2 (MapMerge m0 m2) (MapMerge m1 m3)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m3) a)\n match MapGet m3 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapMerge (M2 m0 m1) m2) a)\n match MapGet m2 a with\n | Some y' => Some y'\n | None => MapGet (M2 m0 m1) a\n end
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m1 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m1 a\n end
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapMerge m0 m') a)\n match MapGet m' a with\n | Some y' => Some y'\n | None => MapGet m0 a\n end
m,m0 : Map
A : Type
*****
eq (MapMerge (M2 m0 m1) (M2 m2 m3)) (M2 (MapMerge m0 m2) (MapMerge m1 m3))
+++++
reflexivity.
-----
Lemma MapMerge_semantics : forall m m':Map, eqm (MapGet (MapMerge m m')) (fun a0:ad => match MapGet m' a0 with | Some y' => Some y' | None => MapGet m a0 end).
Proof.
unfold eqm in |- *.
simple induction m.

*****

*****

+++++
Qed.
-----
Fixpoint MapDelta (m:Map) : Map -> Map :=\n    match m with\n    | M0 => fun m':Map => m'\n    | M1 a y =>\n        fun m':Map =>\n          match MapGet m' a with\n          | None => MapPut m' a y\n          | _ => MapRemove m' a\n          end\n    | M2 m1 m2 =>\n        fun m':Map =>\n          match m' with\n          | M0 => m\n          | M1 a' y' =>\n              match MapGet m a' with\n              | None => MapPut m a' y'\n              | _ => MapRemove m a'\n              end\n          | M2 m'1 m'2 => makeM2 (MapDelta m1 m'1) (MapDelta m2 m'2)\n          end\n    end.
-----
Lemma MapDelta_semantics_comm :\n   forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m))
+++++
Proof.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m))
+++++
unfold eqm in |- *.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (MapDelta m m') a) (MapGet (MapDelta m' m) a)
+++++
simple induction m.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (m' : Map) (a : ad), eq (MapGet (MapDelta M0 m') a) (MapGet (MapDelta m' M0) a)
+++++
simple induction m'.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m,m' : Map
A : Type
*****
forall a : ad, eq (MapGet (MapDelta M0 M0) a) (MapGet (MapDelta M0 M0) a)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m,m' : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad), eq (MapGet (MapDelta M0 (M1 a a0)) a1) (MapGet (MapDelta (M1 a a0) M0) a1)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m,m' : Map
A : Type
*****
forall (m : Map) (_ : forall a : ad, eq (MapGet (MapDelta M0 m) a) (MapGet (MapDelta m M0) a)) (m0 : Map) (_ : forall a : ad, eq (MapGet (MapDelta M0 m0) a) (MapGet (MapDelta m0 M0) a)) (a : ad), eq (MapGet (MapDelta M0 (M2 m m0)) a) (MapGet (MapDelta (M2 m m0) M0) a)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map) (a1 : ad), eq (MapGet (MapDelta (M1 a a0) m') a1) (MapGet (MapDelta m' (M1 a a0)) a1)
+++++
simple induction m'.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall a1 : ad, eq (MapGet (MapDelta (M1 a a0) M0) a1) (MapGet (MapDelta M0 (M1 a a0)) a1)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall (a1 : ad) (a2 : A) (a3 : ad), eq (MapGet (MapDelta (M1 a a0) (M1 a1 a2)) a3) (MapGet (MapDelta (M1 a1 a2) (M1 a a0)) a3)
+++++
unfold MapDelta in |- *.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.

*****
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall (a1 : ad) (a2 : A) (a3 : ad), eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a1 with | Some _ => MapRemove (M1 a a0) a1 | None => MapPut (M1 a a0) a1 a2 end a3)
+++++
intros.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.

*****
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a1 with | Some _ => MapRemove (M1 a a0) a1 | None => MapPut (M1 a a0) a1 a2 end a3)
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a1 with | Some _ => MapRemove (M1 a a0) a1 | None => MapPut (M1 a a0) a1 a2 end a3)
+++++
intro H.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.

*****
H : eq (N.eqb a a1) true
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a1 with | Some _ => MapRemove (M1 a a0) a1 | None => MapPut (M1 a a0) a1 a2 end a3)
+++++
rewrite <- (Neqb_complete _ _ H).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite <- (Neqb_complete _ _ H).

*****
H : eq (N.eqb a a1) true
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match MapGet (M1 a a2) a with | Some _ => MapRemove (M1 a a2) a | None => MapPut (M1 a a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a with | Some _ => MapRemove (M1 a a0) a | None => MapPut (M1 a a0) a a2 end a3)
+++++
rewrite (M1_semantics_1 a a2).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite <- (Neqb_complete _ _ H).
rewrite (M1_semantics_1 a a2).

*****
H : eq (N.eqb a a1) true
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapRemove (M1 a a2) a) a3) (MapGet match MapGet (M1 a a0) a with | Some _ => MapRemove (M1 a a0) a | None => MapPut (M1 a a0) a a2 end a3)
+++++
rewrite (M1_semantics_1 a a0).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite <- (Neqb_complete _ _ H).
rewrite (M1_semantics_1 a a2).
rewrite (M1_semantics_1 a a0).

*****
H : eq (N.eqb a a1) true
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapRemove (M1 a a2) a) a3) (MapGet (MapRemove (M1 a a0) a) a3)
+++++
simpl in |- *.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite <- (Neqb_complete _ _ H).
rewrite (M1_semantics_1 a a2).
rewrite (M1_semantics_1 a a0).
simpl in |- *.

*****
H : eq (N.eqb a a1) true
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (if N.eqb a a then M0 else M1 a a2) a3) (MapGet (if N.eqb a a then M0 else M1 a a0) a3)
+++++
rewrite (Neqb_correct a).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite <- (Neqb_complete _ _ H).
rewrite (M1_semantics_1 a a2).
rewrite (M1_semantics_1 a a0).
simpl in |- *.
rewrite (Neqb_correct a).

*****
H : eq (N.eqb a a1) true
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet M0 a3) (MapGet M0 a3)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a1 with | Some _ => MapRemove (M1 a a0) a1 | None => MapPut (M1 a a0) a1 a2 end a3)
+++++
intro H.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.

*****
H : eq (N.eqb a a1) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet match MapGet (M1 a a0) a1 with | Some _ => MapRemove (M1 a a0) a1 | None => MapPut (M1 a a0) a1 a2 end a3)
+++++
rewrite (M1_semantics_2 a a1 a0 H).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).

*****
H : eq (N.eqb a a1) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet (MapPut (M1 a a0) a1 a2) a3)
+++++
rewrite (Neqb_comm a a1) in H.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.

*****
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet match MapGet (M1 a1 a2) a with | Some _ => MapRemove (M1 a1 a2) a | None => MapPut (M1 a1 a2) a a0 end a3) (MapGet (MapPut (M1 a a0) a1 a2) a3)
+++++
rewrite (M1_semantics_2 a1 a a2 H).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).

*****
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut (M1 a1 a2) a a0) a3) (MapGet (MapPut (M1 a a0) a1 a2) a3)
+++++
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).

*****
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapPut (M1 a1 a2) a a0) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).

*****
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (if N.eqb a a3 then Some a0 else MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
elim (sumbool_of_bool (Neqb a a3)).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).

*****
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a3) true, eq (if N.eqb a a3 then Some a0 else MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
intro H0.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.

*****
H0 : eq (N.eqb a a3) true
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (if N.eqb a a3 then Some a0 else MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
rewrite H0.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a3) true
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (Some a0) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
rewrite (Neqb_complete _ _ H0) in H.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0) in H.

*****
H0 : eq (N.eqb a a3) true
H : eq (N.eqb a1 a3) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (Some a0) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
rewrite H.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0) in H.
rewrite H.

*****
H0 : eq (N.eqb a a3) true
H : eq (N.eqb a1 a3) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (Some a0) (MapGet (M1 a a0) a3)
+++++
rewrite (Neqb_complete _ _ H0).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0) in H.
rewrite H.
rewrite (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a a3) true
H : eq (N.eqb a1 a3) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (Some a0) (MapGet (M1 a3 a0) a3)
+++++
rewrite (M1_semantics_1 a3 a0).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0) in H.
rewrite H.
rewrite (Neqb_complete _ _ H0).
rewrite (M1_semantics_1 a3 a0).

*****
H0 : eq (N.eqb a a3) true
H : eq (N.eqb a1 a3) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (Some a0) (Some a0)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).

*****
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a a3) false, eq (if N.eqb a a3 then Some a0 else MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
intro H0.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.

*****
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (if N.eqb a a3 then Some a0 else MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
rewrite H0.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else MapGet (M1 a a0) a3)
+++++
rewrite (M1_semantics_2 a a3 a0 H0).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).

*****
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else None)
+++++
elim (sumbool_of_bool (Neqb a1 a3)).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).

*****
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a1 a3) true, eq (MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else None)
+++++
intro H1.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).
intro H1.

*****
H1 : eq (N.eqb a1 a3) true
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else None)
+++++
rewrite H1.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a1 a3) true
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a1 a2) a3) (Some a2)
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).
intro H1.
rewrite H1.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a1 a3) true
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a3 a2) a3) (Some a2)
+++++
exact (M1_semantics_1 a3 a2).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).

*****
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall _ : eq (N.eqb a1 a3) false, eq (MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else None)
+++++
intro H1.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).
intro H1.

*****
H1 : eq (N.eqb a1 a3) false
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a1 a2) a3) (if N.eqb a1 a3 then Some a2 else None)
+++++
rewrite H1.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
unfold MapDelta in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H.
rewrite (M1_semantics_2 a a1 a0 H).
rewrite (Neqb_comm a a1) in H.
rewrite (M1_semantics_2 a1 a a2 H).
rewrite (MapPut_semantics (M1 a a0) a1 a2 a3).
rewrite (MapPut_semantics (M1 a1 a2) a a0 a3).
elim (sumbool_of_bool (Neqb a a3)).
intro H0.
rewrite H0.
rewrite (M1_semantics_2 a a3 a0 H0).
elim (sumbool_of_bool (Neqb a1 a3)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a1 a3) false
H0 : eq (N.eqb a a3) false
H : eq (N.eqb a1 a) false
a3 : ad
a2 : A
a1 : ad
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (M1 a1 a2) a3) None
+++++
exact (M1_semantics_2 a1 a3 a2 H1).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
a0 : A
a : ad
m : Map
A : Type
*****
forall (m : Map) (_ : forall a1 : ad, eq (MapGet (MapDelta (M1 a a0) m) a1) (MapGet (MapDelta m (M1 a a0)) a1)) (m0 : Map) (_ : forall a1 : ad, eq (MapGet (MapDelta (M1 a a0) m0) a1) (MapGet (MapDelta m0 (M1 a a0)) a1)) (a1 : ad), eq (MapGet (MapDelta (M1 a a0) (M2 m m0)) a1) (MapGet (MapDelta (M2 m m0) (M1 a a0)) a1)
+++++
intros.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.

*****
a1 : ad
H0 : forall a1 : ad,\neq (MapGet (MapDelta (M1 a a0) m1) a1)\n (MapGet (MapDelta m1 (M1 a a0)) a1)
m1 : Map
H : forall a1 : ad,\neq (MapGet (MapDelta (M1 a a0) m0) a1)\n (MapGet (MapDelta m0 (M1 a a0)) a1)
m',m0 : Map
a0 : A
a : ad
m : Map
A : Type
*****
eq (MapGet (MapDelta (M1 a a0) (M2 m0 m1)) a1) (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (m' : Map) (a : ad), eq (MapGet (MapDelta m m') a) (MapGet (MapDelta m' m) a)) (m0 : Map) (_ : forall (m' : Map) (a : ad), eq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)) (m' : Map) (a : ad), eq (MapGet (MapDelta (M2 m m0) m') a) (MapGet (MapDelta m' (M2 m m0)) a)
+++++
simple induction m'.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
forall a : ad, eq (MapGet (MapDelta (M2 m0 m1) M0) a) (MapGet (MapDelta M0 (M2 m0 m1)) a)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad), eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) (MapGet (MapDelta (M1 a a0) (M2 m0 m1)) a1)
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
forall (m : Map) (_ : forall a : ad, eq (MapGet (MapDelta (M2 m0 m1) m) a) (MapGet (MapDelta m (M2 m0 m1)) a)) (m2 : Map) (_ : forall a : ad, eq (MapGet (MapDelta (M2 m0 m1) m2) a) (MapGet (MapDelta m2 (M2 m0 m1)) a)) (a : ad), eq (MapGet (MapDelta (M2 m0 m1) (M2 m m2)) a) (MapGet (MapDelta (M2 m m2) (M2 m0 m1)) a)
+++++
intros.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M2 m2 m3)) a) (MapGet (MapDelta (M2 m2 m3) (M2 m0 m1)) a)
+++++
simpl in |- *.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (MapGet (makeM2 (MapDelta m0 m2) (MapDelta m1 m3)) a) (MapGet (makeM2 (MapDelta m2 m0) (MapDelta m3 m1)) a)
+++++
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapDelta m0 m2) (MapDelta m1 m3)) a) (MapGet (makeM2 (MapDelta m2 m0) (MapDelta m3 m1)) a)
+++++
rewrite (makeM2_M2 (MapDelta m2 m0) (MapDelta m3 m1) a).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (makeM2_M2 (MapDelta m2 m0) (MapDelta m3 m1) a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapDelta m0 m2) (MapDelta m1 m3)) a) (MapGet (M2 (MapDelta m2 m0) (MapDelta m3 m1)) a)
+++++
rewrite (MapGet_M2_bit_0_if (MapDelta m0 m2) (MapDelta m1 m3) a).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (makeM2_M2 (MapDelta m2 m0) (MapDelta m3 m1) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m0 m2) (MapDelta m1 m3) a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (MapGet (M2 (MapDelta m2 m0) (MapDelta m3 m1)) a)
+++++
rewrite (MapGet_M2_bit_0_if (MapDelta m2 m0) (MapDelta m3 m1) a).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (makeM2_M2 (MapDelta m2 m0) (MapDelta m3 m1) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m2 m0) (MapDelta m3 m1) a).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (if N.odd a then MapGet (MapDelta m3 m1) (N.div2 a) else MapGet (MapDelta m2 m0) (N.div2 a))
+++++
rewrite (H0 m3 (Ndiv2 a)).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (makeM2_M2 (MapDelta m2 m0) (MapDelta m3 m1) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m2 m0) (MapDelta m3 m1) a).
rewrite (H0 m3 (Ndiv2 a)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m3 m1) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (if N.odd a then MapGet (MapDelta m3 m1) (N.div2 a) else MapGet (MapDelta m2 m0) (N.div2 a))
+++++
rewrite (H m2 (Ndiv2 a)).
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (makeM2_M2 (MapDelta m2 m0) (MapDelta m3 m1) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite (MapGet_M2_bit_0_if (MapDelta m2 m0) (MapDelta m3 m1) a).
rewrite (H0 m3 (Ndiv2 a)).
rewrite (H m2 (Ndiv2 a)).

*****
a : ad
H2 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m3) a)\n (MapGet (MapDelta m3 (M2 m0 m1)) a)
m3 : Map
H1 : forall a : ad,\neq (MapGet (MapDelta (M2 m0 m1) m2) a)\n (MapGet (MapDelta m2 (M2 m0 m1)) a)
m',m2 : Map
H0 : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m1 m') a) (MapGet (MapDelta m' m1) a)
m1 : Map
H : forall (m' : Map) (a : ad),\neq (MapGet (MapDelta m0 m') a) (MapGet (MapDelta m' m0) a)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m3 m1) (N.div2 a) else MapGet (MapDelta m2 m0) (N.div2 a)) (if N.odd a then MapGet (MapDelta m3 m1) (N.div2 a) else MapGet (MapDelta m2 m0) (N.div2 a))
+++++
reflexivity.
-----
Lemma MapDelta_semantics_comm : forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).
Proof.
unfold eqm in |- *.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_1_1 :\n   forall (a:ad) (y:A) (m':Map) (a0:ad),\n     MapGet (M1 a y) a0 = None ->\n     MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.

*****
A : Type
*****
forall (a : ad) (y : A) (m' : Map) (a0 : ad) (_ : eq (MapGet (M1 a y) a0) None) (_ : eq (MapGet m' a0) None), eq (MapGet (MapDelta (M1 a y) m') a0) None
+++++
Proof.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.

*****
A : Type
*****
forall (a : ad) (y : A) (m' : Map) (a0 : ad) (_ : eq (MapGet (M1 a y) a0) None) (_ : eq (MapGet m' a0) None), eq (MapGet (MapDelta (M1 a y) m') a0) None
+++++
intros.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet (MapDelta (M1 a y) m') a0) None
+++++
unfold MapDelta in |- *.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
intro H1.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
rewrite (Neqb_complete _ _ H1) in H.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a0 y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
rewrite (M1_semantics_1 a0 y) in H.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (M1_semantics_1 a0 y) in H.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (Some y) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
discriminate H.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
intro H1.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) None
+++++
case (MapGet m' a).
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : A, eq (MapGet (MapRemove m' a) a0) None
+++++
rewrite (MapRemove_semantics m' a a0).
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapRemove_semantics m' a a0).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : A, eq (if N.eqb a a0 then None else MapGet m' a0) None
+++++
rewrite H1.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapRemove_semantics m' a a0).
rewrite H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : A, eq (MapGet m' a0) None
+++++
trivial.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet (MapPut m' a y) a0) None
+++++
rewrite (MapPut_semantics m' a y a0).
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapPut_semantics m' a y a0).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (if N.eqb a a0 then Some y else MapGet m' a0) None
+++++
rewrite H1.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapPut_semantics m' a y a0).
rewrite H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) None
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet m' a0) None
+++++
assumption.
-----
Lemma MapDelta_semantics_1_1 : forall (a:ad) (y:A) (m':Map) (a0:ad), MapGet (M1 a y) a0 = None -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_1 :\n   forall (m m':Map) (a:ad),\n     MapGet m a = None ->\n     MapGet m' a = None -> MapGet (MapDelta m m') a = None.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (_ : eq (MapGet m a) None) (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m m') a) None
+++++
Proof.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (_ : eq (MapGet m a) None) (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m m') a) None
+++++
simple induction m.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m' : Map) (a : ad) (_ : eq (MapGet M0 a) None) (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta M0 m') a) None
+++++
trivial.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map) (a1 : ad) (_ : eq (MapGet (M1 a a0) a1) None) (_ : eq (MapGet m' a1) None), eq (MapGet (MapDelta (M1 a a0) m') a1) None
+++++
exact MapDelta_semantics_1_1.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (m' : Map) (a : ad) (_ : eq (MapGet m a) None) (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m m') a) None) (m0 : Map) (_ : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None) (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None) (m' : Map) (a : ad) (_ : eq (MapGet (M2 m m0) a) None) (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta (M2 m m0) m') a) None
+++++
simple induction m'.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet M0 a) None), eq (MapGet (MapDelta (M2 m0 m1) M0) a) None
+++++
trivial.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (MapGet (M2 m0 m1) a1) None) (_ : eq (MapGet (M1 a a0) a1) None), eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) None
+++++
intros.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : eq (MapGet (M1 a a0) a1) None
H1 : eq (MapGet (M2 m0 m1) a1) None
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) None
+++++
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).

*****
H2 : eq (MapGet (M1 a a0) a1) None
H1 : eq (MapGet (M2 m0 m1) a1) None
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M1 a a0) (M2 m0 m1)) a1) None
+++++
apply MapDelta_semantics_1_1.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
apply MapDelta_semantics_1_1.

*****
H2 : eq (MapGet (M1 a a0) a1) None
H1 : eq (MapGet (M2 m0 m1) a1) None
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M1 a a0) a1) None
+++++
trivial.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
apply MapDelta_semantics_1_1.

*****
H2 : eq (MapGet (M1 a a0) a1) None
H1 : eq (MapGet (M2 m0 m1) a1) None
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a1) None
+++++
trivial.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall (m : Map) (_ : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet m a) None), eq (MapGet (MapDelta (M2 m0 m1) m) a) None) (m2 : Map) (_ : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet m2 a) None), eq (MapGet (MapDelta (M2 m0 m1) m2) a) None) (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet (M2 m m2) a) None), eq (MapGet (MapDelta (M2 m0 m1) (M2 m m2)) a) None
+++++
intros.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M2 m2 m3)) a) None
+++++
simpl in |- *.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (makeM2 (MapDelta m0 m2) (MapDelta m1 m3)) a) None
+++++
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).

*****
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapDelta m0 m2) (MapDelta m1 m3)) a) None
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.

*****
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).

*****
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
intro H5.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
rewrite H5.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta m1 m3) (N.div2 a)) None
+++++
apply H0.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a)) None
+++++
rewrite (MapGet_M2_bit_0_1 a H5 m0 m1) in H3.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.
rewrite (MapGet_M2_bit_0_1 a H5 m0 m1) in H3.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet m1 (N.div2 a)) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a)) None
+++++
exact H3.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m3 (N.div2 a)) None
+++++
rewrite (MapGet_M2_bit_0_1 a H5 m2 m3) in H4.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.
rewrite (MapGet_M2_bit_0_1 a H5 m2 m3) in H4.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet m3 (N.div2 a)) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m3 (N.div2 a)) None
+++++
exact H4.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).

*****
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
intro H5.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
rewrite H5.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
apply H.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a)) None
+++++
rewrite (MapGet_M2_bit_0_0 a H5 m0 m1) in H3.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.
rewrite (MapGet_M2_bit_0_0 a H5 m0 m1) in H3.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet m0 (N.div2 a)) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a)) None
+++++
exact H3.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m2 (N.div2 a)) None
+++++
rewrite (MapGet_M2_bit_0_0 a H5 m2 m3) in H4.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.
rewrite (MapGet_M2_bit_0_0 a H5 m2 m3) in H4.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet m2 (N.div2 a)) None
H3 : eq (MapGet (M2 m0 m1) a) None
a : ad
H2 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) None),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) None), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m2 (N.div2 a)) None
+++++
exact H4.
-----
Lemma MapDelta_semantics_1 : forall (m m':Map) (a:ad), MapGet m a = None -> MapGet m' a = None -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_2_1 :\n   forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A),\n     MapGet (M1 a y) a0 = None ->\n     MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.

*****
A : Type
*****
forall (a : ad) (y : A) (m' : Map) (a0 : ad) (y0 : A) (_ : eq (MapGet (M1 a y) a0) None) (_ : eq (MapGet m' a0) (Some y0)), eq (MapGet (MapDelta (M1 a y) m') a0) (Some y0)
+++++
Proof.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.

*****
A : Type
*****
forall (a : ad) (y : A) (m' : Map) (a0 : ad) (y0 : A) (_ : eq (MapGet (M1 a y) a0) None) (_ : eq (MapGet m' a0) (Some y0)), eq (MapGet (MapDelta (M1 a y) m') a0) (Some y0)
+++++
intros.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.

*****
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet (MapDelta (M1 a y) m') a0) (Some y0)
+++++
unfold MapDelta in |- *.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.

*****
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
intro H1.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
rewrite (Neqb_complete _ _ H1) in H.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a0 y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
rewrite (M1_semantics_1 a0 y) in H.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (M1_semantics_1 a0 y) in H.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) (Some y0)
H : eq (Some y) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
discriminate H.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
intro H1.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
case (MapGet m' a).
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : A, eq (MapGet (MapRemove m' a) a0) (Some y0)
+++++
rewrite (MapRemove_semantics m' a a0).
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapRemove_semantics m' a a0).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : A, eq (if N.eqb a a0 then None else MapGet m' a0) (Some y0)
+++++
rewrite H1.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapRemove_semantics m' a a0).
rewrite H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : A, eq (MapGet m' a0) (Some y0)
+++++
trivial.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet (MapPut m' a y) a0) (Some y0)
+++++
rewrite (MapPut_semantics m' a y a0).
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapPut_semantics m' a y a0).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (if N.eqb a a0 then Some y else MapGet m' a0) (Some y0)
+++++
rewrite H1.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
case (MapGet m' a).
rewrite (MapPut_semantics m' a y a0).
rewrite H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) (Some y0)
H : eq (MapGet (M1 a y) a0) None
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet m' a0) (Some y0)
+++++
assumption.
-----
Lemma MapDelta_semantics_2_1 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = None -> MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_2_2 :\n   forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A),\n     MapGet (M1 a y) a0 = Some y0 ->\n     MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.

*****
A : Type
*****
forall (a : ad) (y : A) (m' : Map) (a0 : ad) (y0 : A) (_ : eq (MapGet (M1 a y) a0) (Some y0)) (_ : eq (MapGet m' a0) None), eq (MapGet (MapDelta (M1 a y) m') a0) (Some y0)
+++++
Proof.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.

*****
A : Type
*****
forall (a : ad) (y : A) (m' : Map) (a0 : ad) (y0 : A) (_ : eq (MapGet (M1 a y) a0) (Some y0)) (_ : eq (MapGet m' a0) None), eq (MapGet (MapDelta (M1 a y) m') a0) (Some y0)
+++++
intros.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet (MapDelta (M1 a y) m') a0) (Some y0)
+++++
unfold MapDelta in |- *.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
intro H1.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
rewrite (Neqb_complete _ _ H1) in H.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a0 y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a0 y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y end a0) (Some y0)
+++++
rewrite H0.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Neqb_complete _ _ H1).
rewrite H0.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a0 y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet (MapPut m' a0 y) a0) (Some y0)
+++++
rewrite (MapPut_semantics m' a0 y a0).
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Neqb_complete _ _ H1).
rewrite H0.
rewrite (MapPut_semantics m' a0 y a0).

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a0 y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (if N.eqb a0 a0 then Some y else MapGet m' a0) (Some y0)
+++++
rewrite (Neqb_correct a0).
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Neqb_complete _ _ H1).
rewrite H0.
rewrite (MapPut_semantics m' a0 y a0).
rewrite (Neqb_correct a0).

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a0 y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (Some y) (Some y0)
+++++
rewrite (M1_semantics_1 a0 y) in H.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Neqb_complete _ _ H1).
rewrite H0.
rewrite (MapPut_semantics m' a0 y a0).
rewrite (Neqb_correct a0).
rewrite (M1_semantics_1 a0 y) in H.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (Some y) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (Some y) (Some y0)
+++++
simple inversion H.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Neqb_complete _ _ H1).
rewrite H0.
rewrite (MapPut_semantics m' a0 y a0).
rewrite (Neqb_correct a0).
rewrite (M1_semantics_1 a0 y) in H.
simple inversion H.

*****
H2 : eq (Some y) (Some y0)
H1 : eq (N.eqb a a0) true
H0 : eq (MapGet m' a0) None
H : eq (Some y) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (Some y) (Some y0)
+++++
assumption.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
intro H1.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq (MapGet (M1 a y) a0) (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
rewrite (M1_semantics_2 a a0 y H1) in H.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite (M1_semantics_2 a a0 y H1) in H.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (MapGet m' a0) None
H : eq None (Some y0)
y0 : A
a0 : ad
m' : Map
y : A
a : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y end a0) (Some y0)
+++++
discriminate H.
-----
Lemma MapDelta_semantics_2_2 : forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A), MapGet (M1 a y) a0 = Some y0 -> MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_2 :\n   forall (m m':Map) (a:ad) (y:A),\n     MapGet m a = None ->\n     MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y : A) (_ : eq (MapGet m a) None) (_ : eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta m m') a) (Some y)
+++++
Proof.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y : A) (_ : eq (MapGet m a) None) (_ : eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta m m') a) (Some y)
+++++
simple induction m.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet M0 a) None) (_ : eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta M0 m') a) (Some y)
+++++
trivial.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map) (a1 : ad) (y : A) (_ : eq (MapGet (M1 a a0) a1) None) (_ : eq (MapGet m' a1) (Some y)), eq (MapGet (MapDelta (M1 a a0) m') a1) (Some y)
+++++
exact MapDelta_semantics_2_1.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m a) None) (_ : eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta m m') a) (Some y)) (m0 : Map) (_ : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None) (_ : eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta m0 m') a) (Some y)) (m' : Map) (a : ad) (y : A) (_ : eq (MapGet (M2 m m0) a) None) (_ : eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta (M2 m m0) m') a) (Some y)
+++++
simple induction m'.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet M0 a) (Some y)), eq (MapGet (MapDelta (M2 m0 m1) M0) a) (Some y)
+++++
intros.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : eq (MapGet M0 a) (Some y)
H1 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) M0) a) (Some y)
+++++
discriminate H2.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a1) None) (_ : eq (MapGet (M1 a a0) a1) (Some y)), eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) (Some y)
+++++
intros.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : eq (MapGet (M1 a a0) a1) (Some y)
H1 : eq (MapGet (M2 m0 m1) a1) None
y : A
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) (Some y)
+++++
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).

*****
H2 : eq (MapGet (M1 a a0) a1) (Some y)
H1 : eq (MapGet (M2 m0 m1) a1) None
y : A
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M1 a a0) (M2 m0 m1)) a1) (Some y)
+++++
apply MapDelta_semantics_2_2.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
apply MapDelta_semantics_2_2.

*****
H2 : eq (MapGet (M1 a a0) a1) (Some y)
H1 : eq (MapGet (M2 m0 m1) a1) None
y : A
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M1 a a0) a1) (Some y)
+++++
assumption.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
apply MapDelta_semantics_2_2.

*****
H2 : eq (MapGet (M1 a a0) a1) (Some y)
H1 : eq (MapGet (M2 m0 m1) a1) None
y : A
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a1) None
+++++
assumption.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
forall (m : Map) (_ : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet m a) (Some y)), eq (MapGet (MapDelta (M2 m0 m1) m) a) (Some y)) (m2 : Map) (_ : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet m2 a) (Some y)), eq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)) (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None) (_ : eq (MapGet (M2 m m2) a) (Some y)), eq (MapGet (MapDelta (M2 m0 m1) (M2 m m2)) a) (Some y)
+++++
intros.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M2 m2 m3)) a) (Some y)
+++++
simpl in |- *.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (makeM2 (MapDelta m0 m2) (MapDelta m1 m3)) a) (Some y)
+++++
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapDelta m0 m2) (MapDelta m1 m3)) a) (Some y)
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (Some y)
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (Some y)
+++++
intro H5.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (Some y)
+++++
rewrite H5.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta m1 m3) (N.div2 a)) (Some y)
+++++
apply H0.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a)) None
+++++
rewrite <- (MapGet_M2_bit_0_1 a H5 m0 m1).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.
rewrite <- (MapGet_M2_bit_0_1 a H5 m0 m1).

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a) None
+++++
assumption.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet m3 (N.div2 a)) (Some y)
+++++
rewrite <- (MapGet_M2_bit_0_1 a H5 m2 m3).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H0.
rewrite <- (MapGet_M2_bit_0_1 a H5 m2 m3).

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m2 m3) a) (Some y)
+++++
assumption.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (Some y)
+++++
intro H5.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) (Some y)
+++++
rewrite H5.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta m0 m2) (N.div2 a)) (Some y)
+++++
apply H.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a)) None
+++++
rewrite <- (MapGet_M2_bit_0_0 a H5 m0 m1).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.
rewrite <- (MapGet_M2_bit_0_0 a H5 m0 m1).

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a) None
+++++
assumption.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet m2 (N.div2 a)) (Some y)
+++++
rewrite <- (MapGet_M2_bit_0_0 a H5 m2 m3).
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply H.
rewrite <- (MapGet_M2_bit_0_0 a H5 m2 m3).

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y)
H3 : eq (MapGet (M2 m0 m1) a) None
y : A
a : ad
H2 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m3 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) (Some y)
m3 : Map
H1 : forall (a : ad) (y : A) (_ : eq (MapGet (M2 m0 m1) a) None)\n (_ : eq (MapGet m2 a) (Some y)),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) (Some y)
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m1 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m1 m') a) (Some y)
m1 : Map
H : forall (m' : Map) (a : ad) (y : A) (_ : eq (MapGet m0 a) None)\n (_ : eq (MapGet m' a) (Some y)),\neq (MapGet (MapDelta m0 m') a) (Some y)
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m2 m3) a) (Some y)
+++++
assumption.
-----
Lemma MapDelta_semantics_2 : forall (m m':Map) (a:ad) (y:A), MapGet m a = None -> MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_3_1 :\n   forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A),\n     MapGet (M1 a0 y0) a = Some y ->\n     MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.

*****
A : Type
*****
forall (a0 : ad) (y0 : A) (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet (M1 a0 y0) a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta (M1 a0 y0) m') a) None
+++++
Proof.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.

*****
A : Type
*****
forall (a0 : ad) (y0 : A) (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet (M1 a0 y0) a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta (M1 a0 y0) m') a) None
+++++
intros.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.

*****
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet (MapDelta (M1 a0 y0) m') a) None
+++++
unfold MapDelta in |- *.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.

*****
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y0 end a) None
+++++
elim (sumbool_of_bool (Neqb a0 a)).
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).

*****
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
forall _ : eq (N.eqb a0 a) true, eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y0 end a) None
+++++
intro H1.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y0 end a) None
+++++
rewrite (Neqb_complete a0 a H1).
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.
rewrite (Neqb_complete a0 a H1).

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet match MapGet m' a with | Some _ => MapRemove m' a | None => MapPut m' a y0 end a) None
+++++
rewrite H0.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.
rewrite (Neqb_complete a0 a H1).
rewrite H0.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet (MapRemove m' a) a) None
+++++
rewrite (MapRemove_semantics m' a a).
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.
rewrite (Neqb_complete a0 a H1).
rewrite H0.
rewrite (MapRemove_semantics m' a a).

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (if N.eqb a a then None else MapGet m' a) None
+++++
rewrite (Neqb_correct a).
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.
rewrite (Neqb_complete a0 a H1).
rewrite H0.
rewrite (MapRemove_semantics m' a a).
rewrite (Neqb_correct a).

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).

*****
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
forall _ : eq (N.eqb a0 a) false, eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y0 end a) None
+++++
intro H1.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.

*****
H1 : eq (N.eqb a0 a) false
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet (M1 a0 y0) a) (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y0 end a) None
+++++
rewrite (M1_semantics_2 a0 a y0 H1) in H.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H1.
rewrite (M1_semantics_2 a0 a y0 H1) in H.

*****
H1 : eq (N.eqb a0 a) false
H0 : eq (MapGet m' a) (Some y')
H : eq None (Some y)
y,y' : A
a : ad
m' : Map
y0 : A
a0 : ad
A : Type
*****
eq (MapGet match MapGet m' a0 with | Some _ => MapRemove m' a0 | None => MapPut m' a0 y0 end a) None
+++++
discriminate H.
-----
Lemma MapDelta_semantics_3_1 : forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A), MapGet (M1 a0 y0) a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.
Proof.
intros.
unfold MapDelta in |- *.
elim (sumbool_of_bool (Neqb a0 a)).

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics_3 :\n   forall (m m':Map) (a:ad) (y y':A),\n     MapGet m a = Some y ->\n     MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m m') a) None
+++++
Proof.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.

*****
A : Type
*****
forall (m m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m m') a) None
+++++
simple induction m.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet M0 a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta M0 m') a) None
+++++
intros.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
intros.

*****
H0 : eq (MapGet m' a) (Some y')
H : eq (MapGet M0 a) (Some y)
y,y' : A
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta M0 m') a) None
+++++
discriminate H.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (m' : Map) (a1 : ad) (y y' : A) (_ : eq (MapGet (M1 a a0) a1) (Some y)) (_ : eq (MapGet m' a1) (Some y')), eq (MapGet (MapDelta (M1 a a0) m') a1) None
+++++
exact MapDelta_semantics_3_1.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m m') a) None) (m0 : Map) (_ : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None) (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet (M2 m m0) a) (Some y)) (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta (M2 m m0) m') a) None
+++++
simple induction m'.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y)) (_ : eq (MapGet M0 a) (Some y')), eq (MapGet (MapDelta (M2 m0 m1) M0) a) None
+++++
intros.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : eq (MapGet M0 a) (Some y')
H1 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) M0) a) None
+++++
discriminate H2.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a1) (Some y)) (_ : eq (MapGet (M1 a a0) a1) (Some y')), eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) None
+++++
intros.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : eq (MapGet (M1 a a0) a1) (Some y')
H1 : eq (MapGet (M2 m0 m1) a1) (Some y)
y,y' : A
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M1 a a0)) a1) None
+++++
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
rewrite (MapDelta_semantics_comm (M2 m0 m1) (M1 a a0) a1).

*****
H2 : eq (MapGet (M1 a a0) a1) (Some y')
H1 : eq (MapGet (M2 m0 m1) a1) (Some y)
y,y' : A
a1 : ad
a0 : A
a : ad
m' : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M1 a a0) (M2 m0 m1)) a1) None
+++++
exact (MapDelta_semantics_3_1 a a0 (M2 m0 m1) a1 y' y H2 H1).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall (m : Map) (_ : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y)) (_ : eq (MapGet m a) (Some y')), eq (MapGet (MapDelta (M2 m0 m1) m) a) None) (m2 : Map) (_ : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y)) (_ : eq (MapGet m2 a) (Some y')), eq (MapGet (MapDelta (M2 m0 m1) m2) a) None) (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y)) (_ : eq (MapGet (M2 m m2) a) (Some y')), eq (MapGet (MapDelta (M2 m0 m1) (M2 m m2)) a) None
+++++
intros.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta (M2 m0 m1) (M2 m2 m3)) a) None
+++++
simpl in |- *.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (makeM2 (MapDelta m0 m2) (MapDelta m1 m3)) a) None
+++++
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 (MapDelta m0 m2) (MapDelta m1 m3)) a) None
+++++
rewrite MapGet_M2_bit_0_if.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) true, eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
intro H5.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
rewrite H5.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta m1 m3) (N.div2 a)) None
+++++
apply (H0 m3 (Ndiv2 a) y y').
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H0 m3 (Ndiv2 a) y y').

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m1 (N.div2 a)) (Some y)
+++++
rewrite <- (MapGet_M2_bit_0_1 a H5 m0 m1).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H0 m3 (Ndiv2 a) y y').
rewrite <- (MapGet_M2_bit_0_1 a H5 m0 m1).

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a) (Some y)
+++++
assumption.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H0 m3 (Ndiv2 a) y y').

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m3 (N.div2 a)) (Some y')
+++++
rewrite <- (MapGet_M2_bit_0_1 a H5 m2 m3).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H0 m3 (Ndiv2 a) y y').
rewrite <- (MapGet_M2_bit_0_1 a H5 m2 m3).

*****
H5 : eq (N.odd a) true
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m2 m3) a) (Some y')
+++++
assumption.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).

*****
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
forall _ : eq (N.odd a) false, eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
intro H5.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (if N.odd a then MapGet (MapDelta m1 m3) (N.div2 a) else MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
rewrite H5.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (MapDelta m0 m2) (N.div2 a)) None
+++++
apply (H m2 (Ndiv2 a) y y').
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H m2 (Ndiv2 a) y y').

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m0 (N.div2 a)) (Some y)
+++++
rewrite <- (MapGet_M2_bit_0_0 a H5 m0 m1).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H m2 (Ndiv2 a) y y').
rewrite <- (MapGet_M2_bit_0_0 a H5 m0 m1).

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m0 m1) a) (Some y)
+++++
assumption.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H m2 (Ndiv2 a) y y').

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet m2 (N.div2 a)) (Some y')
+++++
rewrite <- (MapGet_M2_bit_0_0 a H5 m2 m3).
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (makeM2_M2 (MapDelta m0 m2) (MapDelta m1 m3) a).
rewrite MapGet_M2_bit_0_if.
elim (sumbool_of_bool (Nbit0 a)).
intro H5.
rewrite H5.
apply (H m2 (Ndiv2 a) y y').
rewrite <- (MapGet_M2_bit_0_0 a H5 m2 m3).

*****
H5 : eq (N.odd a) false
H4 : eq (MapGet (M2 m2 m3) a) (Some y')
H3 : eq (MapGet (M2 m0 m1) a) (Some y)
y,y' : A
a : ad
H2 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m3 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m3) a) None
m3 : Map
H1 : forall (a : ad) (y y' : A) (_ : eq (MapGet (M2 m0 m1) a) (Some y))\n (_ : eq (MapGet m2 a) (Some y')),\neq (MapGet (MapDelta (M2 m0 m1) m2) a) None
m',m2 : Map
H0 : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m1 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m1 m') a) None
m1 : Map
H : forall (m' : Map) (a : ad) (y y' : A) (_ : eq (MapGet m0 a) (Some y))\n (_ : eq (MapGet m' a) (Some y')), eq (MapGet (MapDelta m0 m') a) None
m,m0 : Map
A : Type
*****
eq (MapGet (M2 m2 m3) a) (Some y')
+++++
assumption.
-----
Lemma MapDelta_semantics_3 : forall (m m':Map) (a:ad) (y y':A), MapGet m a = Some y -> MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_semantics :\n   forall m m':Map,\n     eqm (MapGet (MapDelta m m'))\n       (fun a0:ad =>\n          match MapGet m a0, MapGet m' a0 with\n          | None, Some y' => Some y'\n          | Some y, None => Some y\n          | _, _ => None\n          end).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (MapDelta m m')) (fun a0 : ad => match MapGet m a0 with | Some y => match MapGet m' a0 with | Some _ => None | None => Some y end | None => match MapGet m' a0 with | Some y' => Some y' | None => None end end)
+++++
Proof.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.

*****
A : Type
*****
forall m m' : Map, eqm (MapGet (MapDelta m m')) (fun a0 : ad => match MapGet m a0 with | Some y => match MapGet m' a0 with | Some _ => None | None => Some y end | None => match MapGet m' a0 with | Some y' => Some y' | None => None end end)
+++++
unfold eqm in |- *.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (m m' : Map) (a : ad), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
intros.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
elim (option_sum (MapGet m' a)).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).

*****
a : ad
m,m' : Map
A : Type
*****
forall _ : sig (fun y : A => eq (MapGet m' a) (Some y)), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
intro H.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.

*****
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
elim H.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.

*****
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
forall (x : A) (_ : eq (MapGet m' a) (Some x)), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
intros a0 H0.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.

*****
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
rewrite H0.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.

*****
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
elim (option_sum (MapGet m a)).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).

*****
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
forall _ : sig (fun y : A => eq (MapGet m a) (Some y)), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
intro H1.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).
intro H1.

*****
H1 : sig (fun y : A => eq (MapGet m a) (Some y))
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
elim H1.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : A => eq (MapGet m a) (Some y))
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
forall (x : A) (_ : eq (MapGet m a) (Some x)), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
intros a1 H2.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).
intro H1.
elim H1.
intros a1 H2.

*****
H2 : eq (MapGet m a) (Some a1)
a1 : A
H1 : sig (fun y : A => eq (MapGet m a) (Some y))
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
rewrite H2.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).
intro H1.
elim H1.
intros a1 H2.
rewrite H2.

*****
H2 : eq (MapGet m a) (Some a1)
a1 : A
H1 : sig (fun y : A => eq (MapGet m a) (Some y))
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) None
+++++
exact (MapDelta_semantics_3 m m' a a1 a0 H2 H0).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).

*****
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (MapGet m a) None, eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
intro H1.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).
intro H1.

*****
H1 : eq (MapGet m a) None
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some _ => None | None => Some a0 end
+++++
rewrite H1.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
elim H.
intros a0 H0.
rewrite H0.
elim (option_sum (MapGet m a)).
intro H1.
rewrite H1.

*****
H1 : eq (MapGet m a) None
H0 : eq (MapGet m' a) (Some a0)
a0 : A
H : sig (fun y : A => eq (MapGet m' a) (Some y))
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) (Some a0)
+++++
exact (MapDelta_semantics_2 m m' a a0 H1 H0).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).

*****
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (MapGet m' a) None, eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
intro H.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.

*****
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => match MapGet m' a with | Some _ => None | None => Some y end | None => match MapGet m' a with | Some y' => Some y' | None => None end end
+++++
rewrite H.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
elim (option_sum (MapGet m a)).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).

*****
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
forall _ : sig (fun y : A => eq (MapGet m a) (Some y)), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
intro H0.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.

*****
H0 : sig (fun y : A => eq (MapGet m a) (Some y))
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
elim H0.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.
elim H0.

*****
H0 : sig (fun y : A => eq (MapGet m a) (Some y))
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
forall (x : A) (_ : eq (MapGet m a) (Some x)), eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
intros a0 H1.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.
elim H0.
intros a0 H1.

*****
H1 : eq (MapGet m a) (Some a0)
a0 : A
H0 : sig (fun y : A => eq (MapGet m a) (Some y))
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
rewrite H1.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.
elim H0.
intros a0 H1.
rewrite H1.

*****
H1 : eq (MapGet m a) (Some a0)
a0 : A
H0 : sig (fun y : A => eq (MapGet m a) (Some y))
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) (Some a0)
+++++
rewrite (MapDelta_semantics_comm m m' a).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.
elim H0.
intros a0 H1.
rewrite H1.
rewrite (MapDelta_semantics_comm m m' a).

*****
H1 : eq (MapGet m a) (Some a0)
a0 : A
H0 : sig (fun y : A => eq (MapGet m a) (Some y))
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m' m) a) (Some a0)
+++++
exact (MapDelta_semantics_2 m' m a a0 H H1).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).

*****
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
forall _ : eq (MapGet m a) None, eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
intro H0.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.

*****
H0 : eq (MapGet m a) None
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) match MapGet m a with | Some y => Some y | None => None end
+++++
rewrite H0.
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).
intro H.
rewrite H.
elim (option_sum (MapGet m a)).
intro H0.
rewrite H0.

*****
H0 : eq (MapGet m a) None
H : eq (MapGet m' a) None
a : ad
m,m' : Map
A : Type
*****
eq (MapGet (MapDelta m m') a) None
+++++
exact (MapDelta_semantics_1 m m' a H0 H).
-----
Lemma MapDelta_semantics : forall m m':Map, eqm (MapGet (MapDelta m m')) (fun a0:ad => match MapGet m a0, MapGet m' a0 with | None, Some y' => Some y' | Some y, None => Some y | _, _ => None end).
Proof.
unfold eqm in |- *.
intros.
elim (option_sum (MapGet m' a)).

*****

*****

+++++
Qed.
-----
Definition MapEmptyp (m:Map) := match m with\n                                  | M0 => true\n                                  | _ => false\n                                  end.
-----
Lemma MapEmptyp_correct : MapEmptyp M0 = true.
-----
Lemma MapEmptyp_correct : MapEmptyp M0 = true.

*****
A : Type
*****
eq (MapEmptyp M0) true
+++++
Proof.
-----
Lemma MapEmptyp_correct : MapEmptyp M0 = true.
Proof.

*****
A : Type
*****
eq (MapEmptyp M0) true
+++++
reflexivity.
-----
Lemma MapEmptyp_correct : MapEmptyp M0 = true.
Proof.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.

*****
A : Type
*****
forall (m : Map) (_ : eq (MapEmptyp m) true), eq m M0
+++++
Proof.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.

*****
A : Type
*****
forall (m : Map) (_ : eq (MapEmptyp m) true), eq m M0
+++++
simple induction m.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall _ : eq (MapEmptyp M0) true, eq M0 M0
+++++
trivial.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (_ : eq (MapEmptyp (M1 a a0)) true), eq (M1 a a0) M0
+++++
trivial.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.
trivial.

*****
m : Map
A : Type
*****
forall (a : ad) (a0 : A) (_ : eq (MapEmptyp (M1 a a0)) true), eq (M1 a a0) M0
+++++
intros.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.
trivial.
intros.

*****
H : eq (MapEmptyp (M1 a a0)) true
a0 : A
a : ad
m : Map
A : Type
*****
eq (M1 a a0) M0
+++++
discriminate H.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall _ : eq (MapEmptyp m) true, eq m M0) (m0 : Map) (_ : forall _ : eq (MapEmptyp m0) true, eq m0 M0) (_ : eq (MapEmptyp (M2 m m0)) true), eq (M2 m m0) M0
+++++
trivial.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.
trivial.

*****
m : Map
A : Type
*****
forall (m : Map) (_ : forall _ : eq (MapEmptyp m) true, eq m M0) (m0 : Map) (_ : forall _ : eq (MapEmptyp m0) true, eq m0 M0) (_ : eq (MapEmptyp (M2 m m0)) true), eq (M2 m m0) M0
+++++
intros.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.
trivial.
intros.

*****
H1 : eq (MapEmptyp (M2 m0 m1)) true
H0 : forall _ : eq (MapEmptyp m1) true, eq m1 M0
m1 : Map
H : forall _ : eq (MapEmptyp m0) true, eq m0 M0
m,m0 : Map
A : Type
*****
eq (M2 m0 m1) M0
+++++
discriminate H1.
-----
Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
End MapDefs.
-----
