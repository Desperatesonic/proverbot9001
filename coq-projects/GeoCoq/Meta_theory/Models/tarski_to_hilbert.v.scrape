Require Import GeoCoq.Tarski_dev.Ch12_parallel_inter_dec.
-----
Require Import Morphisms.
-----
Require Import GeoCoq.Axioms.hilbert_axioms.
-----
Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Meta_theory.Parallel_postulates.tarski_playfair.
-----
Require Import GeoCoq.Meta_theory.Parallel_postulates.SPP_ID.
-----
Require Import GeoCoq.Meta_theory.Dimension_axioms.upper_dim_3.
-----
Require Import GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates.
-----
Require Export GeoCoq.Utils.triples.
-----
Section T.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Definition Line := @Couple Tpoint.
-----
Definition Lin := build_couple Tpoint.
-----
Definition IncidentL := fun A l => Col A (P1 l) (P2 l).
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\ IncidentL B l.
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\\ IncidentL B l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (eq A B)), ex (fun l : Couple => and (IncidentL A l) (IncidentL B l))
+++++
Proof.
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\\ IncidentL B l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (eq A B)), ex (fun l : Couple => and (IncidentL A l) (IncidentL B l))
+++++
intros.
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\\ IncidentL B l.
Proof.
intros.

*****
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (IncidentL B l))
+++++
exists (Lin A B H).
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\\ IncidentL B l.
Proof.
intros.
exists (Lin A B H).

*****
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL A (Lin A B H)) (IncidentL B (Lin A B H))
+++++
unfold IncidentL.
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\\ IncidentL B l.
Proof.
intros.
exists (Lin A B H).
unfold IncidentL.

*****
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A (P1 (Lin A B H)) (P2 (Lin A B H))) (Col B (P1 (Lin A B H)) (P2 (Lin A B H)))
+++++
intuition.
-----
Lemma axiom_line_existence : forall A B, A<>B -> exists l, IncidentL A l /\\ IncidentL B l.
Proof.
intros.
exists (Lin A B H).
unfold IncidentL.
intuition.

*****

*****

+++++
Qed.
-----
Definition EqL : relation Line := fun l m => forall X, IncidentL X l <-> IncidentL X m.
-----
Infix "=l=" := EqL (at level 70):type_scope.
-----
Lemma incident_eq : forall A B l, forall H : A<>B,\n IncidentL A l -> IncidentL B l ->\n (Lin A B H) =l= l.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (H : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l), EqL (Lin A B H) l
+++++
Proof.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (H : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l), EqL (Lin A B H) l
+++++
intros.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.

*****
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL (Lin A B H) l
+++++
unfold EqL.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.

*****
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall X : Tpoint, iff (IncidentL X (Lin A B H)) (IncidentL X l)
+++++
intros.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.

*****
X : Tpoint
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentL X (Lin A B H)) (IncidentL X l)
+++++
unfold IncidentL in *.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X (P1 (Lin A B H)) (P2 (Lin A B H))) (Col X (P1 l) (P2 l))
+++++
replace (P1 (Lin A B H)) with A.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X A (P2 (Lin A B H))) (Col X (P1 l) (P2 l))
+++++
trivial.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X A (P2 (Lin A B H))) (Col X (P1 l) (P2 l))
+++++
replace (P2 (Lin A B H)) with B.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X A B) (Col X (P1 l) (P2 l))
+++++
trivial.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X A B) (Col X (P1 l) (P2 l))
+++++
split.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col X A B, Col X (P1 l) (P2 l)
+++++
intro.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.

*****
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
assert (T:=Cond l).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).

*****
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
elim (eq_dec_points X B).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).

*****
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq X B, Col X (P1 l) (P2 l)
+++++
intro.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.

*****
H3 : eq X B
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
subst X.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
subst X.

*****
T : not (eq (P1 l) (P2 l))
H2 : Col B A B
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B (P1 l) (P2 l)
+++++
auto.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).

*****
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq X B), Col X (P1 l) (P2 l)
+++++
intro.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.

*****
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
assert (Col (P1 l) A B).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).

*****
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) A B
+++++
apply col_transitivity_1 with (P2 l).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
apply col_transitivity_1 with (P2 l).

*****
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq (P1 l) (P2 l))
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
apply col_transitivity_1 with (P2 l).

*****
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) A
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
apply col_transitivity_1 with (P2 l).

*****
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) B
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).

*****
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
assert (Col (P2 l) A B).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).

*****
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P2 l) A B
+++++
apply (col_transitivity_2 (P1 l)).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col_transitivity_2 (P1 l)).

*****
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq (P1 l) (P2 l))
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col_transitivity_2 (P1 l)).

*****
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) A
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col_transitivity_2 (P1 l)).

*****
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) B
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).

*****
H5 : Col (P2 l) A B
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
apply (col3 A B).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col3 A B).

*****
H5 : Col (P2 l) A B
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col3 A B).

*****
H5 : Col (P2 l) A B
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B X
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col3 A B).

*****
H5 : Col (P2 l) A B
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B (P1 l)
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (T:=Cond l).
elim (eq_dec_points X B).
intro.
assert (Col (P1 l) A B).
assert (Col (P2 l) A B).
apply (col3 A B).

*****
H5 : Col (P2 l) A B
H4 : Col (P1 l) A B
H3 : not (eq X B)
T : not (eq (P1 l) (P2 l))
H2 : Col X A B
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B (P2 l)
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col X (P1 l) (P2 l), Col X A B
+++++
intro.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.

*****
H2 : Col X (P1 l) (P2 l)
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X A B
+++++
assert (U:=Cond l).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (U:=Cond l).

*****
U : not (eq (P1 l) (P2 l))
H2 : Col X (P1 l) (P2 l)
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X A B
+++++
apply (col3 (P1 l) (P2 l)).
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (U:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
U : not (eq (P1 l) (P2 l))
H2 : Col X (P1 l) (P2 l)
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq (P1 l) (P2 l))
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (U:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
U : not (eq (P1 l) (P2 l))
H2 : Col X (P1 l) (P2 l)
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) X
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (U:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
U : not (eq (P1 l) (P2 l))
H2 : Col X (P1 l) (P2 l)
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) A
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.
trivial.
split.
intro.
assert (U:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
U : not (eq (P1 l) (P2 l))
H2 : Col X (P1 l) (P2 l)
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) B
+++++
Col.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.
trivial.
replace (P2 (Lin A B H)) with B.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B (P2 (Lin A B H))
+++++
trivial.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.

*****
X : Tpoint
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A (P1 (Lin A B H))
+++++
trivial.
-----
Lemma incident_eq : forall A B l, forall H : A<>B, IncidentL A l -> IncidentL B l -> (Lin A B H) =l= l.
Proof.
intros.
unfold EqL.
intros.
unfold IncidentL in *.
replace (P1 (Lin A B H)) with A.

*****

*****

+++++
Qed.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m n : Line) (_ : EqL l m) (_ : EqL m n), EqL l n
+++++
Proof.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m n : Line) (_ : EqL l m) (_ : EqL m n), EqL l n
+++++
unfold EqL.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m n : Line) (_ : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)) (_ : forall X : Tpoint, iff (IncidentL X m) (IncidentL X n)) (X : Tpoint), iff (IncidentL X l) (IncidentL X n)
+++++
unfold IncidentL.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m n : Line) (_ : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))) (_ : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))) (X : Tpoint), iff (Col X (P1 l) (P2 l)) (Col X (P1 n) (P2 n))
+++++
intros.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.

*****
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X (P1 l) (P2 l)) (Col X (P1 n) (P2 n))
+++++
assert (T:=H X).
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).

*****
T : iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X (P1 l) (P2 l)) (Col X (P1 n) (P2 n))
+++++
assert (V:= H0 X).
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).
assert (V:= H0 X).

*****
V : iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
T : iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col X (P1 l) (P2 l)) (Col X (P1 n) (P2 n))
+++++
split.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).
assert (V:= H0 X).
split.

*****
V : iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
T : iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col X (P1 l) (P2 l), Col X (P1 n) (P2 n)
+++++
intro.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).
assert (V:= H0 X).
split.
intro.

*****
H1 : Col X (P1 l) (P2 l)
V : iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
T : iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 n) (P2 n)
+++++
intuition.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).
assert (V:= H0 X).
split.

*****
V : iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
T : iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col X (P1 n) (P2 n), Col X (P1 l) (P2 l)
+++++
intro.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).
assert (V:= H0 X).
split.
intro.

*****
H1 : Col X (P1 n) (P2 n)
V : iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
T : iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
X : Tpoint
H0 : forall X : Tpoint, iff (Col X (P1 m) (P2 m)) (Col X (P1 n) (P2 n))
H : forall X : Tpoint, iff (Col X (P1 l) (P2 l)) (Col X (P1 m) (P2 m))
l,m,n : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col X (P1 l) (P2 l)
+++++
intuition.
-----
Lemma eq_transitivity : forall l m n, l =l= m -> m =l= n -> l =l= n.
Proof.
unfold EqL.
unfold IncidentL.
intros.
assert (T:=H X).
assert (V:= H0 X).
split.

*****

*****

+++++
Qed.
-----
Lemma eq_reflexivity : forall l, l =l= l.
-----
Lemma eq_reflexivity : forall l, l =l= l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall l : Line, EqL l l
+++++
Proof.
-----
Lemma eq_reflexivity : forall l, l =l= l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall l : Line, EqL l l
+++++
intros.
-----
Lemma eq_reflexivity : forall l, l =l= l.
Proof.
intros.

*****
l : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL l l
+++++
unfold EqL.
-----
Lemma eq_reflexivity : forall l, l =l= l.
Proof.
intros.
unfold EqL.

*****
l : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall X : Tpoint, iff (IncidentL X l) (IncidentL X l)
+++++
intuition.
-----
Lemma eq_reflexivity : forall l, l =l= l.
Proof.
intros.
unfold EqL.
intuition.

*****

*****

+++++
Qed.
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m : Line) (_ : EqL l m), EqL m l
+++++
Proof.
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m : Line) (_ : EqL l m), EqL m l
+++++
unfold EqL.
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.
Proof.
unfold EqL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l m : Line) (_ : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)) (X : Tpoint), iff (IncidentL X m) (IncidentL X l)
+++++
intros.
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.
Proof.
unfold EqL.
intros.

*****
X : Tpoint
H : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)
l,m : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentL X m) (IncidentL X l)
+++++
assert (T:=H X).
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.
Proof.
unfold EqL.
intros.
assert (T:=H X).

*****
T : iff (IncidentL X l) (IncidentL X m)
X : Tpoint
H : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)
l,m : Line
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentL X m) (IncidentL X l)
+++++
intuition.
-----
Lemma eq_symmetry : forall l m, l =l= m -> m =l= l.
Proof.
unfold EqL.
intros.
assert (T:=H X).
intuition.

*****

*****

+++++
Qed.
-----
Instance EqL_Equiv : Equivalence EqL.
-----
Instance EqL_Equiv : Equivalence EqL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Equivalence EqL
+++++
Proof.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Equivalence EqL
+++++
split.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflexive EqL
+++++
unfold Reflexive.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.
unfold Reflexive.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall x : Line, EqL x x
+++++
apply eq_reflexivity.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Symmetric EqL
+++++
unfold Symmetric.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.
unfold Symmetric.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (x y : Line) (_ : EqL x y), EqL y x
+++++
apply eq_symmetry.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Transitive EqL
+++++
unfold Transitive.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.
unfold Transitive.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (x y z : Line) (_ : EqL x y) (_ : EqL y z), EqL x z
+++++
apply eq_transitivity.
-----
Instance EqL_Equiv : Equivalence EqL.
Proof.
split.

*****

*****

+++++
Defined.
-----
Lemma eq_incident : forall A l m, l =l= m ->\n (IncidentL A l <-> IncidentL A m).
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Tpoint) (l m : Line) (_ : EqL l m), iff (IncidentL A l) (IncidentL A m)
+++++
Proof.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Tpoint) (l m : Line) (_ : EqL l m), iff (IncidentL A l) (IncidentL A m)
+++++
intros.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.

*****
H : EqL l m
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentL A l) (IncidentL A m)
+++++
split.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.

*****
H : EqL l m
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : IncidentL A l, IncidentL A m
+++++
intros.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.
intros.

*****
H0 : IncidentL A l
H : EqL l m
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A m
+++++
unfold EqL in *.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.
intros.
unfold EqL in *.

*****
H0 : IncidentL A l
H : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A m
+++++
assert (T:= H A).
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.
intros.
unfold EqL in *.
assert (T:= H A).

*****
T : iff (IncidentL A l) (IncidentL A m)
H0 : IncidentL A l
H : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A m
+++++
intuition.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.

*****
H : EqL l m
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : IncidentL A m, IncidentL A l
+++++
intros.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.
intros.

*****
H0 : IncidentL A m
H : EqL l m
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A l
+++++
unfold EqL in *.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.
intros.
unfold EqL in *.

*****
H0 : IncidentL A m
H : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A l
+++++
assert (T:= H A).
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.
intros.
unfold EqL in *.
assert (T:= H A).

*****
T : iff (IncidentL A l) (IncidentL A m)
H0 : IncidentL A m
H : forall X : Tpoint, iff (IncidentL X l) (IncidentL X m)
l,m : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A l
+++++
intuition.
-----
Lemma eq_incident : forall A l m, l =l= m -> (IncidentL A l <-> IncidentL A m).
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Instance incident_Proper (A:Tpoint) :\nProper (EqL ==>iff) (IncidentL A).
-----
Instance incident_Proper (A:Tpoint) : Proper (EqL ==>iff) (IncidentL A).

*****
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Proper (respectful EqL iff) (IncidentL A)
+++++
Proof.
-----
Instance incident_Proper (A:Tpoint) : Proper (EqL ==>iff) (IncidentL A).
Proof.

*****
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Proper (respectful EqL iff) (IncidentL A)
+++++
intros a b H.
-----
Instance incident_Proper (A:Tpoint) : Proper (EqL ==>iff) (IncidentL A).
Proof.
intros a b H.

*****
H : EqL a b
a,b : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentL A a) (IncidentL A b)
+++++
apply eq_incident.
-----
Instance incident_Proper (A:Tpoint) : Proper (EqL ==>iff) (IncidentL A).
Proof.
intros a b H.
apply eq_incident.

*****
H : EqL a b
a,b : Line
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL a b
+++++
assumption.
-----
Instance incident_Proper (A:Tpoint) : Proper (EqL ==>iff) (IncidentL A).
Proof.
intros a b H.
apply eq_incident.
assumption.

*****

*****

+++++
Defined.
-----
Lemma axiom_Incid_morphism :\n forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.
-----
Lemma axiom_Incid_morphism : forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P : Tpoint) (l : Couple) (m : Line) (_ : IncidentL P l) (_ : EqL l m), IncidentL P m
+++++
Proof.
-----
Lemma axiom_Incid_morphism : forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P : Tpoint) (l : Couple) (m : Line) (_ : IncidentL P l) (_ : EqL l m), IncidentL P m
+++++
intros.
-----
Lemma axiom_Incid_morphism : forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.
Proof.
intros.

*****
H0 : EqL l m
H : IncidentL P l
m : Line
l : Couple
P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL P m
+++++
destruct (eq_incident P l m H0).
-----
Lemma axiom_Incid_morphism : forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.
Proof.
intros.
destruct (eq_incident P l m H0).

*****
H2 : forall _ : IncidentL P m, IncidentL P l
H1 : forall _ : IncidentL P l, IncidentL P m
H0 : EqL l m
H : IncidentL P l
m : Line
l : Couple
P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL P m
+++++
intuition.
-----
Lemma axiom_Incid_morphism : forall P l m, IncidentL P l -> EqL l m -> IncidentL P m.
Proof.
intros.
destruct (eq_incident P l m H0).
intuition.

*****

*****

+++++
Qed.
-----
Lemma axiom_Incid_dec : forall P l, IncidentL P l \/ ~IncidentL P l.
-----
Lemma axiom_Incid_dec : forall P l, IncidentL P l \\/ ~IncidentL P l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P : Tpoint) (l : Couple), or (IncidentL P l) (not (IncidentL P l))
+++++
Proof.
-----
Lemma axiom_Incid_dec : forall P l, IncidentL P l \\/ ~IncidentL P l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P : Tpoint) (l : Couple), or (IncidentL P l) (not (IncidentL P l))
+++++
intros.
-----
Lemma axiom_Incid_dec : forall P l, IncidentL P l \\/ ~IncidentL P l.
Proof.
intros.

*****
l : Couple
P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (IncidentL P l) (not (IncidentL P l))
+++++
unfold IncidentL.
-----
Lemma axiom_Incid_dec : forall P l, IncidentL P l \\/ ~IncidentL P l.
Proof.
intros.
unfold IncidentL.

*****
l : Couple
P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Col P (P1 l) (P2 l)) (not (Col P (P1 l) (P2 l)))
+++++
apply col_dec.
-----
Lemma axiom_Incid_dec : forall P l, IncidentL P l \\/ ~IncidentL P l.
Proof.
intros.
unfold IncidentL.
apply col_dec.

*****

*****

+++++
Qed.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B ->\n IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m ->\n l =l= m.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l m : Couple) (_ : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l) (_ : IncidentL A m) (_ : IncidentL B m), EqL l m
+++++
Proof.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l m : Couple) (_ : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l) (_ : IncidentL A m) (_ : IncidentL B m), EqL l m
+++++
intros.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.

*****
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL l m
+++++
assert ((Lin A B H) =l= l).
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).

*****
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL (Lin A B H) l
+++++
eapply incident_eq.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
eapply incident_eq.

*****
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A l
+++++
assumption.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
eapply incident_eq.

*****
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B l
+++++
assumption.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).

*****
H4 : EqL (Lin A B H) l
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL l m
+++++
assert ((Lin A B H) =l= m).
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
assert ((Lin A B H) =l= m).

*****
H4 : EqL (Lin A B H) l
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL (Lin A B H) m
+++++
eapply incident_eq.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
assert ((Lin A B H) =l= m).
eapply incident_eq.

*****
H4 : EqL (Lin A B H) l
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A m
+++++
assumption.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
assert ((Lin A B H) =l= m).
eapply incident_eq.

*****
H4 : EqL (Lin A B H) l
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B m
+++++
assumption.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
assert ((Lin A B H) =l= m).

*****
H5 : EqL (Lin A B H) m
H4 : EqL (Lin A B H) l
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL l m
+++++
rewrite <- H4.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).
assert ((Lin A B H) =l= m).
rewrite <- H4.

*****
H5 : EqL (Lin A B H) m
H4 : EqL (Lin A B H) l
H3 : IncidentL B m
H2 : IncidentL A m
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l,m : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL (Lin A B H) m
+++++
assumption.
-----
Lemma axiom_line_uniqueness : forall A B l m, A <> B -> IncidentL A l -> IncidentL B l -> IncidentL A m -> IncidentL B m -> l =l= m.
Proof.
intros.
assert ((Lin A B H) =l= l).

*****

*****

+++++
Qed.
-----
Lemma axiom_two_points_on_line : forall l,\n  { A : Tpoint & { B | IncidentL B l /\ IncidentL A l /\ A <> B}}.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall l : Couple, sigT (fun A : Tpoint => sig (fun B : Tpoint => and (IncidentL B l) (and (IncidentL A l) (not (eq A B)))))
+++++
Proof.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall l : Couple, sigT (fun A : Tpoint => sig (fun B : Tpoint => and (IncidentL B l) (and (IncidentL A l) (not (eq A B)))))
+++++
intros.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
sigT (fun A : Tpoint => sig (fun B : Tpoint => and (IncidentL B l) (and (IncidentL A l) (not (eq A B)))))
+++++
exists (P1 l).
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
sig (fun B : Tpoint => and (IncidentL B l) (and (IncidentL (P1 l) l) (not (eq (P1 l) B))))
+++++
exists (P2 l).
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL (P2 l) l) (and (IncidentL (P1 l) l) (not (eq (P1 l) (P2 l))))
+++++
unfold IncidentL.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).
unfold IncidentL.

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col (P2 l) (P1 l) (P2 l)) (and (Col (P1 l) (P1 l) (P2 l)) (not (eq (P1 l) (P2 l))))
+++++
repeat split.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).
unfold IncidentL.
repeat split.

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P2 l) (P1 l) (P2 l)
+++++
Col.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).
unfold IncidentL.
repeat split.

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P1 l) (P2 l)
+++++
Col.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).
unfold IncidentL.
repeat split.

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq (P1 l) (P2 l))
+++++
Col.
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).
unfold IncidentL.
repeat split.
Col.

*****
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq (P1 l) (P2 l))
+++++
exact (Cond l).
-----
Lemma axiom_two_points_on_line : forall l, { A : Tpoint & { B | IncidentL B l /\\ IncidentL A l /\\ A <> B}}.
Proof.
intros.
exists (P1 l).
exists (P2 l).
unfold IncidentL.
repeat split.

*****

*****

+++++
Qed.
-----
Definition Col_H := fun A B C =>\n  exists l, IncidentL A l /\ IncidentL B l /\ IncidentL C l.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Col_H A B C), Col A B C
+++++
Proof.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Col_H A B C), Col A B C
+++++
intros.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.

*****
H : Col_H A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
unfold Col_H in H.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.

*****
H : ex\n (fun l : Couple =>\n and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
DecompExAnd H l.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.

*****
H4 : IncidentL C l
H3 : IncidentL B l
H1 : IncidentL A l
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
unfold IncidentL in *.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.

*****
H4 : Col C (P1 l) (P2 l)
H3 : Col B (P1 l) (P2 l)
H1 : Col A (P1 l) (P2 l)
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert (T:=Cond l).
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.
assert (T:=Cond l).

*****
T : not (eq (P1 l) (P2 l))
H4 : Col C (P1 l) (P2 l)
H3 : Col B (P1 l) (P2 l)
H1 : Col A (P1 l) (P2 l)
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
apply (col3 (P1 l) (P2 l)).
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.
assert (T:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
T : not (eq (P1 l) (P2 l))
H4 : Col C (P1 l) (P2 l)
H3 : Col B (P1 l) (P2 l)
H1 : Col A (P1 l) (P2 l)
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq (P1 l) (P2 l))
+++++
Col.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.
assert (T:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
T : not (eq (P1 l) (P2 l))
H4 : Col C (P1 l) (P2 l)
H3 : Col B (P1 l) (P2 l)
H1 : Col A (P1 l) (P2 l)
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) A
+++++
Col.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.
assert (T:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
T : not (eq (P1 l) (P2 l))
H4 : Col C (P1 l) (P2 l)
H3 : Col B (P1 l) (P2 l)
H1 : Col A (P1 l) (P2 l)
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) B
+++++
Col.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.
assert (T:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****
T : not (eq (P1 l) (P2 l))
H4 : Col C (P1 l) (P2 l)
H3 : Col B (P1 l) (P2 l)
H1 : Col A (P1 l) (P2 l)
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) C
+++++
Col.
-----
Lemma cols_coincide_1 : forall A B C, Col_H A B C -> Col A B C.
Proof.
intros.
unfold Col_H in H.
DecompExAnd H l.
unfold IncidentL in *.
assert (T:=Cond l).
apply (col3 (P1 l) (P2 l)).

*****

*****

+++++
Qed.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Col A B C), Col_H A B C
+++++
Proof.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Col A B C), Col_H A B C
+++++
intros.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.

*****
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A B C
+++++
unfold Col_H.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.

*****
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
elim (eq_dec_points A B).
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).

*****
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A B, ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
intro.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.

*****
H0 : eq A B
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
subst B.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.

*****
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL C l)))
+++++
elim (eq_dec_points A C).
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).

*****
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A C, ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL C l)))
+++++
intro.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.

*****
H0 : eq A C
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL C l)))
+++++
subst C.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
subst C.

*****
H : Col A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL A l)))
+++++
assert (exists B, A<>B).
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
subst C.
assert (exists B, A<>B).

*****
H : Col A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => not (eq A B))
+++++
eapply another_point.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
subst C.
assert (exists B, A<>B).

*****
H0 : ex (fun B : Tpoint => not (eq A B))
H : Col A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL A l)))
+++++
DecompEx H0 B.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
subst C.
assert (exists B, A<>B).
DecompEx H0 B.

*****
H1 : not (eq A B)
B : Tpoint
H : Col A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL A l)))
+++++
exists (Lin A B H1).
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
subst C.
assert (exists B, A<>B).
DecompEx H0 B.
exists (Lin A B H1).

*****
H1 : not (eq A B)
B : Tpoint
H : Col A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL A (Lin A B H1)) (and (IncidentL A (Lin A B H1)) (IncidentL A (Lin A B H1)))
+++++
unfold IncidentL.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
subst C.
assert (exists B, A<>B).
DecompEx H0 B.
exists (Lin A B H1).
unfold IncidentL.

*****
H1 : not (eq A B)
B : Tpoint
H : Col A A A
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A (P1 (Lin A B H1)) (P2 (Lin A B H1))) (and (Col A (P1 (Lin A B H1)) (P2 (Lin A B H1))) (Col A (P1 (Lin A B H1)) (P2 (Lin A B H1))))
+++++
intuition.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).

*****
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A C), ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL C l)))
+++++
intro.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.

*****
H0 : not (eq A C)
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL A l) (IncidentL C l)))
+++++
exists (Lin A C H0).
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
exists (Lin A C H0).

*****
H0 : not (eq A C)
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL A (Lin A C H0)) (and (IncidentL A (Lin A C H0)) (IncidentL C (Lin A C H0)))
+++++
unfold IncidentL.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
subst B.
elim (eq_dec_points A C).
intro.
exists (Lin A C H0).
unfold IncidentL.

*****
H0 : not (eq A C)
H : Col A A C
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A (P1 (Lin A C H0)) (P2 (Lin A C H0))) (and (Col A (P1 (Lin A C H0)) (P2 (Lin A C H0))) (Col C (P1 (Lin A C H0)) (P2 (Lin A C H0))))
+++++
intuition.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).

*****
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A B), ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
intro.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.

*****
H0 : not (eq A B)
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
exists (Lin A B H0).
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
exists (Lin A B H0).

*****
H0 : not (eq A B)
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL A (Lin A B H0)) (and (IncidentL B (Lin A B H0)) (IncidentL C (Lin A B H0)))
+++++
unfold IncidentL.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).
intro.
exists (Lin A B H0).
unfold IncidentL.

*****
H0 : not (eq A B)
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A (P1 (Lin A B H0)) (P2 (Lin A B H0))) (and (Col B (P1 (Lin A B H0)) (P2 (Lin A B H0))) (Col C (P1 (Lin A B H0)) (P2 (Lin A B H0))))
+++++
intuition.
-----
Lemma cols_coincide_2 : forall A B C, Col A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H.
elim (eq_dec_points A B).

*****

*****

+++++
Qed.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (Col A B C) (Col_H A B C)
+++++
Proof.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (Col A B C) (Col_H A B C)
+++++
intros.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.
Proof.
intros.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Col A B C) (Col_H A B C)
+++++
split.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col A B C, Col_H A B C
+++++
apply cols_coincide_2.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col_H A B C, Col A B C
+++++
apply cols_coincide_1.
-----
Lemma cols_coincide : forall A B C, Col A B C <-> Col_H A B C.
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (not (Col A B C)) (not (Col_H A B C))
+++++
Proof.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (not (Col A B C)) (not (Col_H A B C))
+++++
intros.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.
intros.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (not (Col A B C)) (not (Col_H A B C))
+++++
split.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col A B C), not (Col_H A B C)
+++++
intros HNCol HCol.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.
intros.
split.
intros HNCol HCol.

*****
HCol : Col_H A B C
HNCol : not (Col A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol, cols_coincide, HCol.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.
intros.
split.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col_H A B C), not (Col A B C)
+++++
intros HNCol HCol.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.
intros.
split.
intros HNCol HCol.

*****
HCol : Col A B C
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol, cols_coincide, HCol.
-----
Lemma ncols_coincide : forall A B C, ~ Col A B C <-> ~ Col_H A B C.
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma lower_dim' : PA <> PB /\ PB <> PC /\ PA <> PC /\ ~ Col_H PA PB PC.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq PA PB)) (and (not (eq PB PC)) (and (not (eq PA PC)) (not (Col_H PA PB PC))))
+++++
Proof.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq PA PB)) (and (not (eq PB PC)) (and (not (eq PA PC)) (not (Col_H PA PB PC))))
+++++
assert (HNCol : ~ Col PA PB PC).
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col PA PB PC)
+++++
apply lower_dim.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).

*****
HNCol : not (Col PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq PA PB)) (and (not (eq PB PC)) (and (not (eq PA PC)) (not (Col_H PA PB PC))))
+++++
idtac.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.

*****
HNCol : not (Col PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq PA PB)) (and (not (eq PB PC)) (and (not (eq PA PC)) (not (Col_H PA PB PC))))
+++++
assert_diffs.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.
assert_diffs.

*****
H4 : not (eq PA PC)
H1 : not (eq PB PC)
H2 : not (eq PA PB)
HNCol : not (Col PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq PA PB)) (and (not (eq PB PC)) (and (not (eq PA PC)) (not (Col_H PA PB PC))))
+++++
apply ncols_coincide in HNCol.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.
assert_diffs.
apply ncols_coincide in HNCol.

*****
H4 : not (eq PA PC)
H1 : not (eq PB PC)
H2 : not (eq PA PB)
HNCol : not (Col_H PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq PA PB)) (and (not (eq PB PC)) (and (not (eq PA PC)) (not (Col_H PA PB PC))))
+++++
repeat split.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.
assert_diffs.
apply ncols_coincide in HNCol.
repeat split.

*****
H4 : not (eq PA PC)
H1 : not (eq PB PC)
H2 : not (eq PA PB)
HNCol : not (Col_H PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq PA PB)
+++++
auto.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.
assert_diffs.
apply ncols_coincide in HNCol.
repeat split.

*****
H4 : not (eq PA PC)
H1 : not (eq PB PC)
H2 : not (eq PA PB)
HNCol : not (Col_H PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq PB PC)
+++++
auto.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.
assert_diffs.
apply ncols_coincide in HNCol.
repeat split.

*****
H4 : not (eq PA PC)
H1 : not (eq PB PC)
H2 : not (eq PA PB)
HNCol : not (Col_H PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq PA PC)
+++++
auto.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).
idtac.
assert_diffs.
apply ncols_coincide in HNCol.
repeat split.

*****
H4 : not (eq PA PC)
H1 : not (eq PB PC)
H2 : not (eq PA PB)
HNCol : not (Col_H PA PB PC)
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col_H PA PB PC)
+++++
auto.
-----
Lemma lower_dim' : PA <> PB /\\ PB <> PC /\\ PA <> PC /\\ ~ Col_H PA PB PC.
Proof.
assert (HNCol : ~ Col PA PB PC).

*****

*****

+++++
Qed.
-----
Record Plane := Plan {M1; M2; M3; NCol : ~ Col_H M1 M2 M3}.
-----
Definition IncidentP := fun A p => Coplanar (M1 p) (M2 p) (M3 p) A.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C ->\n  exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (Col_H A B C)), ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (IncidentP C p)))
+++++
Proof.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (Col_H A B C)), ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (IncidentP C p)))
+++++
intros A B C HNCol.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (IncidentP C p)))
+++++
exists (Plan A B C HNCol).
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP A {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (and (IncidentP B {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (IncidentP C {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}))
+++++
unfold IncidentP.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) A) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) B) (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) C))
+++++
simpl.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar A B C A) (and (Coplanar A B C B) (Coplanar A B C C))
+++++
repeat split.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C A
+++++
Cop.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C B
+++++
Cop.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C C
+++++
Cop.
-----
Lemma axiom_plane_existence : forall A B C, ~ Col_H A B C -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p.
Proof.
intros A B C HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****

*****

+++++
Qed.
-----
Definition EqP : relation Plane := fun p q => forall X, IncidentP X p <-> IncidentP X q.
-----
Infix "=p=" := EqP (at level 70):type_scope.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C,\n IncidentP A p -> IncidentP B p -> IncidentP C p ->\n (Plan A B C H) =p= p.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (p : Plane) (H : not (Col_H A B C)) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p), EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
+++++
Proof.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (p : Plane) (H : not (Col_H A B C)) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p), EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
+++++
intros A B C p HNCol HA HB HC X.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.

*****
X : Tpoint
HC : IncidentP C p
HB : IncidentP B p
HA : IncidentP A p
HNCol : not (Col_H A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP X {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (IncidentP X p)
+++++
unfold IncidentP in *.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.

*****
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col_H A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) X) (Coplanar (M1 p) (M2 p) (M3 p) X)
+++++
simpl.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.

*****
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col_H A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Coplanar A B C X) (Coplanar (M1 p) (M2 p) (M3 p) X)
+++++
assert (Hp := NCol p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).

*****
Hp : not (Col_H (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col_H A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Coplanar A B C X) (Coplanar (M1 p) (M2 p) (M3 p) X)
+++++
apply ncols_coincide in Hp.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.

*****
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col_H A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Coplanar A B C X) (Coplanar (M1 p) (M2 p) (M3 p) X)
+++++
apply ncols_coincide in HNCol.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.

*****
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Coplanar A B C X) (Coplanar (M1 p) (M2 p) (M3 p) X)
+++++
split.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.

*****
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Coplanar A B C X, Coplanar (M1 p) (M2 p) (M3 p) X
+++++
intro.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) X
+++++
apply coplanar_pseudo_trans with A B C.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C (M1 p)
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C (M1 p)
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) (M1 p)
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C (M2 p)
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C (M2 p)
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) (M2 p)
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C (M3 p)
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C (M3 p)
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) (M3 p)
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar A B C X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C X
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.

*****
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Coplanar (M1 p) (M2 p) (M3 p) X, Coplanar A B C X
+++++
intro.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C X
+++++
apply coplanar_pseudo_trans with A B C.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C A
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C A
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C B
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C B
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C C
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C C
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C X
+++++
trivial.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C X
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.
intro.
apply coplanar_pseudo_trans with A B C.
trivial.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
H : Coplanar (M1 p) (M2 p) (M3 p) X
Hp : not (Col (M1 p) (M2 p) (M3 p))
X : Tpoint
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
HNCol : not (Col A B C)
p : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) X
+++++
Cop.
-----
Lemma incidentp_eqp : forall A B C p, forall H : ~ Col_H A B C, IncidentP A p -> IncidentP B p -> IncidentP C p -> (Plan A B C H) =p= p.
Proof.
intros A B C p HNCol HA HB HC X.
unfold IncidentP in *.
simpl.
assert (Hp := NCol p).
apply ncols_coincide in Hp.
apply ncols_coincide in HNCol.
split.

*****

*****

+++++
Qed.
-----
Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.
-----
Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (p q r : Plane) (_ : EqP p q) (_ : EqP q r), EqP p r
+++++
Proof.
-----
Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (p q r : Plane) (_ : EqP p q) (_ : EqP q r), EqP p r
+++++
intros p q r H1 H2 X.
-----
Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.
Proof.
intros p q r H1 H2 X.

*****
X : Tpoint
H2 : EqP q r
H1 : EqP p q
p,q,r : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP X p) (IncidentP X r)
+++++
rewrite (H1 X).
-----
Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.
Proof.
intros p q r H1 H2 X.
rewrite (H1 X).

*****
X : Tpoint
H2 : EqP q r
H1 : EqP p q
p,q,r : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP X q) (IncidentP X r)
+++++
apply H2.
-----
Lemma eqp_transitivity : forall p q r, p =p= q -> q =p= r -> p =p= r.
Proof.
intros p q r H1 H2 X.
rewrite (H1 X).
apply H2.

*****

*****

+++++
Qed.
-----
Lemma eqp_reflexivity : forall p, p =p= p.
-----
Lemma eqp_reflexivity : forall p, p =p= p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall p : Plane, EqP p p
+++++
Proof.
-----
Lemma eqp_reflexivity : forall p, p =p= p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall p : Plane, EqP p p
+++++
intros.
-----
Lemma eqp_reflexivity : forall p, p =p= p.
Proof.
intros.

*****
p : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP p p
+++++
unfold EqP.
-----
Lemma eqp_reflexivity : forall p, p =p= p.
Proof.
intros.
unfold EqP.

*****
p : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall X : Tpoint, iff (IncidentP X p) (IncidentP X p)
+++++
intuition.
-----
Lemma eqp_reflexivity : forall p, p =p= p.
Proof.
intros.
unfold EqP.
intuition.

*****

*****

+++++
Qed.
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (p q : Plane) (_ : EqP p q), EqP q p
+++++
Proof.
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (p q : Plane) (_ : EqP p q), EqP q p
+++++
unfold EqP.
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.
Proof.
unfold EqP.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (p q : Plane) (_ : forall X : Tpoint, iff (IncidentP X p) (IncidentP X q)) (X : Tpoint), iff (IncidentP X q) (IncidentP X p)
+++++
intros p q H X.
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.
Proof.
unfold EqP.
intros p q H X.

*****
X : Tpoint
H : forall X : Tpoint, iff (IncidentP X p) (IncidentP X q)
p,q : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP X q) (IncidentP X p)
+++++
assert (T := H X).
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.
Proof.
unfold EqP.
intros p q H X.
assert (T := H X).

*****
T : iff (IncidentP X p) (IncidentP X q)
X : Tpoint
H : forall X : Tpoint, iff (IncidentP X p) (IncidentP X q)
p,q : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP X q) (IncidentP X p)
+++++
intuition.
-----
Lemma eqp_symmetry : forall p q, p =p= q -> q =p= p.
Proof.
unfold EqP.
intros p q H X.
assert (T := H X).
intuition.

*****

*****

+++++
Qed.
-----
Instance EqP_Equiv : Equivalence EqP.
-----
Instance EqP_Equiv : Equivalence EqP.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Equivalence EqP
+++++
Proof.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Equivalence EqP
+++++
split.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflexive EqP
+++++
unfold Reflexive.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.
unfold Reflexive.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall x : Plane, EqP x x
+++++
apply eqp_reflexivity.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Symmetric EqP
+++++
unfold Symmetric.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.
unfold Symmetric.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (x y : Plane) (_ : EqP x y), EqP y x
+++++
apply eqp_symmetry.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Transitive EqP
+++++
unfold Transitive.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.
unfold Transitive.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (x y z : Plane) (_ : EqP x y) (_ : EqP y z), EqP x z
+++++
apply eqp_transitivity.
-----
Instance EqP_Equiv : Equivalence EqP.
Proof.
split.

*****

*****

+++++
Defined.
-----
Lemma eqp_incidentp : forall A p q, p =p= q ->\n (IncidentP A p <-> IncidentP A q).
-----
Lemma eqp_incidentp : forall A p q, p =p= q -> (IncidentP A p <-> IncidentP A q).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Tpoint) (p q : Plane) (_ : EqP p q), iff (IncidentP A p) (IncidentP A q)
+++++
Proof.
-----
Lemma eqp_incidentp : forall A p q, p =p= q -> (IncidentP A p <-> IncidentP A q).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Tpoint) (p q : Plane) (_ : EqP p q), iff (IncidentP A p) (IncidentP A q)
+++++
intros A p q H.
-----
Lemma eqp_incidentp : forall A p q, p =p= q -> (IncidentP A p <-> IncidentP A q).
Proof.
intros A p q H.

*****
H : EqP p q
p,q : Plane
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP A p) (IncidentP A q)
+++++
exact (H A).
-----
Lemma eqp_incidentp : forall A p q, p =p= q -> (IncidentP A p <-> IncidentP A q).
Proof.
intros A p q H.
exact (H A).

*****

*****

+++++
Qed.
-----
Instance incidentp_Proper (A:Tpoint) :\nProper (EqP ==>iff) (IncidentP A).
-----
Instance incidentp_Proper (A:Tpoint) : Proper (EqP ==>iff) (IncidentP A).

*****
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Proper (respectful EqP iff) (IncidentP A)
+++++
Proof.
-----
Instance incidentp_Proper (A:Tpoint) : Proper (EqP ==>iff) (IncidentP A).
Proof.

*****
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Proper (respectful EqP iff) (IncidentP A)
+++++
intros a b H.
-----
Instance incidentp_Proper (A:Tpoint) : Proper (EqP ==>iff) (IncidentP A).
Proof.
intros a b H.

*****
H : EqP a b
a,b : Plane
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (IncidentP A a) (IncidentP A b)
+++++
apply eqp_incidentp.
-----
Instance incidentp_Proper (A:Tpoint) : Proper (EqP ==>iff) (IncidentP A).
Proof.
intros a b H.
apply eqp_incidentp.

*****
H : EqP a b
a,b : Plane
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP a b
+++++
assumption.
-----
Instance incidentp_Proper (A:Tpoint) : Proper (EqP ==>iff) (IncidentP A).
Proof.
intros a b H.
apply eqp_incidentp.
assumption.

*****

*****

+++++
Defined.
-----
Lemma axiom_Incidp_morphism :\n forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.
-----
Lemma axiom_Incidp_morphism : forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (p q : Plane) (_ : IncidentP M p) (_ : EqP p q), IncidentP M q
+++++
Proof.
-----
Lemma axiom_Incidp_morphism : forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (p q : Plane) (_ : IncidentP M p) (_ : EqP p q), IncidentP M q
+++++
intros M p q Hp H.
-----
Lemma axiom_Incidp_morphism : forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.
Proof.
intros M p q Hp H.

*****
H : EqP p q
Hp : IncidentP M p
p,q : Plane
M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP M q
+++++
destruct (eqp_incidentp M p q H).
-----
Lemma axiom_Incidp_morphism : forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.
Proof.
intros M p q Hp H.
destruct (eqp_incidentp M p q H).

*****
H1 : forall _ : IncidentP M q, IncidentP M p
H0 : forall _ : IncidentP M p, IncidentP M q
H : EqP p q
Hp : IncidentP M p
p,q : Plane
M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP M q
+++++
intuition.
-----
Lemma axiom_Incidp_morphism : forall M p q, IncidentP M p -> EqP p q -> IncidentP M q.
Proof.
intros M p q Hp H.
destruct (eqp_incidentp M p q H).
intuition.

*****

*****

+++++
Qed.
-----
Lemma axiom_Incidp_dec : forall M p, IncidentP M p \/ ~ IncidentP M p.
-----
Lemma axiom_Incidp_dec : forall M p, IncidentP M p \\/ ~ IncidentP M p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (p : Plane), or (IncidentP M p) (not (IncidentP M p))
+++++
Proof.
-----
Lemma axiom_Incidp_dec : forall M p, IncidentP M p \\/ ~ IncidentP M p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (p : Plane), or (IncidentP M p) (not (IncidentP M p))
+++++
intros.
-----
Lemma axiom_Incidp_dec : forall M p, IncidentP M p \\/ ~ IncidentP M p.
Proof.
intros.

*****
p : Plane
M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (IncidentP M p) (not (IncidentP M p))
+++++
apply cop_dec.
-----
Lemma axiom_Incidp_dec : forall M p, IncidentP M p \\/ ~ IncidentP M p.
Proof.
intros.
apply cop_dec.

*****

*****

+++++
Qed.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C ->\n IncidentP A p -> IncidentP B p -> IncidentP C p ->\n IncidentP A q -> IncidentP B q -> IncidentP C q ->\n p =p= q.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (p q : Plane) (_ : not (Col_H A B C)) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentP A q) (_ : IncidentP B q) (_ : IncidentP C q), EqP p q
+++++
Proof.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (p q : Plane) (_ : not (Col_H A B C)) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentP A q) (_ : IncidentP B q) (_ : IncidentP C q), EqP p q
+++++
intros A B C p q H.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.

*****
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentP A q) (_ : IncidentP B q) (_ : IncidentP C q), EqP p q
+++++
intros.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.

*****
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP p q
+++++
assert (Heq : (Plan A B C H) =p= p).
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).

*****
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
+++++
apply incidentp_eqp.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
apply incidentp_eqp.

*****
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A p
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
apply incidentp_eqp.

*****
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B p
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
apply incidentp_eqp.

*****
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C p
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP p q
+++++
assert ((Plan A B C H) =p= q).
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
assert ((Plan A B C H) =p= q).

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} q
+++++
apply incidentp_eqp.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
assert ((Plan A B C H) =p= q).
apply incidentp_eqp.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A q
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
assert ((Plan A B C H) =p= q).
apply incidentp_eqp.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B q
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
assert ((Plan A B C H) =p= q).
apply incidentp_eqp.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C q
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
assert ((Plan A B C H) =p= q).

*****
H6 : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} q
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP p q
+++++
rewrite <- Heq.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).
assert ((Plan A B C H) =p= q).
rewrite <- Heq.

*****
H6 : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} q
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} p
H5 : IncidentP C q
H4 : IncidentP B q
H3 : IncidentP A q
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p,q : Plane
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP {| M1 := A; M2 := B; M3 := C; NCol := H |} q
+++++
assumption.
-----
Lemma axiom_plane_uniqueness : forall A B C p q, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP A q -> IncidentP B q -> IncidentP C q -> p =p= q.
Proof.
intros A B C p q H.
intros.
assert (Heq : (Plan A B C H) =p= p).

*****

*****

+++++
Qed.
-----
Lemma axiom_one_point_on_plane : forall p,\n  { A | IncidentP A p }.
-----
Lemma axiom_one_point_on_plane : forall p, { A | IncidentP A p }.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall p : Plane, sig (fun A : Tpoint => IncidentP A p)
+++++
Proof.
-----
Lemma axiom_one_point_on_plane : forall p, { A | IncidentP A p }.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall p : Plane, sig (fun A : Tpoint => IncidentP A p)
+++++
intro p.
-----
Lemma axiom_one_point_on_plane : forall p, { A | IncidentP A p }.
Proof.
intro p.

*****
p : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
sig (fun A : Tpoint => IncidentP A p)
+++++
exists (M1 p).
-----
Lemma axiom_one_point_on_plane : forall p, { A | IncidentP A p }.
Proof.
intro p.
exists (M1 p).

*****
p : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP (M1 p) p
+++++
unfold IncidentP.
-----
Lemma axiom_one_point_on_plane : forall p, { A | IncidentP A p }.
Proof.
intro p.
exists (M1 p).
unfold IncidentP.

*****
p : Plane
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) (M1 p)
+++++
Cop.
-----
Lemma axiom_one_point_on_plane : forall p, { A | IncidentP A p }.
Proof.
intro p.
exists (M1 p).
unfold IncidentP.
Cop.

*****

*****

+++++
Qed.
-----
Definition  IncidentLP := fun l p => forall A, IncidentL A l -> IncidentP A p.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B ->\n IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p ->\n IncidentLP l p.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (p : Plane) (_ : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l) (_ : IncidentP A p) (_ : IncidentP B p), IncidentLP l p
+++++
Proof.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (p : Plane) (_ : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l) (_ : IncidentP A p) (_ : IncidentP B p), IncidentLP l p
+++++
intros A B l p HAB HAl HBl HAp HBp X HXl.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.

*****
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP X p
+++++
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].

*****
HNCol : not (Col A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP X p
+++++
apply ncols_coincide in HNCol.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.

*****
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP X p
+++++
assert (Heq : (Plan A B C HNCol) =p= p).
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).

*****
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
+++++
apply incidentp_eqp.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
apply incidentp_eqp.

*****
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A p
+++++
auto.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
apply incidentp_eqp.

*****
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B p
+++++
auto.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
apply incidentp_eqp.

*****
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C p
+++++
auto.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP X p
+++++
rewrite <- Heq.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP X {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentP.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) X
+++++
simpl.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C X
+++++
exists X.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Col A B X) (Col C X X)) (or (and (Col A C X) (Col B X X)) (and (Col A X X) (Col B C X)))
+++++
left.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A B X) (Col C X X)
+++++
split.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B X
+++++
apply cols_coincide_1.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.
apply cols_coincide_1.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A B X
+++++
exists l.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.
apply cols_coincide_1.
exists l.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL A l) (and (IncidentL B l) (IncidentL X l))
+++++
repeat split.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.
apply cols_coincide_1.
exists l.
repeat split.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A l
+++++
assumption.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.
apply cols_coincide_1.
exists l.
repeat split.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B l
+++++
assumption.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.
apply cols_coincide_1.
exists l.
repeat split.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL X l
+++++
assumption.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).
rewrite <- Heq.
unfold IncidentP.
simpl.
exists X.
left.
split.

*****
Heq : EqP {| M1 := A; M2 := B; M3 := C; NCol := HNCol |} p
HNCol : not (Col_H A B C)
HCp : Coplanar (M1 p) (M2 p) (M3 p) C
C : Tpoint
HXl : IncidentL X l
X : Tpoint
HBp : IncidentP B p
HAp : IncidentP A p
HBl : IncidentL B l
HAl : IncidentL A l
HAB : not (eq A B)
p : Plane
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C X X
+++++
Col.
-----
Lemma axiom_line_on_plane : forall A B l p, A <> B -> IncidentL A l -> IncidentL B l -> IncidentP A p -> IncidentP B p -> IncidentLP l p.
Proof.
intros A B l p HAB HAl HBl HAp HBp X HXl.
destruct (ex_ncol_cop (M1 p) (M2 p) (M3 p) A B HAB) as [C [HCp HNCol]].
apply ncols_coincide in HNCol.
assert (Heq : (Plan A B C HNCol) =p= p).

*****

*****

+++++
Qed.
-----
Definition Between_H := fun A B C =>\n  Bet A B C /\ A <> B /\ B <> C /\ A <> C.
-----
Lemma axiom_between_col :\n forall A B C, Between_H A B C -> Col_H A B C.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), Col_H A B C
+++++
Proof.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), Col_H A B C
+++++
intros.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.

*****
H : Between_H A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A B C
+++++
unfold Col_H in *.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H in *.

*****
H : Between_H A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
unfold Between_H in *.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H in *.
unfold Between_H in *.

*****
H : and (Bet A B C)\n (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
DecompAndAll.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H in *.
unfold Between_H in *.
DecompAndAll.

*****
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
H0 : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun l : Couple => and (IncidentL A l) (and (IncidentL B l) (IncidentL C l)))
+++++
exists (Lin A B H2).
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H in *.
unfold Between_H in *.
DecompAndAll.
exists (Lin A B H2).

*****
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
H0 : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL A (Lin A B H2)) (and (IncidentL B (Lin A B H2)) (IncidentL C (Lin A B H2)))
+++++
unfold IncidentL.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H in *.
unfold Between_H in *.
DecompAndAll.
exists (Lin A B H2).
unfold IncidentL.

*****
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
H0 : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A (P1 (Lin A B H2)) (P2 (Lin A B H2))) (and (Col B (P1 (Lin A B H2)) (P2 (Lin A B H2))) (Col C (P1 (Lin A B H2)) (P2 (Lin A B H2))))
+++++
intuition.
-----
Lemma axiom_between_col : forall A B C, Between_H A B C -> Col_H A B C.
Proof.
intros.
unfold Col_H in *.
unfold Between_H in *.
DecompAndAll.
exists (Lin A B H2).
unfold IncidentL.
intuition.

*****

*****

+++++
Qed.
-----
Lemma axiom_between_diff :\n forall A B C, Between_H A B C -> A<>C.
-----
Lemma axiom_between_diff : forall A B C, Between_H A B C -> A<>C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), not (eq A C)
+++++
Proof.
-----
Lemma axiom_between_diff : forall A B C, Between_H A B C -> A<>C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), not (eq A C)
+++++
intros.
-----
Lemma axiom_between_diff : forall A B C, Between_H A B C -> A<>C.
Proof.
intros.

*****
H : Between_H A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
unfold Between_H in *.
-----
Lemma axiom_between_diff : forall A B C, Between_H A B C -> A<>C.
Proof.
intros.
unfold Between_H in *.

*****
H : and (Bet A B C)\n (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intuition.
-----
Lemma axiom_between_diff : forall A B C, Between_H A B C -> A<>C.
Proof.
intros.
unfold Between_H in *.
intuition.

*****

*****

+++++
Qed.
-----
Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.
-----
Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), Between_H C B A
+++++
Proof.
-----
Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), Between_H C B A
+++++
unfold Between_H in |- *.
-----
Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.
Proof.
unfold Between_H in |- *.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))), and (Bet C B A) (and (not (eq C B)) (and (not (eq B A)) (not (eq C A))))
+++++
intros.
-----
Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.
Proof.
unfold Between_H in |- *.
intros.

*****
H : and (Bet A B C)\n (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B A) (and (not (eq C B)) (and (not (eq B A)) (not (eq C A))))
+++++
intuition.
-----
Lemma axiom_between_comm : forall A B C, Between_H A B C -> Between_H C B A.
Proof.
unfold Between_H in |- *.
intros.
intuition.

*****

*****

+++++
Qed.
-----
Lemma axiom_between_out :\n forall A B, A <> B -> exists C, Between_H A B C.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (eq A B)), ex (fun C : Tpoint => Between_H A B C)
+++++
Proof.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (eq A B)), ex (fun C : Tpoint => Between_H A B C)
+++++
intros.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.

*****
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => Between_H A B C)
+++++
prolong A B C A B.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => Between_H A B C)
+++++
exists C.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H A B C
+++++
unfold Between_H.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
+++++
repeat split.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
auto.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
auto.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.
auto.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
intro.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.
auto.
intro.

*****
H2 : eq B C
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.
auto.
intro.
treat_equalities.

*****
H : not (eq A A)
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
auto.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.
auto.

*****
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.
auto.
intro.

*****
H2 : eq A C
H1 : Cong B C A B
H0 : Bet A B C
C : Tpoint
H : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.
auto.
intro.
treat_equalities.

*****
H : not (eq A A)
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_between_out : forall A B, A <> B -> exists C, Between_H A B C.
Proof.
intros.
prolong A B C A B.
exists C.
unfold Between_H.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma axiom_between_only_one :\n forall A B C,\n Between_H A B C -> ~ Between_H B C A.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), not (Between_H B C A)
+++++
Proof.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Between_H A B C), not (Between_H B C A)
+++++
unfold Between_H in |- *.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))), not (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A)))))
+++++
intros.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.

*****
H : and (Bet A B C)\n (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A)))))
+++++
intro.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.

*****
H0 : and (Bet B C A)\n (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))
H : and (Bet A B C)\n (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.

*****
H3 : not (eq B A)
H2 : not (eq C A)
H1 : not (eq B C)
H0 : Bet B C A
H6 : not (eq A C)
H5 : not (eq B C)
H4 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (B=C).
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.
assert (B=C).

*****
H3 : not (eq B A)
H2 : not (eq C A)
H1 : not (eq B C)
H0 : Bet B C A
H6 : not (eq A C)
H5 : not (eq B C)
H4 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B C
+++++
apply (between_equality B C A).
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.
assert (B=C).
apply (between_equality B C A).

*****
H3 : not (eq B A)
H2 : not (eq C A)
H1 : not (eq B C)
H0 : Bet B C A
H6 : not (eq A C)
H5 : not (eq B C)
H4 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B C A
+++++
Between.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.
assert (B=C).
apply (between_equality B C A).

*****
H3 : not (eq B A)
H2 : not (eq C A)
H1 : not (eq B C)
H0 : Bet B C A
H6 : not (eq A C)
H5 : not (eq B C)
H4 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B A
+++++
Between.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.
assert (B=C).

*****
H7 : eq B C
H3 : not (eq B A)
H2 : not (eq C A)
H1 : not (eq B C)
H0 : Bet B C A
H6 : not (eq A C)
H5 : not (eq B C)
H4 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.
assert (B=C).
idtac.

*****
H7 : eq B C
H3 : not (eq B A)
H2 : not (eq C A)
H1 : not (eq B C)
H0 : Bet B C A
H6 : not (eq A C)
H5 : not (eq B C)
H4 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
solve [intuition].
-----
Lemma axiom_between_only_one : forall A B C, Between_H A B C -> ~ Between_H B C A.
Proof.
unfold Between_H in |- *.
intros.
intro.
spliter.
assert (B=C).

*****

*****

+++++
Qed.
-----
Lemma between_one : forall A B C,\n A<>B -> A<>C -> B<>C -> Col A B C ->\n Between_H A B C \/ Between_H B C A \/ Between_H B A C.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq B C)) (_ : Col A B C), or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
Proof.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq B C)) (_ : Col A B C), or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
intros.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.

*****
H2 : Col A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
unfold Col in *.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.

*****
H2 : or (Bet A B C) (or (Bet B C A) (Bet C A B))
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
unfold Between_H in *.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.

*****
H2 : or (Bet A B C) (or (Bet B C A) (Bet C A B))
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))) (or (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))) (and (Bet B A C) (and (not (eq B A)) (and (not (eq A C)) (not (eq B C))))))
+++++
destruct H2 as [|[|]].
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].

*****
H2 : Bet A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))) (or (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))) (and (Bet B A C) (and (not (eq B A)) (and (not (eq A C)) (not (eq B C))))))
+++++
left.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].
left.

*****
H2 : Bet A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
+++++
Between.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].

*****
H2 : Bet B C A
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))) (or (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))) (and (Bet B A C) (and (not (eq B A)) (and (not (eq A C)) (not (eq B C))))))
+++++
right.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].
right.

*****
H2 : Bet B C A
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))) (and (Bet B A C) (and (not (eq B A)) (and (not (eq A C)) (not (eq B C)))))
+++++
Between.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].

*****
H2 : Bet C A B
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))) (or (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))) (and (Bet B A C) (and (not (eq B A)) (and (not (eq A C)) (not (eq B C))))))
+++++
right.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].
right.

*****
H2 : Bet C A B
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet B C A) (and (not (eq B C)) (and (not (eq C A)) (not (eq B A))))) (and (Bet B A C) (and (not (eq B A)) (and (not (eq A C)) (not (eq B C)))))
+++++
Between.
-----
Lemma between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
unfold Col in *.
unfold Between_H in *.
destruct H2 as [|[|]].

*****

*****

+++++
Qed.
-----
Lemma axiom_between_one : forall A B C,\n A<>B -> A<>C -> B<>C -> Col_H A B C ->\n Between_H A B C \/ Between_H B C A \/ Between_H B A C.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq B C)) (_ : Col_H A B C), or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
Proof.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq B C)) (_ : Col_H A B C), or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
intros.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H A B C) (or (Between_H B C A) (Between_H B A C))
+++++
apply between_one.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
try assumption.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
try assumption.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
try assumption.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.
try assumption.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
apply cols_coincide_1.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.
try assumption.
apply cols_coincide_1.

*****
H2 : Col_H A B C
H1 : not (eq B C)
H0 : not (eq A C)
H : not (eq A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A B C
+++++
assumption.
-----
Lemma axiom_between_one : forall A B C, A<>B -> A<>C -> B<>C -> Col_H A B C -> Between_H A B C \\/ Between_H B C A \\/ Between_H B A C.
Proof.
intros.
apply between_one.

*****

*****

+++++
Qed.
-----
Definition cut := fun l A B =>\n  ~ IncidentL A l /\ ~ IncidentL B l /\ exists I, IncidentL I l /\ Between_H A I B.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l : Couple) (A B : Tpoint), iff (cut l A B) (TS (P1 l) (P2 l) A B)
+++++
Proof.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l : Couple) (A B : Tpoint), iff (cut l A B) (TS (P1 l) (P2 l) A B)
+++++
intros.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.

*****
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (cut l A B) (TS (P1 l) (P2 l) A B)
+++++
unfold cut.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.

*****
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))) (TS (P1 l) (P2 l) A B)
+++++
unfold TS.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.

*****
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))) (and (not (Col A (P1 l) (P2 l))) (and (not (Col B (P1 l) (P2 l))) (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B)))))
+++++
split.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.

*****
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B)))), and (not (Col A (P1 l) (P2 l))) (and (not (Col B (P1 l) (P2 l))) (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))))
+++++
intros.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.

*****
H : and (not (IncidentL A l))\n (and (not (IncidentL B l))\n (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col A (P1 l) (P2 l))) (and (not (Col B (P1 l) (P2 l))) (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))))
+++++
spliter.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.

*****
H1 : ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))
H0 : not (IncidentL B l)
H : not (IncidentL A l)
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col A (P1 l) (P2 l))) (and (not (Col B (P1 l) (P2 l))) (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))))
+++++
repeat split.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.

*****
H1 : ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))
H0 : not (IncidentL B l)
H : not (IncidentL A l)
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A (P1 l) (P2 l))
+++++
intuition.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.

*****
H1 : ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))
H0 : not (IncidentL B l)
H : not (IncidentL A l)
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B (P1 l) (P2 l))
+++++
intuition.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.

*****
H1 : ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))
H0 : not (IncidentL B l)
H : not (IncidentL A l)
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
+++++
intuition.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.
intuition.

*****
H1 : ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))
H0 : forall _ : IncidentL B l, False
H : forall _ : IncidentL A l, False
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
+++++
ex_and H1 T.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.
intuition.
ex_and H1 T.

*****
H2 : Between_H A T B
H1 : IncidentL T l
T : Tpoint
H0 : forall _ : IncidentL B l, False
H : forall _ : IncidentL A l, False
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
+++++
exists T.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.
intuition.
ex_and H1 T.
exists T.

*****
H2 : Between_H A T B
H1 : IncidentL T l
T : Tpoint
H0 : forall _ : IncidentL B l, False
H : forall _ : IncidentL A l, False
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (Bet A T B)
+++++
unfold IncidentL in H1.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.
intuition.
ex_and H1 T.
exists T.
unfold IncidentL in H1.

*****
H2 : Between_H A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : forall _ : IncidentL B l, False
H : forall _ : IncidentL A l, False
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (Bet A T B)
+++++
unfold Between_H in *.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
repeat split.
intuition.
ex_and H1 T.
exists T.
unfold IncidentL in H1.
unfold Between_H in *.

*****
H2 : and (Bet A T B)\n (and (not (eq A T)) (and (not (eq T B)) (not (eq A B))))
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : forall _ : IncidentL B l, False
H : forall _ : IncidentL A l, False
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (Bet A T B)
+++++
intuition.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.

*****
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : and (not (Col A (P1 l) (P2 l))) (and (not (Col B (P1 l) (P2 l))) (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B)))), and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))
+++++
intros.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.

*****
H : and (not (Col A (P1 l) (P2 l)))\n (and (not (Col B (P1 l) (P2 l)))\n (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))
+++++
spliter.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.

*****
H1 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))
+++++
ex_and H1 T.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (IncidentL A l)) (and (not (IncidentL B l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I B))))
+++++
unfold IncidentL.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col A (P1 l) (P2 l))) (and (not (Col B (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I B))))
+++++
repeat split.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A (P1 l) (P2 l))
+++++
try assumption.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B (P1 l) (P2 l))
+++++
try assumption.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I B))
+++++
try assumption.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I B))
+++++
exists T.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (Between_H A T B)
+++++
split.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T (P1 l) (P2 l)
+++++
assumption.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H A T B
+++++
unfold Between_H.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A T B) (and (not (eq A T)) (and (not (eq T B)) (not (eq A B))))
+++++
repeat split.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A T B
+++++
assumption.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
intro.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.
intro.

*****
H3 : eq A T
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.
intro.
subst.

*****
H2 : Bet T T B
H1 : Col T (P1 l) (P2 l)
H0 : not (Col B (P1 l) (P2 l))
H : not (Col T (P1 l) (P2 l))
B,T : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T B)
+++++
intro.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.
intro.

*****
H3 : eq T B
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.
intro.
subst.

*****
H1 : Col B (P1 l) (P2 l)
H2 : Bet A B B
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.

*****
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
intro.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.
intro.

*****
H3 : eq A B
H2 : Bet A T B
H1 : Col T (P1 l) (P2 l)
T : Tpoint
H0 : not (Col B (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
A,B : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.
intros.
spliter.
ex_and H1 T.
unfold IncidentL.
repeat split.
try assumption.
exists T.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H1 : Col A (P1 l) (P2 l)
H : not (Col A (P1 l) (P2 l))
A : Tpoint
l : Couple
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma cut_two_sides : forall l A B, cut l A B <-> TS (P1 l) (P2 l) A B.
Proof.
intros.
unfold cut.
unfold TS.
split.

*****

*****

+++++
Qed.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B ->\n  exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p /\ IncidentP D p.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Coplanar A B C D) (_ : not (eq A B)), ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
Proof.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Coplanar A B C D) (_ : not (eq A B)), ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
intros A B C D HCop HAB.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.

*****
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (col_dec A B C) as [|HNCol].
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].

*****
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (col_dec A B D) as [|HNCol].
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].

*****
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (not_col_exists A B HAB) as [E HNCol].
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].

*****
HNCol : not (Col A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
apply ncols_coincide in HNCol.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
exists (Plan A B E HNCol).
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP A {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (and (IncidentP B {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (and (IncidentP C {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (IncidentP D {| M1 := A; M2 := B; M3 := E; NCol := HNCol |})))
+++++
unfold IncidentP.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).
unfold IncidentP.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar (M1 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) A) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) B) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) C) (Coplanar (M1 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := E; NCol := HNCol |}) D)))
+++++
simpl.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).
unfold IncidentP.
simpl.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar A B E A) (and (Coplanar A B E B) (and (Coplanar A B E C) (Coplanar A B E D)))
+++++
repeat split.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B E A
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B E B
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B E C
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
destruct (not_col_exists A B HAB) as [E HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B E HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B E)
E : Tpoint
H0 : Col A B D
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B E D
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].

*****
HNCol : not (Col A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
apply ncols_coincide in HNCol.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
exists (Plan A B D HNCol).
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP A {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (and (IncidentP B {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (and (IncidentP C {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (IncidentP D {| M1 := A; M2 := B; M3 := D; NCol := HNCol |})))
+++++
unfold IncidentP.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).
unfold IncidentP.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar (M1 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) A) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) B) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) C) (Coplanar (M1 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := D; NCol := HNCol |}) D)))
+++++
simpl.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).
unfold IncidentP.
simpl.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar A B D A) (and (Coplanar A B D B) (and (Coplanar A B D C) (Coplanar A B D D)))
+++++
repeat split.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B D A
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B D B
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B D C
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
destruct (col_dec A B D) as [|HNCol].
apply ncols_coincide in HNCol.
exists (Plan A B D HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B D)
H : Col A B C
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B D D
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].

*****
HNCol : not (Col A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
idtac.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.

*****
HNCol : not (Col A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
apply ncols_coincide in HNCol.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
exists (Plan A B C HNCol).
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP A {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (and (IncidentP B {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (and (IncidentP C {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (IncidentP D {| M1 := A; M2 := B; M3 := C; NCol := HNCol |})))
+++++
unfold IncidentP.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) A) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) B) (and (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) C) (Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) D)))
+++++
simpl.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Coplanar A B C A) (and (Coplanar A B C B) (and (Coplanar A B C C) (Coplanar A B C D)))
+++++
repeat split.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C A
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C B
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C C
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].
idtac.
apply ncols_coincide in HNCol.
exists (Plan A B C HNCol).
unfold IncidentP.
simpl.
repeat split.

*****
HNCol : not (Col_H A B C)
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C D
+++++
Cop.
-----
Lemma cop_plane_aux : forall A B C D, Coplanar A B C D -> A <> B -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop HAB.
destruct (col_dec A B C) as [|HNCol].

*****

*****

+++++
Qed.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D ->\n  exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p /\ IncidentP D p.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Coplanar A B C D), ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
Proof.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Coplanar A B C D), ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
intros A B C D HCop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.

*****
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (eq_dec_points A B) as [|HAB].
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].

*****
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (eq_dec_points A C).
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).

*****
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (eq_dec_points A D).
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).

*****
H1 : eq A D
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (another_point D) as [E].
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].

*****
H2 : not (eq D E)
E : Tpoint
H1 : eq A D
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (cop_plane_aux D E E E) as [p []].
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].

*****
H2 : not (eq D E)
E : Tpoint
H1 : eq A D
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar D E E E
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].

*****
H2 : not (eq D E)
E : Tpoint
H1 : eq A D
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
H1 : eq A D
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
H1 : eq A D
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
subst.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.
subst.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
HCop : Coplanar D D D D
D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP D p) (and (IncidentP D p) (and (IncidentP D p) (IncidentP D p))))
+++++
exists p.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.
subst.
exists p.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
HCop : Coplanar D D D D
D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP D p) (and (IncidentP D p) (and (IncidentP D p) (IncidentP D p)))
+++++
repeat split.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.
subst.
exists p.
repeat split.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
HCop : Coplanar D D D D
D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.
subst.
exists p.
repeat split.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
HCop : Coplanar D D D D
D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.
subst.
exists p.
repeat split.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
HCop : Coplanar D D D D
D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (another_point D) as [E].
destruct (cop_plane_aux D E E E) as [p []].
Cop.
subst.
exists p.
repeat split.

*****
H4 : and (IncidentP E p) (and (IncidentP E p) (IncidentP E p))
H3 : IncidentP D p
p : Plane
H2 : not (eq D E)
E : Tpoint
HCop : Coplanar D D D D
D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).

*****
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (cop_plane_aux A D B C) as [p].
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].

*****
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A D B C
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].

*****
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].

*****
H2 : and (IncidentP A p)\n (and (IncidentP D p) (and (IncidentP B p) (IncidentP C p)))
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.

*****
H2 : and (IncidentP A p)\n (and (IncidentP D p) (and (IncidentP B p) (IncidentP C p)))
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
spliter.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.
spliter.

*****
H5 : IncidentP C p
H4 : IncidentP B p
H3 : IncidentP D p
H2 : IncidentP A p
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
exists p.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.
spliter.
exists p.

*****
H5 : IncidentP C p
H4 : IncidentP B p
H3 : IncidentP D p
H2 : IncidentP A p
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))
+++++
repeat split.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H5 : IncidentP C p
H4 : IncidentP B p
H3 : IncidentP D p
H2 : IncidentP A p
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H5 : IncidentP C p
H4 : IncidentP B p
H3 : IncidentP D p
H2 : IncidentP A p
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H5 : IncidentP C p
H4 : IncidentP B p
H3 : IncidentP D p
H2 : IncidentP A p
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
destruct (eq_dec_points A D).
destruct (cop_plane_aux A D B C) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H5 : IncidentP C p
H4 : IncidentP B p
H3 : IncidentP D p
H2 : IncidentP A p
p : Plane
H1 : not (eq A D)
H0 : eq A C
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).

*****
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
idtac.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.

*****
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
destruct (cop_plane_aux A C B D) as [p].
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].

*****
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A C B D
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].

*****
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].

*****
H1 : and (IncidentP A p)\n (and (IncidentP C p) (and (IncidentP B p) (IncidentP D p)))
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
Cop.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.

*****
H1 : and (IncidentP A p)\n (and (IncidentP C p) (and (IncidentP B p) (IncidentP D p)))
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
spliter.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.
spliter.

*****
H4 : IncidentP D p
H3 : IncidentP B p
H2 : IncidentP C p
H1 : IncidentP A p
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
exists p.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.
spliter.
exists p.

*****
H4 : IncidentP D p
H3 : IncidentP B p
H2 : IncidentP C p
H1 : IncidentP A p
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))
+++++
repeat split.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H4 : IncidentP D p
H3 : IncidentP B p
H2 : IncidentP C p
H1 : IncidentP A p
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H4 : IncidentP D p
H3 : IncidentP B p
H2 : IncidentP C p
H1 : IncidentP A p
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H4 : IncidentP D p
H3 : IncidentP B p
H2 : IncidentP C p
H1 : IncidentP A p
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
destruct (eq_dec_points A C).
idtac.
destruct (cop_plane_aux A C B D) as [p].
Cop.
spliter.
exists p.
repeat split.

*****
H4 : IncidentP D p
H3 : IncidentP B p
H2 : IncidentP C p
H1 : IncidentP A p
p : Plane
H0 : not (eq A C)
H : eq A B
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
assumption.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].

*****
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
idtac.
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].
idtac.

*****
HAB : not (eq A B)
HCop : Coplanar A B C D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p))))
+++++
apply (cop_plane_aux A B C D HCop HAB).
-----
Lemma cop_plane : forall A B C D, Coplanar A B C D -> exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p.
Proof.
intros A B C D HCop.
destruct (eq_dec_points A B) as [|HAB].

*****

*****

+++++
Qed.
-----
Lemma plane_cop: forall A B C D p,\n  IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (p : Plane) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentP D p), Coplanar A B C D
+++++
Proof.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (p : Plane) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentP D p), Coplanar A B C D
+++++
unfold IncidentP.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (p : Plane) (_ : Coplanar (M1 p) (M2 p) (M3 p) A) (_ : Coplanar (M1 p) (M2 p) (M3 p) B) (_ : Coplanar (M1 p) (M2 p) (M3 p) C) (_ : Coplanar (M1 p) (M2 p) (M3 p) D), Coplanar A B C D
+++++
intros A B C D p HA HB HC HD.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.

*****
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C D
+++++
assert (HNCol := NCol p).
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).

*****
HNCol : not (Col_H (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C D
+++++
apply ncols_coincide in HNCol.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.

*****
HNCol : not (Col (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C D
+++++
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
HNCol : not (Col (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col (M1 p) (M2 p) (M3 p))
+++++
assumption.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
HNCol : not (Col (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) A
+++++
assumption.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
HNCol : not (Col (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) B
+++++
assumption.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
HNCol : not (Col (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) C
+++++
assumption.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****
HNCol : not (Col (M1 p) (M2 p) (M3 p))
HD : Coplanar (M1 p) (M2 p) (M3 p) D
HC : Coplanar (M1 p) (M2 p) (M3 p) C
HB : Coplanar (M1 p) (M2 p) (M3 p) B
HA : Coplanar (M1 p) (M2 p) (M3 p) A
p : Plane
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 p) (M2 p) (M3 p) D
+++++
assumption.
-----
Lemma plane_cop: forall A B C D p, IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentP D p -> Coplanar A B C D.
Proof.
unfold IncidentP.
intros A B C D p HA HB HC HD.
assert (HNCol := NCol p).
apply ncols_coincide in HNCol.
apply coplanar_pseudo_trans with (M1 p) (M2 p) (M3 p).

*****

*****

+++++
Qed.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C ->\n IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l ->\n cut l A B -> cut l A C \/ cut l B C.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (l : Couple) (p : Plane) (_ : not (Col_H A B C)) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentLP l p) (_ : not (IncidentL C l)) (_ : cut l A B), or (cut l A C) (cut l B C)
+++++
Proof.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (l : Couple) (p : Plane) (_ : not (Col_H A B C)) (_ : IncidentP A p) (_ : IncidentP B p) (_ : IncidentP C p) (_ : IncidentLP l p) (_ : not (IncidentL C l)) (_ : cut l A B), or (cut l A C) (cut l B C)
+++++
intros.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.

*****
H5 : cut l A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
apply cut_two_sides in H5.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.

*****
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
assert(~Col A B C).
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).

*****
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
apply ncols_coincide.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
apply ncols_coincide.

*****
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col_H A B C)
+++++
assumption.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).

*****
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
assert(HH:=H5).
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).

*****
HH : TS (P1 l) (P2 l) A B
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
unfold TS in HH.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.

*****
HH : and (not (Col A (P1 l) (P2 l)))\n (and (not (Col B (P1 l) (P2 l)))\n (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
spliter.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (IncidentL C l)
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
unfold IncidentL in H4.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
assert (HCop : Coplanar (P1 l) (P2 l) A C).
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (P1 l) (P2 l) A C
+++++
apply plane_cop with p.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP (P1 l) p
+++++
trivial.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP (P1 l) p
+++++
apply H3.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.
apply H3.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL (P1 l) l
+++++
unfold IncidentL.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.
apply H3.
unfold IncidentL.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P1 l) (P2 l)
+++++
simpl.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.
apply H3.
unfold IncidentL.
simpl.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P1 l) (P2 l)
+++++
Col.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP (P2 l) p
+++++
trivial.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP (P2 l) p
+++++
apply H3.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.
apply H3.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL (P2 l) l
+++++
unfold IncidentL.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.
apply H3.
unfold IncidentL.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P2 l) (P1 l) (P2 l)
+++++
simpl.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.
trivial.
apply H3.
unfold IncidentL.
simpl.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P2 l) (P1 l) (P2 l)
+++++
Col.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A p
+++++
trivial.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
apply plane_cop with p.

*****
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C p
+++++
trivial.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).

*****
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).

*****
HH : or (TS (P1 l) (P2 l) A C) (OS (P1 l) (P2 l) A C)
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
induction HH.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.

*****
H10 : TS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
left.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
left.

*****
H10 : TS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
cut l A C
+++++
apply <-cut_two_sides.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
left.
apply <-cut_two_sides.

*****
H10 : TS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS (P1 l) (P2 l) A C
+++++
assumption.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.

*****
H10 : OS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (cut l A C) (cut l B C)
+++++
right.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
right.

*****
H10 : OS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
cut l B C
+++++
apply <-cut_two_sides.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
right.
apply <-cut_two_sides.

*****
H10 : OS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS (P1 l) (P2 l) B C
+++++
apply l9_2.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
right.
apply <-cut_two_sides.
apply l9_2.

*****
H10 : OS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS (P1 l) (P2 l) C B
+++++
eapply l9_8_2.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
right.
apply <-cut_two_sides.
apply l9_2.
eapply l9_8_2.

*****
H10 : OS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS (P1 l) (P2 l) ?A B
+++++
apply H5.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).
assert(HH:=H5).
unfold TS in HH.
spliter.
unfold IncidentL in H4.
assert (HCop : Coplanar (P1 l) (P2 l) A C).
assert(HH:= cop__one_or_two_sides (P1 l)(P2 l) A C HCop H7 H4).
induction HH.
right.
apply <-cut_two_sides.
apply l9_2.
eapply l9_8_2.

*****
H10 : OS (P1 l) (P2 l) A C
HCop : Coplanar (P1 l) (P2 l) A C
H9 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H8 : not (Col B (P1 l) (P2 l))
H7 : not (Col A (P1 l) (P2 l))
H6 : not (Col A B C)
H5 : TS (P1 l) (P2 l) A B
H4 : not (Col C (P1 l) (P2 l))
H3 : IncidentLP l p
H2 : IncidentP C p
H1 : IncidentP B p
H0 : IncidentP A p
H : not (Col_H A B C)
p : Plane
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A C
+++++
assumption.
-----
Lemma axiom_pasch : forall A B C l p, ~ Col_H A B C -> IncidentP A p -> IncidentP B p -> IncidentP C p -> IncidentLP l p -> ~ IncidentL C l -> cut l A B -> cut l A C \\/ cut l B C.
Proof.
intros.
apply cut_two_sides in H5.
assert(~Col A B C).

*****

*****

+++++
Qed.
-----
Lemma Incid_line :\n forall P A B l, A<>B ->\n IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (l : Couple) (_ : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l) (_ : Col P A B), IncidentL P l
+++++
Proof.
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (l : Couple) (_ : not (eq A B)) (_ : IncidentL A l) (_ : IncidentL B l) (_ : Col P A B), IncidentL P l
+++++
intros.
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
Proof.
intros.

*****
H2 : Col P A B
H1 : IncidentL B l
H0 : IncidentL A l
H : not (eq A B)
l : Couple
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL P l
+++++
unfold IncidentL in *.
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
Proof.
intros.
unfold IncidentL in *.

*****
H2 : Col P A B
H1 : Col B (P1 l) (P2 l)
H0 : Col A (P1 l) (P2 l)
H : not (eq A B)
l : Couple
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P (P1 l) (P2 l)
+++++
destruct l as [C D HCD].
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
Proof.
intros.
unfold IncidentL in *.
destruct l as [C D HCD].

*****
H2 : Col P A B
H1 : Col B (P1 {| P1 := C; P2 := D; Cond := HCD |})\n (P2 {| P1 := C; P2 := D; Cond := HCD |})
H0 : Col A (P1 {| P1 := C; P2 := D; Cond := HCD |})\n (P2 {| P1 := C; P2 := D; Cond := HCD |})
H : not (eq A B)
HCD : not (eq C D)
P,A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P (P1 {| P1 := C; P2 := D; Cond := HCD |}) (P2 {| P1 := C; P2 := D; Cond := HCD |})
+++++
simpl in *.
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
Proof.
intros.
unfold IncidentL in *.
destruct l as [C D HCD].
simpl in *.

*****
H2 : Col P A B
H1 : Col B C D
H0 : Col A C D
H : not (eq A B)
HCD : not (eq C D)
P,A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P C D
+++++
ColR.
-----
Lemma Incid_line : forall P A B l, A<>B -> IncidentL A l -> IncidentL B l -> Col P A B -> IncidentL P l.
Proof.
intros.
unfold IncidentL in *.
destruct l as [C D HCD].
simpl in *.
ColR.

*****

*****

+++++
Qed.
-----
Definition outH := fun P A B => Between_H P A B \/ Between_H P B A \/ (P <> A /\ A = B).
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : Out P A B), outH P A B
+++++
unfold Out.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))), outH P A B
+++++
unfold outH.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))), or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
intros.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.

*****
H : and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
spliter.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.

*****
H1 : or (Bet P A B) (Bet P B A)
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
induction H1.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.

*****
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
induction (eq_dec_points A B).
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).

*****
H2 : eq A B
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
right.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.

*****
H2 : eq A B
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P B A) (and (not (eq P A)) (eq A B))
+++++
right.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
right.

*****
H2 : eq A B
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq P A)) (eq A B)
+++++
split.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
right.
split.

*****
H2 : eq A B
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
right.
split.

*****
H2 : eq A B
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
left.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
left.

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H P A B
+++++
unfold Between_H.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
left.
unfold Between_H.

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet P A B) (and (not (eq P A)) (and (not (eq A B)) (not (eq P B))))
+++++
repeat split.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P A B
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P A B
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P B)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.

*****
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
induction (eq_dec_points A B).
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).

*****
H2 : eq A B
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
right.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.

*****
H2 : eq A B
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P B A) (and (not (eq P A)) (eq A B))
+++++
right.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
right.

*****
H2 : eq A B
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq P A)) (eq A B)
+++++
split.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
right.
split.

*****
H2 : eq A B
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
right.
split.

*****
H2 : eq A B
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A B
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
+++++
right.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Between_H P B A) (and (not (eq P A)) (eq A B))
+++++
left.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
left.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H P B A
+++++
unfold Between_H.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
left.
unfold Between_H.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet P B A) (and (not (eq P B)) (and (not (eq B A)) (not (eq P A))))
+++++
repeat split.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P B A
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P B)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.
induction (eq_dec_points A B).
right.
left.
unfold Between_H.
repeat split.

*****
H2 : not (eq A B)
H1 : Bet P B A
H0 : not (eq B P)
H : not (eq A P)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
auto.
-----
Lemma out_outH : forall P A B, Out P A B -> outH P A B.
unfold Out.
unfold outH.
intros.
spliter.
induction H1.

*****

*****

+++++
Qed.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l,\n  A <> B -> A' <> P ->\n  IncidentL A' l -> IncidentL P l ->\n  exists B', IncidentL B' l /\ outH A' P B' /\ Cong A' B' A B.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B A' P : Tpoint) (l : Couple) (_ : not (eq A B)) (_ : not (eq A' P)) (_ : IncidentL A' l) (_ : IncidentL P l), ex (fun B' : Tpoint => and (IncidentL B' l) (and (outH A' P B') (Cong A' B' A B)))
+++++
Proof.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B A' P : Tpoint) (l : Couple) (_ : not (eq A B)) (_ : not (eq A' P)) (_ : IncidentL A' l) (_ : IncidentL P l), ex (fun B' : Tpoint => and (IncidentL B' l) (and (outH A' P B') (Cong A' B' A B)))
+++++
intros.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.

*****
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (IncidentL B' l) (and (outH A' P B') (Cong A' B' A B)))
+++++
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].

*****
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A')
+++++
auto.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].

*****
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (IncidentL B' l) (and (outH A' P B') (Cong A' B' A B)))
+++++
auto.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (IncidentL B' l) (and (outH A' P B') (Cong A' B' A B)))
+++++
exists B'.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (IncidentL B' l) (and (outH A' P B') (Cong A' B' A B))
+++++
repeat split.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B' l
+++++
try apply out_outH, l6_6.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B' l
+++++
auto.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.
auto.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B' l
+++++
unfold IncidentL in *.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.
auto.
unfold IncidentL in *.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : Col P (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B' (P1 l) (P2 l)
+++++
destruct l.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.
auto.
unfold IncidentL in *.
destruct l.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : Col P (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
H1 : Col A' (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
H0 : not (eq A' P)
H : not (eq A B)
Cond : not (eq P1 P2)
A,B,A',P,P1,P2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B' (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |}) (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
+++++
simpl in *.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.
auto.
unfold IncidentL in *.
destruct l.
simpl in *.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : Col P P1 P2
H1 : Col A' P1 P2
H0 : not (eq A' P)
H : not (eq A B)
Cond : not (eq P1 P2)
A,B,A',P,P1,P2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B' P1 P2
+++++
ColR.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH A' P B'
+++++
try apply out_outH, l6_6.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A' B' P
+++++
auto.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A' B' A B
+++++
try apply out_outH, l6_6.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].
auto.
exists B'.
repeat split.
try apply out_outH, l6_6.

*****
HCong : Cong A' B' A B
HOut : Out A' B' P
B' : Tpoint
H2 : IncidentL P l
H1 : IncidentL A' l
H0 : not (eq A' P)
H : not (eq A B)
l : Couple
A,B,A',P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A' B' A B
+++++
auto.
-----
Lemma axiom_hcong_1_existence : forall A B A' P l, A <> B -> A' <> P -> IncidentL A' l -> IncidentL P l -> exists B', IncidentL B' l /\\ outH A' P B' /\\ Cong A' B' A B.
Proof.
intros.
destruct (l6_11_existence A' A B P) as [B' [HOut HCong]].

*****

*****

+++++
Qed.
-----
Lemma axiom_hcong_1_uniqueness :\n forall A B l M A' B' A'' B'', A <> B -> IncidentL M l ->\n  IncidentL A' l -> IncidentL B' l ->\n  IncidentL A'' l -> IncidentL B'' l ->\n  Between_H A' M B' -> Cong M A' A B ->\n  Cong M B' A B -> Between_H A'' M B'' ->\n  Cong M A'' A B -> Cong M B'' A B ->\n  (A' = A'' /\ B' = B'') \/ (A' = B'' /\ B' = A'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (M A' B' A'' B'' : Tpoint) (_ : not (eq A B)) (_ : IncidentL M l) (_ : IncidentL A' l) (_ : IncidentL B' l) (_ : IncidentL A'' l) (_ : IncidentL B'' l) (_ : Between_H A' M B') (_ : Cong M A' A B) (_ : Cong M B' A B) (_ : Between_H A'' M B'') (_ : Cong M A'' A B) (_ : Cong M B'' A B), or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
Proof.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (M A' B' A'' B'' : Tpoint) (_ : not (eq A B)) (_ : IncidentL M l) (_ : IncidentL A' l) (_ : IncidentL B' l) (_ : IncidentL A'' l) (_ : IncidentL B'' l) (_ : Between_H A' M B') (_ : Cong M A' A B) (_ : Cong M B' A B) (_ : Between_H A'' M B'') (_ : Cong M A'' A B) (_ : Cong M B'' A B), or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
unfold Between_H.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (M A' B' A'' B'' : Tpoint) (_ : not (eq A B)) (_ : IncidentL M l) (_ : IncidentL A' l) (_ : IncidentL B' l) (_ : IncidentL A'' l) (_ : IncidentL B'' l) (_ : and (Bet A' M B') (and (not (eq A' M)) (and (not (eq M B')) (not (eq A' B'))))) (_ : Cong M A' A B) (_ : Cong M B' A B) (_ : and (Bet A'' M B'') (and (not (eq A'' M)) (and (not (eq M B'')) (not (eq A'' B''))))) (_ : Cong M A'' A B) (_ : Cong M B'' A B), or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
unfold IncidentL.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (M A' B' A'' B'' : Tpoint) (_ : not (eq A B)) (_ : Col M (P1 l) (P2 l)) (_ : Col A' (P1 l) (P2 l)) (_ : Col B' (P1 l) (P2 l)) (_ : Col A'' (P1 l) (P2 l)) (_ : Col B'' (P1 l) (P2 l)) (_ : and (Bet A' M B') (and (not (eq A' M)) (and (not (eq M B')) (not (eq A' B'))))) (_ : Cong M A' A B) (_ : Cong M B' A B) (_ : and (Bet A'' M B'') (and (not (eq A'' M)) (and (not (eq M B'')) (not (eq A'' B''))))) (_ : Cong M A'' A B) (_ : Cong M B'' A B), or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
intros.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H8 : and (Bet A'' M B'')\n (and (not (eq A'' M)) (and (not (eq M B'')) (not (eq A'' B''))))
H7 : Cong M B' A B
H6 : Cong M A' A B
H5 : and (Bet A' M B')\n (and (not (eq A' M)) (and (not (eq M B')) (not (eq A' B'))))
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
spliter.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
assert(A' <> M /\ A'' <> M /\ B' <> M /\ B'' <> M /\ A' <> B' /\ A'' <> B'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A' M)) (and (not (eq A'' M)) (and (not (eq B' M)) (and (not (eq B'' M)) (and (not (eq A' B')) (not (eq A'' B''))))))
+++++
repeat split.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A' M)
+++++
intro.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.

*****
H17 : eq A' M
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.
treat_equalities.

*****
H15 : not (eq A' A')
H0 : Col A' (P1 l) (P2 l)
H : not (eq A A)
A' : Tpoint
l : Couple
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A'' M)
+++++
intro.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.

*****
H17 : eq A'' M
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.
treat_equalities.

*****
H15 : not (eq A'' A'')
H0 : Col A'' (P1 l) (P2 l)
H : not (eq A A)
A'' : Tpoint
l : Couple
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' M)
+++++
intro.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.

*****
H17 : eq B' M
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.
treat_equalities.

*****
H15 : not (eq B' B')
H0 : Col B' (P1 l) (P2 l)
H : not (eq A A)
B' : Tpoint
l : Couple
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' M)
+++++
intro.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.

*****
H17 : eq B'' M
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.
treat_equalities.

*****
H15 : not (eq B'' B'')
H0 : Col B'' (P1 l) (P2 l)
H : not (eq A A)
B'' : Tpoint
l : Couple
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A' B')
+++++
intro.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.

*****
H17 : eq A' B'
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.
treat_equalities.

*****
H14 : not (eq A' A')
H0 : Col A' (P1 l) (P2 l)
H : not (eq A A)
A' : Tpoint
l : Couple
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.

*****
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A'' B'')
+++++
intro.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.

*****
H17 : eq A'' B''
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
repeat split.
intro.
treat_equalities.

*****
H15 : not (eq A'' A'')
H0 : Col A'' (P1 l) (P2 l)
H : not (eq A A)
A'' : Tpoint
l : Couple
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').

*****
H17 : and (not (eq A' M))\n (and (not (eq A'' M))\n (and (not (eq B' M))\n (and (not (eq B'' M)) (and (not (eq A' B')) (not (eq A'' B''))))))
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
spliter.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.

*****
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
induction(out_dec M A' A'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
left.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (eq A' A'') (eq B' B'')
+++++
assert(A' = A'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A' A''
+++++
eapply (l6_11_uniqueness M A B A'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A'' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A' A''
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M A' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A'' A''
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').
try assumption.

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A'' A''
+++++
apply out_trivial.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').
try assumption.
apply out_trivial.

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A'' M)
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
eapply (l6_11_uniqueness M A B A'').

*****
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M A'' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').

*****
H24 : eq A' A''
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (eq A' A'') (eq B' B'')
+++++
split.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.

*****
H24 : eq A' A''
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A' A''
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.

*****
H24 : eq A' A''
H23 : Out M A' A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B' B''
+++++
subst A''.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B' B''
+++++
eapply (l6_11_uniqueness M A B B'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B' B''
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B' B''
+++++
unfold Out.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq B' M)) (and (not (eq B'' M)) (or (Bet M B' B'') (Bet M B'' B')))
+++++
repeat split.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet M B' B'') (Bet M B'' B')
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.
try assumption.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet M B' B'') (Bet M B'' B')
+++++
eapply l5_2.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq ?A M)
+++++
apply H18.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' M B'
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' M B''
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M B' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B'' B''
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B'' B''
+++++
apply out_trivial.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').
try assumption.
apply out_trivial.

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' M)
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
left.
assert(A' = A'').
split.
subst A''.
eapply (l6_11_uniqueness M A B B'').

*****
H22 : not (eq A' B'')
H23 : Out M A' A'
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H17,H18 : not (eq A' M)
H10 : Cong M B'' A B
H13 : not (eq A' B'')
H9 : Cong M A' A B
H12 : not (eq M B'')
H8 : Bet A' M B''
H11 : not (eq A' M)
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M B'' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (eq A' A'') (eq B' B'')) (and (eq A' B'') (eq B' A''))
+++++
right.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (eq A' B'') (eq B' A'')
+++++
apply not_out_bet in H23.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (eq A' B'') (eq B' A'')
+++++
assert(A' = B'').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A' B''
+++++
eapply (l6_11_uniqueness M A B A').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A' A'
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A' A'
+++++
apply out_trivial.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
apply out_trivial.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A' M)
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M A' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B'' A'
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B'' A'
+++++
unfold Out.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq B'' M)) (and (not (eq A' M)) (or (Bet M B'' A') (Bet M A' B'')))
+++++
repeat split.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet M B'' A') (Bet M A' B'')
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.
try assumption.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet M B'' A') (Bet M A' B'')
+++++
eapply l5_2.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq ?A M)
+++++
apply H18.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A'' M B''
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A'' M A'
+++++
apply between_symmetry.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.
apply between_symmetry.

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' M A''
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
eapply (l6_11_uniqueness M A B A').

*****
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M B'' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').

*****
H24 : eq A' B''
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (eq A' B'') (eq B' A'')
+++++
split.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.

*****
H24 : eq A' B''
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A' B''
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.

*****
H24 : eq A' B''
H23 : Bet A' M A''
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B' A''
+++++
subst B''.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B' A''
+++++
eapply (l6_11_uniqueness M A B B').
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B' B'
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M B' B'
+++++
apply out_trivial.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
apply out_trivial.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' M)
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M B' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A'' B'
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out M A'' B'
+++++
unfold Out.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A'' M)) (and (not (eq B' M)) (or (Bet M A'' B') (Bet M B' A'')))
+++++
repeat split.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A'' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' M)
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet M A'' B') (Bet M B' A'')
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.
try assumption.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet M A'' B') (Bet M B' A'')
+++++
eapply l5_2.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq ?A M)
+++++
apply H20.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' M A''
+++++
apply between_symmetry.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.
apply between_symmetry.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A'' M A'
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').
try assumption.
unfold Out.
repeat split.
try assumption.
eapply l5_2.

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' M B'
+++++
assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
assert(A' = B'').
split.
subst B''.
eapply (l6_11_uniqueness M A B B').

*****
H23 : Bet A' M A''
H22 : not (eq A'' A')
H21 : not (eq A' B')
H20 : not (eq A' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M A' A B
H9 : Cong M A'' A B
H12 : not (eq M A')
H13 : not (eq A'' A')
H11 : not (eq A'' M)
H8 : Bet A'' M A'
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col A' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M A'' A B
+++++
try assumption.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A' M A''
+++++
eapply col3.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
eapply col3.

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq ?X ?Y)
+++++
apply (Cond l).
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
eapply col3.

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) A'
+++++
Col.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
eapply col3.

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) M
+++++
Col.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').
spliter.
induction(out_dec M A' A'').
right.
apply not_out_bet in H23.
eapply col3.

*****
H23 : not (Out M A' A'')
H22 : not (eq A'' B'')
H21 : not (eq A' B')
H20 : not (eq B'' M)
H19 : not (eq B' M)
H18 : not (eq A'' M)
H17 : not (eq A' M)
H10 : Cong M B'' A B
H9 : Cong M A'' A B
H13 : not (eq A'' B'')
H12 : not (eq M B'')
H11 : not (eq A'' M)
H8 : Bet A'' M B''
H7 : Cong M B' A B
H6 : Cong M A' A B
H16 : not (eq A' B')
H15 : not (eq M B')
H14 : not (eq A' M)
H5 : Bet A' M B'
H4 : Col B'' (P1 l) (P2 l)
H3 : Col A'' (P1 l) (P2 l)
H2 : Col B' (P1 l) (P2 l)
H1 : Col A' (P1 l) (P2 l)
H0 : Col M (P1 l) (P2 l)
H : not (eq A B)
M,A',B',A'',B'' : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col (P1 l) (P2 l) A''
+++++
Col.
-----
Lemma axiom_hcong_1_uniqueness : forall A B l M A' B' A'' B'', A <> B -> IncidentL M l -> IncidentL A' l -> IncidentL B' l -> IncidentL A'' l -> IncidentL B'' l -> Between_H A' M B' -> Cong M A' A B -> Cong M B' A B -> Between_H A'' M B'' -> Cong M A'' A B -> Cong M B'' A B -> (A' = A'' /\\ B' = B'') \\/ (A' = B'' /\\ B' = A'').
Proof.
unfold Between_H.
unfold IncidentL.
intros.
spliter.
assert(A' <> M /\\ A'' <> M /\\ B' <> M /\\ B'' <> M /\\ A' <> B' /\\ A'' <> B'').

*****

*****

+++++
Qed.
-----
Definition same_side_scott := fun E A B => E <> A /\ E <> B /\ Col_H E A B /\ ~ Between_H A E B.
-----
Remark axiom_hcong_scott:\n forall P Q A C, A <> C -> P <> Q ->\n  exists B, same_side_scott A B C  /\ Cong P Q A B.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A C : Tpoint) (_ : not (eq A C)) (_ : not (eq P Q)), ex (fun B : Tpoint => and (same_side_scott A B C) (Cong P Q A B))
+++++
Proof.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A C : Tpoint) (_ : not (eq A C)) (_ : not (eq P Q)), ex (fun B : Tpoint => and (same_side_scott A B C) (Cong P Q A B))
+++++
intros.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.

*****
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (same_side_scott A B C) (Cong P Q A B))
+++++
unfold same_side_scott.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.

*****
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (and (not (eq A B)) (and (not (eq A C)) (and (Col_H A B C) (not (Between_H B A C))))) (Cong P Q A B))
+++++
assert (exists X : Tpoint, Out A X C /\ Cong A X P Q).
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).

*****
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Out A X C) (Cong A X P Q))
+++++
apply l6_11_existence.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
apply l6_11_existence.

*****
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
auto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
apply l6_11_existence.

*****
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
auto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).

*****
H1 : ex (fun X : Tpoint => and (Out A X C) (Cong A X P Q))
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (and (not (eq A B)) (and (not (eq A C)) (and (Col_H A B C) (not (Between_H B A C))))) (Cong P Q A B))
+++++
decompose [ex and] H1.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H1 : ex (fun X : Tpoint => and (Out A X C) (Cong A X P Q))
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (and (not (eq A B)) (and (not (eq A C)) (and (Col_H A B C) (not (Between_H B A C))))) (Cong P Q A B))
+++++
clear H1.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (and (not (eq A B)) (and (not (eq A C)) (and (Col_H A B C) (not (Between_H B A C))))) (Cong P Q A B))
+++++
exists x.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (not (eq A x)) (and (not (eq A C)) (and (Col_H A x C) (not (Between_H x A C))))) (Cong P Q A x)
+++++
repeat split.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A x)
+++++
unfold Out in H3.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.

*****
H4 : Cong A x P Q
H3 : and (not (eq x A)) (and (not (eq C A)) (or (Bet A x C) (Bet A C x)))
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A x)
+++++
intuition.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
unfold Out in H3.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.

*****
H4 : Cong A x P Q
H3 : and (not (eq x A)) (and (not (eq C A)) (or (Bet A x C) (Bet A C x)))
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intuition.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A x C
+++++
apply cols_coincide_2.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
apply cols_coincide_2.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A x C
+++++
apply out_col.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
apply cols_coincide_2.
apply out_col.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A x C
+++++
assumption.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Between_H x A C)
+++++
unfold Out in H3.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.

*****
H4 : Cong A x P Q
H3 : and (not (eq x A)) (and (not (eq C A)) (or (Bet A x C) (Bet A C x)))
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Between_H x A C)
+++++
unfold Between_H.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.

*****
H4 : Cong A x P Q
H3 : and (not (eq x A)) (and (not (eq C A)) (or (Bet A x C) (Bet A C x)))
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (and (Bet x A C) (and (not (eq x A)) (and (not (eq A C)) (not (eq x C)))))
+++++
intro.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.

*****
H1 : and (Bet x A C)\n (and (not (eq x A)) (and (not (eq A C)) (not (eq x C))))
H4 : Cong A x P Q
H3 : and (not (eq x A)) (and (not (eq C A)) (or (Bet A x C) (Bet A C x)))
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
decompose [and] H3.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.

*****
H7 : or (Bet A x C) (Bet A C x)
H6 : not (eq C A)
H2 : not (eq x A)
H1 : and (Bet x A C)\n (and (not (eq x A)) (and (not (eq A C)) (not (eq x C))))
H4 : Cong A x P Q
H3 : and (not (eq x A)) (and (not (eq C A)) (or (Bet A x C) (Bet A C x)))
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
clear H3.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.

*****
H7 : or (Bet A x C) (Bet A C x)
H6 : not (eq C A)
H2 : not (eq x A)
H1 : and (Bet x A C)\n (and (not (eq x A)) (and (not (eq A C)) (not (eq x C))))
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
decompose [and] H1.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H8 : not (eq x A)
H3 : Bet x A C
H7 : or (Bet A x C) (Bet A C x)
H6 : not (eq C A)
H2 : not (eq x A)
H1 : and (Bet x A C)\n (and (not (eq x A)) (and (not (eq A C)) (not (eq x C))))
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
clear H1.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H8 : not (eq x A)
H3 : Bet x A C
H7 : or (Bet A x C) (Bet A C x)
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
clear H8.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H7 : or (Bet A x C) (Bet A C x)
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct H7.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A x C
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (A = x).
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = x).

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A x C
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A x
+++++
eapply between_equality.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = x).
eapply between_equality.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A x C
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A x ?C
+++++
eauto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = x).
eapply between_equality.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A x C
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet x A C
+++++
eauto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = x).

*****
H7 : eq A x
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A x C
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (A = C).
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = C).

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A C
+++++
eapply between_equality.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = C).
eapply between_equality.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C ?C
+++++
eauto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = C).
eapply between_equality.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C A x
+++++
eauto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = C).
eapply between_equality.
eauto.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C A x
+++++
apply between_symmetry.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = C).
eapply between_equality.
eauto.
apply between_symmetry.

*****
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet x A C
+++++
auto.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.
unfold Out in H3.
unfold Between_H.
intro.
decompose [and] H3.
clear H3.
decompose [and] H1.
clear H1.
clear H8.
destruct H7.
assert (A = C).

*****
H7 : eq A C
H10 : not (eq x C)
H5 : not (eq A C)
H3 : Bet x A C
H1 : Bet A C x
H6 : not (eq C A)
H2 : not (eq x A)
H4 : Cong A x P Q
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).
decompose [ex and] H1.
clear H1.
exists x.
repeat split.

*****
H4 : Cong A x P Q
H3 : Out A x C
x : Tpoint
H0 : not (eq P Q)
H : not (eq A C)
P,Q,A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P Q A x
+++++
Cong.
-----
Remark axiom_hcong_scott: forall P Q A C, A <> C -> P <> Q -> exists B, same_side_scott A B C /\\ Cong P Q A B.
Proof.
intros.
unfold same_side_scott.
assert (exists X : Tpoint, Out A X C /\\ Cong A X P Q).

*****

*****

+++++
Qed.
-----
Definition disjoint := fun A B C D => ~ exists P, Between_H A P B /\ Between_H C P D.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Col_H A B C) (_ : disjoint A B B C), Bet A B C
+++++
Proof.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Col_H A B C) (_ : disjoint A B B C), Bet A B C
+++++
intros.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.

*****
H0 : disjoint A B B C
H : Col_H A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
apply cols_coincide_1 in H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.

*****
H0 : disjoint A B B C
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
unfold disjoint in H0.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.

*****
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
induction (eq_dec_points A B).
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).

*****
H1 : eq A B
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
subst B.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
subst B.

*****
H : Col A A C
H0 : not (ex (fun P : Tpoint => and (Between_H A P A) (Between_H A P C)))
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A A C
+++++
apply between_trivial2.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).

*****
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
induction (eq_dec_points B C).
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).

*****
H2 : eq B C
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
subst C.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
subst C.

*****
H1 : not (eq A B)
H : Col A B B
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P B)))
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B B
+++++
apply between_trivial.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Col A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
unfold Col in H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
induction H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : or (Bet B C A) (Bet C A B)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
induction H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
apply False_ind.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H0.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C))
+++++
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).

*****
H3 : ex (fun M : Tpoint => Midpoint M B C)
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C))
+++++
ex_and H3 M.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.

*****
H4 : Midpoint M B C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C))
+++++
exists M.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.

*****
H4 : Midpoint M B C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Between_H A M B) (Between_H B M C)
+++++
unfold Midpoint in H4.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.

*****
H4 : and (Bet B M C) (Cong B M M C)
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Between_H A M B) (Between_H B M C)
+++++
spliter.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Between_H A M B) (Between_H B M C)
+++++
split.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H A M B
+++++
unfold Between_H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A M B) (and (not (eq A M)) (and (not (eq M B)) (not (eq A B))))
+++++
repeat split.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
apply between_symmetry.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
apply between_symmetry.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B M A
+++++
eapply between_exchange4.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
apply between_symmetry.
eapply between_exchange4.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B M ?C
+++++
apply H3.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
apply between_symmetry.
eapply between_exchange4.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B C A
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A M)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq A M
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H0 : not (ex (fun P : Tpoint => and (Between_H B P B) (Between_H B P B)))
H1 : not (eq B B)
B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M B)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq M B
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H0 : not (ex (fun P : Tpoint => and (Between_H A P M) (Between_H M P M)))
H1 : not (eq A M)
H2 : not (eq M M)
A,M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H B M C
+++++
unfold Between_H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B M C) (and (not (eq B M)) (and (not (eq M C)) (not (eq B C))))
+++++
repeat split.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B M C
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B M)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq B M
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H2 : not (eq B B)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P B)))
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M C)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq M C
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H2 : not (eq B B)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P B)))
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M B C) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong B M M C
H3 : Bet B M C
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet B C A
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
apply False_ind.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H0.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.

*****
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C))
+++++
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).

*****
H3 : ex (fun M : Tpoint => Midpoint M A B)
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C))
+++++
ex_and H3 M.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.

*****
H4 : Midpoint M A B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C))
+++++
exists M.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.

*****
H4 : Midpoint M A B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Between_H A M B) (Between_H B M C)
+++++
unfold Midpoint in H4.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.

*****
H4 : and (Bet A M B) (Cong A M M B)
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Between_H A M B) (Between_H B M C)
+++++
spliter.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Between_H A M B) (Between_H B M C)
+++++
split.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H A M B
+++++
unfold Between_H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A M B) (and (not (eq A M)) (and (not (eq M B)) (not (eq A B))))
+++++
repeat split.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A M)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq A M
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H0 : not (ex (fun P : Tpoint => and (Between_H A P A) (Between_H A P C)))
H1 : not (eq A A)
H2 : not (eq A C)
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M B)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq M B
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H2 : not (eq A C)
H1 : not (eq A A)
H0 : not (ex (fun P : Tpoint => and (Between_H A P A) (Between_H A P C)))
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H B M C
+++++
unfold Between_H.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B M C) (and (not (eq B M)) (and (not (eq M C)) (not (eq B C))))
+++++
repeat split.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B M C
+++++
eapply between_exchange4.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
eapply between_exchange4.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B M ?C
+++++
apply between_symmetry.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
eapply between_exchange4.
apply between_symmetry.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet ?C M B
+++++
apply H3.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
eapply between_exchange4.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A C
+++++
apply between_symmetry.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
eapply between_exchange4.
apply between_symmetry.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C A B
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B M)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq B M
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H0 : not (ex (fun P : Tpoint => and (Between_H A P A) (Between_H A P C)))
H1 : not (eq A A)
H2 : not (eq A C)
A,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
tauto.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M C)
+++++
intro.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.

*****
H5 : eq M C
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.
intro.
treat_equalities.

*****
H0 : not (ex (fun P : Tpoint => and (Between_H A P A) (Between_H A P A)))
H1 : not (eq A A)
A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).
induction (eq_dec_points B C).
unfold Col in H.
induction H.
induction H.
apply False_ind.
apply H0.
assert(exists M, Midpoint M A B) by(apply midpoint_existence).
ex_and H3 M.
exists M.
unfold Midpoint in H4.
spliter.
split.
unfold Between_H.
repeat split.

*****
H4 : Cong A M M B
H3 : Bet A M B
M : Tpoint
H2 : not (eq B C)
H1 : not (eq A B)
H0 : not (ex (fun P : Tpoint => and (Between_H A P B) (Between_H B P C)))
H : Bet C A B
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
assumption.
-----
Lemma col_disjoint_bet : forall A B C, Col_H A B C -> disjoint A B B C -> Bet A B C.
Proof.
intros.
apply cols_coincide_1 in H.
unfold disjoint in H0.
induction (eq_dec_points A B).

*****

*****

+++++
Qed.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C',\n   Col_H A B C -> Col_H A' B' C' ->\n  disjoint A B B C -> disjoint A' B' B' C' ->\n  Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C A' B' C' : Tpoint) (_ : Col_H A B C) (_ : Col_H A' B' C') (_ : disjoint A B B C) (_ : disjoint A' B' B' C') (_ : Cong A B A' B') (_ : Cong B C B' C'), Cong A C A' C'
+++++
Proof.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C A' B' C' : Tpoint) (_ : Col_H A B C) (_ : Col_H A' B' C') (_ : disjoint A B B C) (_ : disjoint A' B' B' C') (_ : Cong A B A' B') (_ : Cong B C B' C'), Cong A C A' C'
+++++
intros.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.

*****
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C A' C'
+++++
assert(Bet A B C).
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).

*****
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
eapply col_disjoint_bet.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
eapply col_disjoint_bet.

*****
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A B C
+++++
assumption.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
eapply col_disjoint_bet.

*****
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
disjoint A B B C
+++++
assumption.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).

*****
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C A' C'
+++++
assert(Bet A' B' C').
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').

*****
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' B' C'
+++++
eapply col_disjoint_bet.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').
eapply col_disjoint_bet.

*****
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A' B' C'
+++++
assumption.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').
eapply col_disjoint_bet.

*****
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
disjoint A' B' B' C'
+++++
assumption.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').

*****
H6 : Bet A' B' C'
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C A' C'
+++++
eapply l2_11.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').
eapply l2_11.

*****
H6 : Bet A' B' C'
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A ?B C
+++++
eauto.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').
eapply l2_11.

*****
H6 : Bet A' B' C'
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A' ?B' C'
+++++
eauto.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').
eapply l2_11.

*****
H6 : Bet A' B' C'
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A' B'
+++++
eauto.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).
assert(Bet A' B' C').
eapply l2_11.

*****
H6 : Bet A' B' C'
H5 : Bet A B C
H4 : Cong B C B' C'
H3 : Cong A B A' B'
H2 : disjoint A' B' B' C'
H1 : disjoint A B B C
H0 : Col_H A' B' C'
H : Col_H A B C
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B C B' C'
+++++
eauto.
-----
Lemma axiom_hcong_3 : forall A B C A' B' C', Col_H A B C -> Col_H A' B' C' -> disjoint A B B C -> disjoint A' B' B' C' -> Cong A B A' B' -> Cong B C B' C' -> Cong A C A' C'.
Proof.
intros.
assert(Bet A B C).

*****

*****

+++++
Qed.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall  HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (HH : not (eq A B)), ex (fun C : Tpoint => not (IncidentL C (Lin A B HH)))
+++++
Proof.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (HH : not (eq A B)), ex (fun C : Tpoint => not (IncidentL C (Lin A B HH)))
+++++
intros.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.

*****
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => not (IncidentL C (Lin A B HH)))
+++++
unfold IncidentL.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.

*****
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => not (Col C (P1 (Lin A B HH)) (P2 (Lin A B HH))))
+++++
assert(HC:=not_col_exists A B HH).
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).

*****
HC : ex (fun C : Tpoint => not (Col A B C))
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => not (Col C (P1 (Lin A B HH)) (P2 (Lin A B HH))))
+++++
ex_and HC C.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).
ex_and HC C.

*****
H : not (Col A B C)
C : Tpoint
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => not (Col C (P1 (Lin A B HH)) (P2 (Lin A B HH))))
+++++
exists C.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).
ex_and HC C.
exists C.

*****
H : not (Col A B C)
C : Tpoint
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col C (P1 (Lin A B HH)) (P2 (Lin A B HH)))
+++++
intro.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).
ex_and HC C.
exists C.
intro.

*****
H0 : Col C (P1 (Lin A B HH)) (P2 (Lin A B HH))
H : not (Col A B C)
C : Tpoint
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).
ex_and HC C.
exists C.
intro.
apply H.

*****
H0 : Col C (P1 (Lin A B HH)) (P2 (Lin A B HH))
H : not (Col A B C)
C : Tpoint
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
simpl in H0.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).
ex_and HC C.
exists C.
intro.
apply H.
simpl in H0.

*****
H0 : Col C A B
H : not (Col A B C)
C : Tpoint
HH : not (eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
Col.
-----
Lemma exists_not_incident : forall A B : Tpoint, forall HH : A <> B , exists C, ~ IncidentL C (Lin A B HH).
Proof.
intros.
unfold IncidentL.
assert(HC:=not_col_exists A B HH).
ex_and HC C.
exists C.
intro.
apply H.
simpl in H0.
Col.

*****

*****

+++++
Qed.
-----
Definition same_side := fun A B l => exists P, cut l A P /\ cut l B P.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : same_side A B l), OS (P1 l) (P2 l) A B
+++++
Proof.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : same_side A B l), OS (P1 l) (P2 l) A B
+++++
unfold same_side.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : ex (fun P : Tpoint => and (cut l A P) (cut l B P))), OS (P1 l) (P2 l) A B
+++++
intros.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.

*****
H : ex (fun P : Tpoint => and (cut l A P) (cut l B P))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A B
+++++
destruct H as [P []].
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.
destruct H as [P []].

*****
H0 : cut l B P
H : cut l A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A B
+++++
apply cut_two_sides in H.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.
destruct H as [P []].
apply cut_two_sides in H.

*****
H0 : cut l B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A B
+++++
apply cut_two_sides in H0.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.
destruct H as [P []].
apply cut_two_sides in H.
apply cut_two_sides in H0.

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A B
+++++
eapply l9_8_1.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.
destruct H as [P []].
apply cut_two_sides in H.
apply cut_two_sides in H0.
eapply l9_8_1.

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS (P1 l) (P2 l) A ?C
+++++
apply H.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.
destruct H as [P []].
apply cut_two_sides in H.
apply cut_two_sides in H0.
eapply l9_8_1.

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS (P1 l) (P2 l) B P
+++++
apply H0.
-----
Lemma same_side_one_side : forall A B l, same_side A B l -> OS (P1 l) (P2 l) A B.
Proof.
unfold same_side.
intros.
destruct H as [P []].
apply cut_two_sides in H.
apply cut_two_sides in H0.
eapply l9_8_1.

*****

*****

+++++
Qed.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : OS (P1 l) (P2 l) A B), same_side A B l
+++++
Proof.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : OS (P1 l) (P2 l) A B), same_side A B l
+++++
intros.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.

*****
H : OS (P1 l) (P2 l) A B
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
same_side A B l
+++++
unfold same_side.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.

*****
H : OS (P1 l) (P2 l) A B
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (cut l A P) (cut l B P))
+++++
unfold OS in H.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.

*****
H : ex\n (fun R : Tpoint => and (TS (P1 l) (P2 l) A R) (TS (P1 l) (P2 l) B R))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (cut l A P) (cut l B P))
+++++
destruct H as [P []].
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => and (cut l A P) (cut l B P))
+++++
exists P.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (cut l A P) (cut l B P)
+++++
unfold cut.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (not (IncidentL A l)) (and (not (IncidentL P l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H A I P))))) (and (not (IncidentL B l)) (and (not (IncidentL P l)) (ex (fun I : Tpoint => and (IncidentL I l) (Between_H B I P)))))
+++++
unfold IncidentL.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.

*****
H0 : TS (P1 l) (P2 l) B P
H : TS (P1 l) (P2 l) A P
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (not (Col A (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))))) (and (not (Col B (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P)))))
+++++
unfold TS in H.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.

*****
H0 : TS (P1 l) (P2 l) B P
H : and (not (Col A (P1 l) (P2 l)))\n (and (not (Col P (P1 l) (P2 l)))\n (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (not (Col A (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))))) (and (not (Col B (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P)))))
+++++
unfold TS in H0.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.

*****
H0 : and (not (Col B (P1 l) (P2 l)))\n (and (not (Col P (P1 l) (P2 l)))\n (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))))
H : and (not (Col A (P1 l) (P2 l)))\n (and (not (Col P (P1 l) (P2 l)))\n (ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (not (Col A (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))))) (and (not (Col B (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P)))))
+++++
spliter.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (not (Col A (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))))) (and (not (Col B (P1 l) (P2 l))) (and (not (Col P (P1 l) (P2 l))) (ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P)))))
+++++
repeat split.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A (P1 l) (P2 l))
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P (P1 l) (P2 l))
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))
+++++
ex_and H4 T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H A I P))
+++++
exists T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (Between_H A T P)
+++++
unfold Between_H.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (and (Bet A T P) (and (not (eq A T)) (and (not (eq T P)) (not (eq A P)))))
+++++
repeat split.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T (P1 l) (P2 l)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A T P
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
intro.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.

*****
H6 : eq A T
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst T.

*****
H4 : Col A (P1 l) (P2 l)
H5 : Bet A A P
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T P)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T P)
+++++
intro.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.

*****
H6 : eq T P
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst T.

*****
H4 : Col P (P1 l) (P2 l)
H5 : Bet A P P
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A P)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.

*****
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A P)
+++++
intro.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.

*****
H6 : eq A P
H5 : Bet A T P
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst P.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst P.

*****
H5 : Bet A T A
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col A (P1 l) (P2 l))
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T A))
H0 : not (Col B (P1 l) (P2 l))
H,H3 : not (Col A (P1 l) (P2 l))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply between_identity in H5.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst P.
apply between_identity in H5.

*****
H5 : eq A T
H4 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col A (P1 l) (P2 l))
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T A))
H0 : not (Col B (P1 l) (P2 l))
H,H3 : not (Col A (P1 l) (P2 l))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H4 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst P.
apply between_identity in H5.
subst T.

*****
H4 : Col A (P1 l) (P2 l)
H1 : not (Col A (P1 l) (P2 l))
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T A))
H0 : not (Col B (P1 l) (P2 l))
H,H3 : not (Col A (P1 l) (P2 l))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B (P1 l) (P2 l))
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P (P1 l) (P2 l))
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P))
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.

*****
H2 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet B T P))
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P))
+++++
ex_and H2 T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col I (P1 l) (P2 l)) (Between_H B I P))
+++++
exists T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (Between_H B T P)
+++++
unfold Between_H.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col T (P1 l) (P2 l)) (and (Bet B T P) (and (not (eq B T)) (and (not (eq T P)) (not (eq B P)))))
+++++
repeat split.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T (P1 l) (P2 l)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B T P
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B T)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B T)
+++++
intro.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.

*****
H6 : eq B T
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst T.

*****
H2 : Col B (P1 l) (P2 l)
H5 : Bet B B P
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T P)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T P)
+++++
intro.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.

*****
H6 : eq T P
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst T.

*****
H2 : Col P (P1 l) (P2 l)
H5 : Bet B P P
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B P)
+++++
auto.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.

*****
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B P)
+++++
intro.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.

*****
H6 : eq B P
H5 : Bet B T P
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H1 : not (Col P (P1 l) (P2 l))
H0 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T P))
H3 : not (Col P (P1 l) (P2 l))
H : not (Col A (P1 l) (P2 l))
P : Tpoint
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst P.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst P.

*****
H5 : Bet B T B
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H3,H0,H1 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H : not (Col A (P1 l) (P2 l))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply between_identity in H5.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst P.
apply between_identity in H5.

*****
H5 : eq B T
H2 : Col T (P1 l) (P2 l)
T : Tpoint
H3,H0,H1 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H : not (Col A (P1 l) (P2 l))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst T.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.
auto.
ex_and H2 T.
exists T.
unfold Between_H.
repeat split.
auto.
intro.
subst P.
apply between_identity in H5.
subst T.

*****
H2 : Col B (P1 l) (P2 l)
H3,H0,H1 : not (Col B (P1 l) (P2 l))
H4 : ex (fun T : Tpoint => and (Col T (P1 l) (P2 l)) (Bet A T B))
H : not (Col A (P1 l) (P2 l))
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
contradiction.
-----
Lemma one_side_same_side : forall A B l, OS (P1 l) (P2 l) A B -> same_side A B l.
Proof.
intros.
unfold same_side.
unfold OS in H.
destruct H as [P []].
exists P.
unfold cut.
unfold IncidentL.
unfold TS in H.
unfold TS in H0.
spliter.
repeat split.

*****

*****

+++++
Qed.
-----
Definition same_side' := fun A B X Y =>\n  X <> Y /\ forall l, IncidentL X l -> IncidentL Y l -> same_side A B l.
-----
Lemma OS_distinct : forall P Q A B,\n  OS P Q A B -> P<>Q.
-----
Lemma OS_distinct : forall P Q A B, OS P Q A B -> P<>Q.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A B : Tpoint) (_ : OS P Q A B), not (eq P Q)
+++++
Proof.
-----
Lemma OS_distinct : forall P Q A B, OS P Q A B -> P<>Q.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A B : Tpoint) (_ : OS P Q A B), not (eq P Q)
+++++
intros.
-----
Lemma OS_distinct : forall P Q A B, OS P Q A B -> P<>Q.
Proof.
intros.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
apply one_side_not_col123 in H.
-----
Lemma OS_distinct : forall P Q A B, OS P Q A B -> P<>Q.
Proof.
intros.
apply one_side_not_col123 in H.

*****
H : not (Col P Q A)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
assert_diffs.
-----
Lemma OS_distinct : forall P Q A B, OS P Q A B -> P<>Q.
Proof.
intros.
apply one_side_not_col123 in H.
assert_diffs.

*****
H5 : not (eq P A)
H2 : not (eq Q A)
H3 : not (eq P Q)
H : not (Col P Q A)
P,Q,A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
assumption.
-----
Lemma OS_distinct : forall P Q A B, OS P Q A B -> P<>Q.
Proof.
intros.
apply one_side_not_col123 in H.
assert_diffs.
assumption.

*****

*****

+++++
Qed.
-----
Lemma OS_same_side' :\n forall P Q A B, OS P Q A B -> same_side' A B P Q.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A B : Tpoint) (_ : OS P Q A B), same_side' A B P Q
+++++
Proof.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A B : Tpoint) (_ : OS P Q A B), same_side' A B P Q
+++++
intros.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
same_side' A B P Q
+++++
unfold same_side'.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq P Q)) (forall (l : Couple) (_ : IncidentL P l) (_ : IncidentL Q l), same_side A B l)
+++++
intros.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq P Q)) (forall (l : Couple) (_ : IncidentL P l) (_ : IncidentL Q l), same_side A B l)
+++++
split.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
apply OS_distinct with A B.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
apply OS_distinct with A B.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS P Q A B
+++++
assumption.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.

*****
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l : Couple) (_ : IncidentL P l) (_ : IncidentL Q l), same_side A B l
+++++
intros.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.

*****
H1 : IncidentL Q l
H0 : IncidentL P l
l : Couple
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
same_side A B l
+++++
apply one_side_same_side.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.

*****
H1 : IncidentL Q l
H0 : IncidentL P l
l : Couple
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A B
+++++
destruct l.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.

*****
H1 : IncidentL Q {| P1 := P1; P2 := P2; Cond := Cond |}
H0 : IncidentL P {| P1 := P1; P2 := P2; Cond := Cond |}
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |}) (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |}) A B
+++++
unfold IncidentL in *.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.

*****
H1 : Col Q (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
H0 : Col P (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |}) (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |}) A B
+++++
simpl in *.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS P1 P2 A B
+++++
apply col2_os__os with P Q.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P Q.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P1 P2)
+++++
try assumption.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P Q.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q P1
+++++
try assumption.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P Q.
try assumption.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q P1
+++++
ColR.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P Q.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q P2
+++++
try assumption.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P Q.
try assumption.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q P2
+++++
ColR.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.
intros.
apply one_side_same_side.
destruct l.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P Q.

*****
H1 : Col Q P1 P2
H0 : Col P P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H : OS P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS P Q A B
+++++
try assumption.
-----
Lemma OS_same_side' : forall P Q A B, OS P Q A B -> same_side' A B P Q.
Proof.
intros.
unfold same_side'.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma same_side_OS :\n forall P Q A B, same_side' P Q A B -> OS A B P Q.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A B : Tpoint) (_ : same_side' P Q A B), OS A B P Q
+++++
Proof.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q A B : Tpoint) (_ : same_side' P Q A B), OS A B P Q
+++++
intros.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.

*****
H : same_side' P Q A B
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
unfold same_side' in *.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.

*****
H : and (not (eq A B))\n (forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\n same_side P Q l)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
destruct H.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.

*****
H0 : forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\nsame_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
destruct (axiom_line_existence A B H).
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).

*****
H1 : and (IncidentL A x) (IncidentL B x)
x : Couple
H0 : forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\nsame_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
destruct H1.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.

*****
H2 : IncidentL B x
H1 : IncidentL A x
x : Couple
H0 : forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\nsame_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
assert (T:=H0 x H1 H2).
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).

*****
T : same_side P Q x
H2 : IncidentL B x
H1 : IncidentL A x
x : Couple
H0 : forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\nsame_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
assert (U:=same_side_one_side P Q x T).
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).

*****
U : OS (P1 x) (P2 x) P Q
T : same_side P Q x
H2 : IncidentL B x
H1 : IncidentL A x
x : Couple
H0 : forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\nsame_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
destruct x.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.

*****
U : OS (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |}) P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : IncidentL B {| P1 := P1; P2 := P2; Cond := Cond |}
H1 : IncidentL A {| P1 := P1; P2 := P2; Cond := Cond |}
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : IncidentL A l) (_ : IncidentL B l),\nsame_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
unfold IncidentL in *.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.

*****
U : OS (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |}) P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : Col B (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
H1 : Col A (triples.P1 {| P1 := P1; P2 := P2; Cond := Cond |})\n (triples.P2 {| P1 := P1; P2 := P2; Cond := Cond |})
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : Col A (triples.P1 l) (triples.P2 l))\n (_ : Col B (triples.P1 l) (triples.P2 l)), same_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
simpl in *.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.
simpl in *.

*****
U : OS P1 P2 P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : Col B P1 P2
H1 : Col A P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : Col A (triples.P1 l) (triples.P2 l))\n (_ : Col B (triples.P1 l) (triples.P2 l)), same_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B P Q
+++++
apply col2_os__os with P1 P2.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P1 P2.

*****
U : OS P1 P2 P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : Col B P1 P2
H1 : Col A P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : Col A (triples.P1 l) (triples.P2 l))\n (_ : Col B (triples.P1 l) (triples.P2 l)), same_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
Col.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P1 P2.

*****
U : OS P1 P2 P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : Col B P1 P2
H1 : Col A P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : Col A (triples.P1 l) (triples.P2 l))\n (_ : Col B (triples.P1 l) (triples.P2 l)), same_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P1 P2 A
+++++
Col.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P1 P2.

*****
U : OS P1 P2 P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : Col B P1 P2
H1 : Col A P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : Col A (triples.P1 l) (triples.P2 l))\n (_ : Col B (triples.P1 l) (triples.P2 l)), same_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P1 P2 B
+++++
Col.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P1 P2.

*****
U : OS P1 P2 P Q
T : same_side P Q {| P1 := P1; P2 := P2; Cond := Cond |}
H2 : Col B P1 P2
H1 : Col A P1 P2
Cond : not (eq P1 P2)
P1,P2 : Tpoint
H0 : forall (l : Couple) (_ : Col A (triples.P1 l) (triples.P2 l))\n (_ : Col B (triples.P1 l) (triples.P2 l)), same_side P Q l
H : not (eq A B)
P,Q,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS P1 P2 P Q
+++++
Col.
-----
Lemma same_side_OS : forall P Q A B, same_side' P Q A B -> OS A B P Q.
Proof.
intros.
unfold same_side' in *.
destruct H.
destruct (axiom_line_existence A B H).
destruct H1.
assert (T:=H0 x H1 H2).
assert (U:=same_side_one_side P Q x T).
destruct x.
unfold IncidentL in *.
simpl in *.
apply col2_os__os with P1 P2.

*****

*****

+++++
Qed.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : outH P A B), Out P A B
+++++
Proof.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : outH P A B), Out P A B
+++++
unfold outH.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))), Out P A B
+++++
unfold Out.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P A B : Tpoint) (_ : or (Between_H P A B) (or (Between_H P B A) (and (not (eq P A)) (eq A B)))), and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
intros.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.

*****
H : or (Between_H P A B)\n (or (Between_H P B A) (and (not (eq P A)) (eq A B)))
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
induction H.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.

*****
H : Between_H P A B
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
unfold Between_H in H.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
unfold Between_H in H.

*****
H : and (Bet P A B)\n (and (not (eq P A)) (and (not (eq A B)) (not (eq P B))))
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
spliter.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
unfold Between_H in H.
spliter.

*****
H2 : not (eq P B)
H1 : not (eq A B)
H0 : not (eq P A)
H : Bet P A B
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
repeat split.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
unfold Between_H in H.
spliter.
repeat split.

*****
H2 : not (eq P B)
H1 : not (eq A B)
H0 : not (eq P A)
H : Bet P A B
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A P)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
unfold Between_H in H.
spliter.
repeat split.

*****
H2 : not (eq P B)
H1 : not (eq A B)
H0 : not (eq P A)
H : Bet P A B
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B P)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
unfold Between_H in H.
spliter.
repeat split.

*****
H2 : not (eq P B)
H1 : not (eq A B)
H0 : not (eq P A)
H : Bet P A B
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet P A B) (Bet P B A)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.

*****
H : or (Between_H P B A) (and (not (eq P A)) (eq A B))
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
induction H.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.

*****
H : Between_H P B A
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
unfold Between_H in H.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
unfold Between_H in H.

*****
H : and (Bet P B A)\n (and (not (eq P B)) (and (not (eq B A)) (not (eq P A))))
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
spliter.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
unfold Between_H in H.
spliter.

*****
H2 : not (eq P A)
H1 : not (eq B A)
H0 : not (eq P B)
H : Bet P B A
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
repeat split.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
unfold Between_H in H.
spliter.
repeat split.

*****
H2 : not (eq P A)
H1 : not (eq B A)
H0 : not (eq P B)
H : Bet P B A
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A P)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
unfold Between_H in H.
spliter.
repeat split.

*****
H2 : not (eq P A)
H1 : not (eq B A)
H0 : not (eq P B)
H : Bet P B A
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B P)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
unfold Between_H in H.
spliter.
repeat split.

*****
H2 : not (eq P A)
H1 : not (eq B A)
H0 : not (eq P B)
H : Bet P B A
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet P A B) (Bet P B A)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.

*****
H : and (not (eq P A)) (eq A B)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
spliter.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.

*****
H0 : eq A B
H : not (eq P A)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A P)) (and (not (eq B P)) (or (Bet P A B) (Bet P B A)))
+++++
repeat split.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.
repeat split.

*****
H0 : eq A B
H : not (eq P A)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A P)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.
repeat split.

*****
H0 : eq A B
H : not (eq P A)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B P)
+++++
subst B.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.
repeat split.
subst B.

*****
H : not (eq P A)
P,A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A P)
+++++
auto.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.
repeat split.

*****
H0 : eq A B
H : not (eq P A)
P,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet P A B) (Bet P B A)
+++++
subst B.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.
repeat split.
subst B.

*****
H : not (eq P A)
P,A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet P A A) (Bet P A A)
+++++
left.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.
induction H.
spliter.
repeat split.
subst B.
left.

*****
H : not (eq P A)
P,A : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P A A
+++++
apply between_trivial.
-----
Lemma outH_out : forall P A B, outH P A B -> Out P A B.
Proof.
unfold outH.
unfold Out.
intros.
induction H.

*****

*****

+++++
Qed.
-----
Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).
-----
Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (l : Couple) (_ : IncidentL M l), Col M (P1 l) (P2 l)
+++++
Proof.
-----
Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (l : Couple) (_ : IncidentL M l), Col M (P1 l) (P2 l)
+++++
unfold IncidentL.
-----
Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).
Proof.
unfold IncidentL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (l : Couple) (_ : Col M (P1 l) (P2 l)), Col M (P1 l) (P2 l)
+++++
intros.
-----
Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).
Proof.
unfold IncidentL.
intros.

*****
H : Col M (P1 l) (P2 l)
l : Couple
M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M (P1 l) (P2 l)
+++++
assumption.
-----
Lemma incident_col : forall M l, IncidentL M l -> Col M (P1 l)(P2 l).
Proof.
unfold IncidentL.
intros.
assumption.

*****

*****

+++++
Qed.
-----
Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.
-----
Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (l : Couple) (_ : Col M (P1 l) (P2 l)), IncidentL M l
+++++
Proof.
-----
Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (l : Couple) (_ : Col M (P1 l) (P2 l)), IncidentL M l
+++++
unfold IncidentL.
-----
Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.
Proof.
unfold IncidentL.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (M : Tpoint) (l : Couple) (_ : Col M (P1 l) (P2 l)), Col M (P1 l) (P2 l)
+++++
intros.
-----
Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.
Proof.
unfold IncidentL.
intros.

*****
H : Col M (P1 l) (P2 l)
l : Couple
M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M (P1 l) (P2 l)
+++++
assumption.
-----
Lemma col_incident : forall M l, Col M (P1 l)(P2 l) -> IncidentL M l.
Proof.
unfold IncidentL.
intros.
assumption.

*****

*****

+++++
Qed.
-----
Lemma Bet_Between_H : forall A B C,\n Bet A B C -> A<>B -> B<>C -> Between_H A B C.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Bet A B C) (_ : not (eq A B)) (_ : not (eq B C)), Between_H A B C
+++++
Proof.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Bet A B C) (_ : not (eq A B)) (_ : not (eq B C)), Between_H A B C
+++++
intros.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Between_H A B C
+++++
unfold Between_H.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B C) (and (not (eq A B)) (and (not (eq B C)) (not (eq A C))))
+++++
repeat split.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B C
+++++
try assumption.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
try assumption.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
try assumption.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
try assumption.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.
try assumption.

*****
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.
try assumption.
intro.

*****
H2 : eq A C
H1 : not (eq B C)
H0 : not (eq A B)
H : Bet A B C
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.
try assumption.
intro.
subst.

*****
H1 : not (eq B C)
H : Bet C B C
H0 : not (eq C B)
B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.
try assumption.
intro.
subst.
treat_equalities.

*****
H0 : not (eq C C)
C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma Bet_Between_H : forall A B C, Bet A B C -> A<>B -> B<>C -> Between_H A B C.
Proof.
intros.
unfold Between_H.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' ->\n           Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C A' B' C' : Tpoint) (_ : not (Col_H A B C)) (_ : not (Col_H A' B' C')) (_ : Cong A B A' B') (_ : Cong A C A' C') (_ : CongA B A C B' A' C'), CongA A B C A' B' C'
+++++
Proof.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C A' B' C' : Tpoint) (_ : not (Col_H A B C)) (_ : not (Col_H A' B' C')) (_ : Cong A B A' B') (_ : Cong A C A' C') (_ : CongA B A C B' A' C'), CongA A B C A' B' C'
+++++
intros A B C A' B' C'.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.

*****
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col_H A B C)) (_ : not (Col_H A' B' C')) (_ : Cong A B A' B') (_ : Cong A C A' C') (_ : CongA B A C B' A' C'), CongA A B C A' B' C'
+++++
intros.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.

*****
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
assert (T:=l11_49 B A C B' A' C').
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').

*****
T : forall (_ : CongA B A C B' A' C') (_ : Cong A B A' B')\n (_ : Cong A C A' C'),\nand (Cong B C B' C')\n (forall _ : not (eq B C),\n and (CongA A B C A' B' C') (CongA A C B A' C' B'))
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
assert (~ Col A B C).
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').
assert (~ Col A B C).

*****
T : forall (_ : CongA B A C B' A' C') (_ : Cong A B A' B')\n (_ : Cong A C A' C'),\nand (Cong B C B' C')\n (forall _ : not (eq B C),\n and (CongA A B C A' B' C') (CongA A C B A' C' B'))
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
intro.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').
assert (~ Col A B C).
intro.

*****
H4 : Col A B C
T : forall (_ : CongA B A C B' A' C') (_ : Cong A B A' B')\n (_ : Cong A C A' C'),\nand (Cong B C B' C')\n (forall _ : not (eq B C),\n and (CongA A B C A' B' C') (CongA A C B A' C' B'))
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply cols_coincide_2 in H4.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').
assert (~ Col A B C).
intro.
apply cols_coincide_2 in H4.

*****
H4 : Col_H A B C
T : forall (_ : CongA B A C B' A' C') (_ : Cong A B A' B')\n (_ : Cong A C A' C'),\nand (Cong B C B' C')\n (forall _ : not (eq B C),\n and (CongA A B C A' B' C') (CongA A C B A' C' B'))
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').
assert (~ Col A B C).

*****
H4 : not (Col A B C)
T : forall (_ : CongA B A C B' A' C') (_ : Cong A B A' B')\n (_ : Cong A C A' C'),\nand (Cong B C B' C')\n (forall _ : not (eq B C),\n and (CongA A B C A' B' C') (CongA A C B A' C' B'))
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
assert_diffs.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').
assert (~ Col A B C).
assert_diffs.

*****
H6 : not (eq A' B')
H5 : not (eq A' C')
H10 : not (eq A C)
H7 : not (eq B C)
H8 : not (eq A B)
H4 : not (Col A B C)
T : forall (_ : CongA B A C B' A' C') (_ : Cong A B A' B')\n (_ : Cong A C A' C'),\nand (Cong B C B' C')\n (forall _ : not (eq B C),\n and (CongA A B C A' B' C') (CongA A C B A' C' B'))
H3 : CongA B A C B' A' C'
H2 : Cong A C A' C'
H1 : Cong A B A' B'
H0 : not (Col_H A' B' C')
H : not (Col_H A B C)
A,B,C,A',B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
intuition.
-----
Lemma axiom_cong_5' : forall A B C A' B' C', ~ Col_H A B C -> ~ Col_H A' B' C' -> Cong A B A' B' -> Cong A C A' C' -> CongA B A C B' A' C' -> CongA A B C A' B' C'.
Proof.
intros A B C A' B' C'.
intros.
assert (T:=l11_49 B A C B' A' C').
assert (~ Col A B C).

*****

*****

+++++
Qed.
-----
Lemma axiom_hcong_4_existence :  forall A B C O X P,\n   ~ Col_H P O X -> ~ Col_H A B C ->\n  exists Y, CongA A B C X O Y   /\ same_side' P Y O X.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C O X P : Tpoint) (_ : not (Col_H P O X)) (_ : not (Col_H A B C)), ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
Proof.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C O X P : Tpoint) (_ : not (Col_H P O X)) (_ : not (Col_H A B C)), ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
intros.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.

*****
H0 : not (Col_H A B C)
H : not (Col_H P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
rewrite <- cols_coincide in H.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.

*****
H0 : not (Col_H A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
rewrite <- cols_coincide in H0.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.

*****
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
assert(~Col X O P).
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).

*****
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col X O P)
+++++
intro.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
intro.

*****
H1 : Col X O P
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
intro.
apply H.

*****
H1 : Col X O P
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P O X
+++++
Col.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).

*****
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
assert(HH:=angle_construction_1 A B C X O P H0 H1).
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).

*****
HH : ex (fun C' : Tpoint => and (CongA A B C X O C') (OS X O C' P))
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
ex_and HH Y.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (CongA A B C X O Y) (same_side' P Y O X))
+++++
exists Y.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.
exists Y.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA A B C X O Y) (same_side' P Y O X)
+++++
split.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.
exists Y.
split.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C X O Y
+++++
assumption.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.
exists Y.
split.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
same_side' P Y O X
+++++
apply OS_same_side'.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.
exists Y.
split.
apply OS_same_side'.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS O X P Y
+++++
apply invert_one_side.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.
exists Y.
split.
apply OS_same_side'.
apply invert_one_side.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS X O P Y
+++++
apply one_side_symmetry.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).
assert(HH:=angle_construction_1 A B C X O P H0 H1).
ex_and HH Y.
exists Y.
split.
apply OS_same_side'.
apply invert_one_side.
apply one_side_symmetry.

*****
H3 : OS X O Y P
H2 : CongA A B C X O Y
Y : Tpoint
H1 : not (Col X O P)
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,X,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS X O Y P
+++++
assumption.
-----
Lemma axiom_hcong_4_existence : forall A B C O X P, ~ Col_H P O X -> ~ Col_H A B C -> exists Y, CongA A B C X O Y /\\ same_side' P Y O X.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert(~Col X O P).

*****

*****

+++++
Qed.
-----
Lemma same_side_trans :\n forall A B C l,\n  same_side A B l -> same_side B C l -> same_side A C l.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (l : Couple) (_ : same_side A B l) (_ : same_side B C l), same_side A C l
+++++
Proof.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (l : Couple) (_ : same_side A B l) (_ : same_side B C l), same_side A C l
+++++
intros.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.

*****
H0 : same_side B C l
H : same_side A B l
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
same_side A C l
+++++
apply one_side_same_side.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.
apply one_side_same_side.

*****
H0 : same_side B C l
H : same_side A B l
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A C
+++++
apply same_side_one_side in H.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.

*****
H0 : same_side B C l
H : OS (P1 l) (P2 l) A B
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A C
+++++
apply same_side_one_side in H0.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.
apply same_side_one_side in H0.

*****
H0 : OS (P1 l) (P2 l) B C
H : OS (P1 l) (P2 l) A B
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A C
+++++
eapply one_side_transitivity.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.
apply same_side_one_side in H0.
eapply one_side_transitivity.

*****
H0 : OS (P1 l) (P2 l) B C
H : OS (P1 l) (P2 l) A B
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A ?B
+++++
apply H.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.
apply same_side_one_side in H0.
eapply one_side_transitivity.

*****
H0 : OS (P1 l) (P2 l) B C
H : OS (P1 l) (P2 l) A B
l : Couple
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) B C
+++++
assumption.
-----
Lemma same_side_trans : forall A B C l, same_side A B l -> same_side B C l -> same_side A C l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.
apply same_side_one_side in H0.
eapply one_side_transitivity.

*****

*****

+++++
Qed.
-----
Lemma same_side_sym :\n forall A B l,\n  same_side A B l -> same_side B A l.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : same_side A B l), same_side B A l
+++++
Proof.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (l : Couple) (_ : same_side A B l), same_side B A l
+++++
intros.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.
Proof.
intros.

*****
H : same_side A B l
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
same_side B A l
+++++
apply one_side_same_side.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.
Proof.
intros.
apply one_side_same_side.

*****
H : same_side A B l
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) B A
+++++
apply same_side_one_side in H.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.

*****
H : OS (P1 l) (P2 l) A B
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) B A
+++++
apply one_side_symmetry.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.
apply one_side_symmetry.

*****
H : OS (P1 l) (P2 l) A B
l : Couple
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS (P1 l) (P2 l) A B
+++++
assumption.
-----
Lemma same_side_sym : forall A B l, same_side A B l -> same_side B A l.
Proof.
intros.
apply one_side_same_side.
apply same_side_one_side in H.
apply one_side_symmetry.
assumption.

*****

*****

+++++
Qed.
-----
Lemma axiom_hcong_4_uniqueness :\n  forall A B C O P X Y Y', ~ Col_H P O X  -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> \n  same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C O P X Y Y' : Tpoint) (_ : not (Col_H P O X)) (_ : not (Col_H A B C)) (_ : CongA A B C X O Y) (_ : CongA A B C X O Y') (_ : same_side' P Y O X) (_ : same_side' P Y' O X), outH O Y Y'
+++++
Proof.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C O P X Y Y' : Tpoint) (_ : not (Col_H P O X)) (_ : not (Col_H A B C)) (_ : CongA A B C X O Y) (_ : CongA A B C X O Y') (_ : same_side' P Y O X) (_ : same_side' P Y' O X), outH O Y Y'
+++++
intros.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col_H A B C)
H : not (Col_H P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
rewrite <- cols_coincide in H.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col_H A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
rewrite <- cols_coincide in H0.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
assert (T:CongA X O Y X O Y').
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA X O Y X O Y'
+++++
eapply conga_trans.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
eapply conga_trans.

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA X O Y ?A' ?B' ?C'
+++++
apply conga_sym.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
eapply conga_trans.
apply conga_sym.

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA ?A' ?B' ?C' X O Y
+++++
apply H1.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
eapply conga_trans.

*****
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C X O Y'
+++++
assumption.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').

*****
T : CongA X O Y X O Y'
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
apply conga_cop__or_out_ts in T.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.

*****
T : or (Out O Y Y') (TS X O Y Y')
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
induction T.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.

*****
H5 : Out O Y Y'
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
apply out_outH.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply out_outH.

*****
H5 : Out O Y Y'
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out O Y Y'
+++++
assumption.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.

*****
H5 : TS X O Y Y'
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
apply same_side_OS in H3.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.

*****
H5 : TS X O Y Y'
H4 : same_side' P Y' O X
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
apply same_side_OS in H4.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.

*****
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
outH O Y Y'
+++++
exfalso.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.

*****
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (OS O X Y Y').
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').

*****
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS O X Y Y'
+++++
apply one_side_transitivity with P.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').
apply one_side_transitivity with P.

*****
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS O X Y P
+++++
apply one_side_symmetry.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').
apply one_side_transitivity with P.
apply one_side_symmetry.

*****
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS O X P Y
+++++
assumption.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').
apply one_side_transitivity with P.

*****
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS O X P Y'
+++++
assumption.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').

*****
H6 : OS O X Y Y'
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply invert_one_side in H6.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').
apply invert_one_side in H6.

*****
H6 : OS X O Y Y'
H5 : TS X O Y Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply l9_9 in H5.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
induction T.
apply same_side_OS in H3.
apply same_side_OS in H4.
exfalso.
assert (OS O X Y Y').
apply invert_one_side in H6.
apply l9_9 in H5.

*****
H6 : OS X O Y Y'
H5 : not (OS X O Y Y')
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.

*****
T : CongA X O Y X O Y'
H4 : same_side' P Y' O X
H3 : same_side' P Y O X
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X O Y Y'
+++++
apply same_side_OS in H3.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.

*****
T : CongA X O Y X O Y'
H4 : same_side' P Y' O X
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X O Y Y'
+++++
apply same_side_OS in H4.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.
apply same_side_OS in H4.

*****
T : CongA X O Y X O Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X O Y Y'
+++++
apply coplanar_trans_1 with P.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.
apply same_side_OS in H4.
apply coplanar_trans_1 with P.

*****
T : CongA X O Y X O Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P X O)
+++++
Col.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.
apply same_side_OS in H4.
apply coplanar_trans_1 with P.

*****
T : CongA X O Y X O Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P X O Y
+++++
Col.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.
apply same_side_OS in H4.
apply coplanar_trans_1 with P.
Col.

*****
T : CongA X O Y X O Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P X O Y
+++++
Cop.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.
apply same_side_OS in H4.
apply coplanar_trans_1 with P.

*****
T : CongA X O Y X O Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P X O Y'
+++++
Col.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').
apply conga_cop__or_out_ts in T.
apply same_side_OS in H3.
apply same_side_OS in H4.
apply coplanar_trans_1 with P.
Col.

*****
T : CongA X O Y X O Y'
H4 : OS O X P Y'
H3 : OS O X P Y
H2 : CongA A B C X O Y'
H1 : CongA A B C X O Y
H0 : not (Col A B C)
H : not (Col P O X)
A,B,C,O,P,X,Y,Y' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P X O Y'
+++++
Cop.
-----
Lemma axiom_hcong_4_uniqueness : forall A B C O P X Y Y', ~ Col_H P O X -> ~ Col_H A B C -> CongA A B C X O Y -> CongA A B C X O Y' -> same_side' P Y O X -> same_side' P Y' O X -> outH O Y Y'.
Proof.
intros.
rewrite <- cols_coincide in H.
rewrite <- cols_coincide in H0.
assert (T:CongA X O Y X O Y').

*****

*****

+++++
Qed.
-----
Lemma axiom_conga_comm : forall A B C,\n ~ Col_H A B C -> CongA A B C C B A.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (Col_H A B C)), CongA A B C C B A
+++++
Proof.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (Col_H A B C)), CongA A B C C B A
+++++
intros.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.
intros.

*****
H : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C C B A
+++++
rewrite <- cols_coincide in H.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.
intros.
rewrite <- cols_coincide in H.

*****
H : not (Col A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C C B A
+++++
assert_diffs.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.
intros.
rewrite <- cols_coincide in H.
assert_diffs.

*****
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : not (Col A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C C B A
+++++
apply conga_pseudo_refl.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.
intros.
rewrite <- cols_coincide in H.
assert_diffs.
apply conga_pseudo_refl.

*****
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : not (Col A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.
intros.
rewrite <- cols_coincide in H.
assert_diffs.
apply conga_pseudo_refl.

*****
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : not (Col A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C B)
+++++
auto.
-----
Lemma axiom_conga_comm : forall A B C, ~ Col_H A B C -> CongA A B C C B A.
Proof.
intros.
rewrite <- cols_coincide in H.
assert_diffs.
apply conga_pseudo_refl.

*****

*****

+++++
Qed.
-----
Lemma axiom_congaH_outH_congaH :\n forall A B C D E F A' C' D' F' : Tpoint,\n  CongA A B C D E F ->\n  Between_H B A A' \/ Between_H B A' A \/ B <> A /\ A = A' ->\n  Between_H B C C' \/ Between_H B C' C \/ B <> C /\ C = C' ->\n  Between_H E D D' \/ Between_H E D' D \/ E <> D /\ D = D' ->\n  Between_H E F F' \/ Between_H E F' F \/ E <> F /\ F = F' ->\n  CongA A' B C' D' E F'.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F A' C' D' F' : Tpoint) (_ : CongA A B C D E F) (_ : or (Between_H B A A') (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))) (_ : or (Between_H B C C') (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))) (_ : or (Between_H E D D') (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))) (_ : or (Between_H E F F') (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))), CongA A' B C' D' E F'
+++++
Proof.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F A' C' D' F' : Tpoint) (_ : CongA A B C D E F) (_ : or (Between_H B A A') (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))) (_ : or (Between_H B C C') (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))) (_ : or (Between_H E D D') (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))) (_ : or (Between_H E F F') (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))), CongA A' B C' D' E F'
+++++
intros.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.

*****
H3 : or (Between_H E F F')\n (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))
H2 : or (Between_H E D D')\n (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))
H1 : or (Between_H B C C')\n (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))
H0 : or (Between_H B A A')\n (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))
H : CongA A B C D E F
A,B,C,D,E,F,A',C',D',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A' B C' D' E F'
+++++
apply out_conga with A C D F.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.
apply out_conga with A C D F.

*****
H3 : or (Between_H E F F')\n (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))
H2 : or (Between_H E D D')\n (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))
H1 : or (Between_H B C C')\n (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))
H0 : or (Between_H B A A')\n (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))
H : CongA A B C D E F
A,B,C,D,E,F,A',C',D',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C D E F
+++++
auto using outH_out.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.
apply out_conga with A C D F.

*****
H3 : or (Between_H E F F')\n (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))
H2 : or (Between_H E D D')\n (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))
H1 : or (Between_H B C C')\n (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))
H0 : or (Between_H B A A')\n (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))
H : CongA A B C D E F
A,B,C,D,E,F,A',C',D',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A A'
+++++
auto using outH_out.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.
apply out_conga with A C D F.

*****
H3 : or (Between_H E F F')\n (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))
H2 : or (Between_H E D D')\n (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))
H1 : or (Between_H B C C')\n (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))
H0 : or (Between_H B A A')\n (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))
H : CongA A B C D E F
A,B,C,D,E,F,A',C',D',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B C C'
+++++
auto using outH_out.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.
apply out_conga with A C D F.

*****
H3 : or (Between_H E F F')\n (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))
H2 : or (Between_H E D D')\n (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))
H1 : or (Between_H B C C')\n (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))
H0 : or (Between_H B A A')\n (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))
H : CongA A B C D E F
A,B,C,D,E,F,A',C',D',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D D'
+++++
auto using outH_out.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.
apply out_conga with A C D F.

*****
H3 : or (Between_H E F F')\n (or (Between_H E F' F) (and (not (eq E F)) (eq F F')))
H2 : or (Between_H E D D')\n (or (Between_H E D' D) (and (not (eq E D)) (eq D D')))
H1 : or (Between_H B C C')\n (or (Between_H B C' C) (and (not (eq B C)) (eq C C')))
H0 : or (Between_H B A A')\n (or (Between_H B A' A) (and (not (eq B A)) (eq A A')))
H : CongA A B C D E F
A,B,C,D,E,F,A',C',D',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E F F'
+++++
auto using outH_out.
-----
Lemma axiom_congaH_outH_congaH : forall A B C D E F A' C' D' F' : Tpoint, CongA A B C D E F -> Between_H B A A' \\/ Between_H B A' A \\/ B <> A /\\ A = A' -> Between_H B C C' \\/ Between_H B C' C \\/ B <> C /\\ C = C' -> Between_H E D D' \\/ Between_H E D' D \\/ E <> D /\\ D = D' -> Between_H E F F' \\/ Between_H E F' F \\/ E <> F /\\ F = F' -> CongA A' B C' D' E F'.
Proof.
intros.
apply out_conga with A C D F.

*****

*****

+++++
Qed.
-----
Lemma axiom_conga_permlr:\nforall A B C D E F : Tpoint, CongA A B C D E F -> CongA C B A F E D.
-----
Lemma axiom_conga_permlr: forall A B C D E F : Tpoint, CongA A B C D E F -> CongA C B A F E D.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : CongA A B C D E F), CongA C B A F E D
+++++
Proof.
-----
Lemma axiom_conga_permlr: forall A B C D E F : Tpoint, CongA A B C D E F -> CongA C B A F E D.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : CongA A B C D E F), CongA C B A F E D
+++++
apply Ch11_angles.conga_comm.
-----
Lemma axiom_conga_permlr: forall A B C D E F : Tpoint, CongA A B C D E F -> CongA C B A F E D.
Proof.
apply Ch11_angles.conga_comm.

*****

*****

+++++
Qed.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (Col_H A B C)), CongA A B C A B C
+++++
Proof.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : not (Col_H A B C)), CongA A B C A B C
+++++
intros A B C H.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.

*****
H : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A B C
+++++
apply Ch11_angles.conga_refl.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.

*****
H : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
intro.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.

*****
H0 : eq A B
H : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.
subst.

*****
H : not (Col_H B B C)
B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.
subst.
apply H.

*****
H : not (Col_H B B C)
B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H B B C
+++++
apply cols_coincide.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.
subst.
apply H.
apply cols_coincide.

*****
H : not (Col_H B B C)
B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B C
+++++
Col.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.

*****
H : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C B)
+++++
intro.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.

*****
H0 : eq C B
H : not (Col_H A B C)
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.
subst.

*****
H : not (Col_H A B B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.
subst.
apply H.

*****
H : not (Col_H A B B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col_H A B B
+++++
apply cols_coincide.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.
intro.
subst.
apply H.
apply cols_coincide.

*****
H : not (Col_H A B B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B B
+++++
Col.
-----
Lemma axiom_conga_refl : forall A B C, ~ Col_H A B C -> CongA A B C A B C.
Proof.
intros A B C H.
apply Ch11_angles.conga_refl.

*****

*****

+++++
Qed.
-----
End T.
-----
Section Tarski_neutral_to_Hilbert_neutral.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Instance Hilbert_neutral_follows_from_Tarski_neutral : Hilbert_neutral_dimensionless.
-----
Instance Hilbert_neutral_follows_from_Tarski_neutral : Hilbert_neutral_dimensionless.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_dimensionless
+++++
Proof.
-----
Instance Hilbert_neutral_follows_from_Tarski_neutral : Hilbert_neutral_dimensionless.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_dimensionless
+++++
exact (Build_Hilbert_neutral_dimensionless Tpoint Line Plane EqL EqL_Equiv EqP EqP_Equiv IncidentL IncidentP axiom_Incid_morphism axiom_Incid_dec axiom_Incidp_morphism axiom_Incidp_dec eq_dec_points axiom_line_existence axiom_line_uniqueness axiom_two_points_on_line PA PB PC lower_dim' axiom_plane_existence axiom_one_point_on_plane axiom_plane_uniqueness axiom_line_on_plane Between_H axiom_between_diff axiom_between_col axiom_between_comm axiom_between_out axiom_between_only_one axiom_pasch Cong cong_right_commutativity axiom_hcong_1_existence cong_inner_transitivity axiom_hcong_3 CongA axiom_conga_refl axiom_conga_comm axiom_conga_permlr axiom_congaH_outH_congaH axiom_hcong_4_existence axiom_hcong_4_uniqueness axiom_cong_5').
-----
Instance Hilbert_neutral_follows_from_Tarski_neutral : Hilbert_neutral_dimensionless.
Proof.
exact (Build_Hilbert_neutral_dimensionless Tpoint Line Plane EqL EqL_Equiv EqP EqP_Equiv IncidentL IncidentP axiom_Incid_morphism axiom_Incid_dec axiom_Incidp_morphism axiom_Incidp_dec eq_dec_points axiom_line_existence axiom_line_uniqueness axiom_two_points_on_line PA PB PC lower_dim' axiom_plane_existence axiom_one_point_on_plane axiom_plane_uniqueness axiom_line_on_plane Between_H axiom_between_diff axiom_between_col axiom_between_comm axiom_between_out axiom_between_only_one axiom_pasch Cong cong_right_commutativity axiom_hcong_1_existence cong_inner_transitivity axiom_hcong_3 CongA axiom_conga_refl axiom_conga_comm axiom_conga_permlr axiom_congaH_outH_congaH axiom_hcong_4_existence axiom_hcong_4_uniqueness axiom_cong_5').

*****

*****

+++++
Defined.
-----
End Tarski_neutral_to_Hilbert_neutral.
-----
Section Tarski_neutral_2D_to_Hilbert_neutral_2D.
-----
Context `{T2D:Tarski_2D}.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.

*****
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral
+++++
Proof.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.

*****
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral
+++++
split.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.

*****
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Point) (l : hilbert_axioms.Line) (_ : not (ColH A B C)) (_ : not (IncidL C l)) (_ : hilbert_axioms.cut l A B), or (hilbert_axioms.cut l A C) (hilbert_axioms.cut l B C)
+++++
intros A B C l HNCol HNCl Hcut.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (hilbert_axioms.cut l A C) (hilbert_axioms.cut l B C)
+++++
apply axiom_pasch with (Plan A B C HNCol).
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col_H A B C)
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentLP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) A
+++++
intros.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.
intros.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) A
+++++
try (apply all_coplanar).
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentLP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) B
+++++
intros.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.
intros.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) B
+++++
try (apply all_coplanar).
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentLP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) C
+++++
intros.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.
intros.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) C
+++++
try (apply all_coplanar).
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentLP l {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentLP l {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentLP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A0 : Tpoint) (_ : IncidentL A0 l), IncidentP A0 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}
+++++
unfold IncidentP.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A0 : Tpoint) (_ : IncidentL A0 l), Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) A0
+++++
intros.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).
trivial.
unfold IncidentLP.
unfold IncidentP.
intros.

*****
H : IncidentL A0 l
A0 : Tpoint
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar (M1 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M2 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) (M3 {| M1 := A; M2 := B; M3 := C; NCol := HNCol |}) A0
+++++
try (apply all_coplanar).
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (IncidentL C l)
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****
Hcut : hilbert_axioms.cut l A B
HNCl : not (IncidL C l)
HNCol : not (ColH A B C)
l : hilbert_axioms\.Line
A,B,C : Point
T2D : Tarski_2D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
cut l A B
+++++
trivial.
-----
Instance Hilbert_2D_follows_from_Tarski_2D : Hilbert_neutral_2D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
intros A B C l HNCol HNCl Hcut.
apply axiom_pasch with (Plan A B C HNCol).

*****

*****

+++++
Defined.
-----
End Tarski_neutral_2D_to_Hilbert_neutral_2D.
-----
Section Tarski_neutral_3D_to_Hilbert_neutral_3D.
-----
Context `{T3D:Tarski_3D}.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D |\n  ~ exists p, IncidentP A p /\ IncidentP B p /\ IncidentP C p /\ IncidentP D p}}}}.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.

*****
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
sigT (fun A : Tpoint => sigT (fun B : Tpoint => sigT (fun C : Tpoint => sig (fun D : Tpoint => not (ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))))))))
+++++
Proof.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.

*****
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
sigT (fun A : Tpoint => sigT (fun B : Tpoint => sigT (fun C : Tpoint => sig (fun D : Tpoint => not (ex (fun p : Plane => and (IncidentP A p) (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))))))))
+++++
exists S1, S2, S3, S4.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.

*****
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (ex (fun p : Plane => and (IncidentP S1 p) (and (IncidentP S2 p) (and (IncidentP S3 p) (IncidentP S4 p)))))
+++++
intros [p].
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].

*****
H : and (IncidentP S1 p)\n (and (IncidentP S2 p) (and (IncidentP S3 p) (IncidentP S4 p)))
p : Plane
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].
spliter.

*****
H2 : IncidentP S4 p
H1 : IncidentP S3 p
H0 : IncidentP S2 p
H : IncidentP S1 p
p : Plane
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply tarski_axioms.lower_dim_3, plane_cop with p.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].
spliter.
apply tarski_axioms.lower_dim_3, plane_cop with p.

*****
H2 : IncidentP S4 p
H1 : IncidentP S3 p
H0 : IncidentP S2 p
H : IncidentP S1 p
p : Plane
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP S1 p
+++++
assumption.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].
spliter.
apply tarski_axioms.lower_dim_3, plane_cop with p.

*****
H2 : IncidentP S4 p
H1 : IncidentP S3 p
H0 : IncidentP S2 p
H : IncidentP S1 p
p : Plane
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP S2 p
+++++
assumption.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].
spliter.
apply tarski_axioms.lower_dim_3, plane_cop with p.

*****
H2 : IncidentP S4 p
H1 : IncidentP S3 p
H0 : IncidentP S2 p
H : IncidentP S1 p
p : Plane
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP S3 p
+++++
assumption.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].
spliter.
apply tarski_axioms.lower_dim_3, plane_cop with p.

*****
H2 : IncidentP S4 p
H1 : IncidentP S3 p
H0 : IncidentP S2 p
H : IncidentP S1 p
p : Plane
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP S4 p
+++++
assumption.
-----
Lemma lower_dim_3' : {A : Tpoint & {B : Tpoint & {C : Tpoint & {D | ~ exists p, IncidentP A p /\\ IncidentP B p /\\ IncidentP C p /\\ IncidentP D p}}}}.
Proof.
exists S1, S2, S3, S4.
intros [p].
spliter.
apply tarski_axioms.lower_dim_3, plane_cop with p.

*****

*****

+++++
Qed.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.

*****
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral
+++++
Proof.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.

*****
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral
+++++
destruct lower_dim_3' as [A [B [C [D n]]]].
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].

*****
n : not\n (ex\n (fun p : Plane =>\n and (IncidentP A p)\n (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))))
A,B,C,D : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral
+++++
exists A B C D.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.

*****
n : not\n (ex\n (fun p : Plane =>\n and (IncidentP A p)\n (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))))
A,B,C,D : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (p q : hilbert_axioms.Plane) (_ : IncidP A p) (_ : IncidP A q), ex (fun B : Point => and (IncidP B p) (and (IncidP B q) (not (eq A B))))
+++++
idtac.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.

*****
n : not\n (ex\n (fun p : Plane =>\n and (IncidentP A p)\n (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))))
A,B,C,D : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (p q : hilbert_axioms.Plane) (_ : IncidP A p) (_ : IncidP A q), ex (fun B : Point => and (IncidP B p) (and (IncidP B q) (not (eq A B))))
+++++
clear A B C D n.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.

*****
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (p q : hilbert_axioms.Plane) (_ : IncidP A p) (_ : IncidP A q), ex (fun B : Point => and (IncidP B p) (and (IncidP B q) (not (eq A B))))
+++++
intros A p q HAp HAq.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.

*****
HAq : IncidP A q
HAp : IncidP A p
p,q : hilbert_axioms\.Plane
A : Point
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Point => and (IncidP B p) (and (IncidP B q) (not (eq A B))))
+++++
destruct p as [P1 P2 P3 HP].
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].

*****
HAq : IncidP A q
HAp : IncidP A {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}
q : hilbert_axioms\.Plane
HP : not (Col_H P1 P2 P3)
P1,P2,P3 : Tpoint
A : Point
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Point => and (IncidP B {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) (and (IncidP B q) (not (eq A B))))
+++++
destruct q as [Q1 Q2 Q3 HQ].
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].

*****
HAq : IncidP A {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}
HAp : IncidP A {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
P1,P2,P3 : Tpoint
A : Point
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Point => and (IncidP B {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) (and (IncidP B {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) (not (eq A B))))
+++++
unfold IncidP in *.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.

*****
HAq : (let\n (Point, Line, Plane, EqL, _, EqP, _, IncidL, IncidP, _, _, _, _, _,\n _, _, _, _, PP, PQ, PR, _, _, _, _, _, _, BetH, _, _, _, _, _, _,\n _, CongH, _, _, _, _, _, _, CongaH, _, _, _, _, _, _, _, _, _) as\n Hilbert_neutral_dimensionless\n return (forall (_ : Point) (_ : hilbert_axioms.Plane), Prop) :=\n Hilbert_neutral_follows_from_Tarski_neutral in\n IncidP) A {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}
HAp : (let\n (Point, Line, Plane, EqL, _, EqP, _, IncidL, IncidP, _, _, _, _, _,\n _, _, _, _, PP, PQ, PR, _, _, _, _, _, _, BetH, _, _, _, _, _, _,\n _, CongH, _, _, _, _, _, _, CongaH, _, _, _, _, _, _, _, _, _) as\n Hilbert_neutral_dimensionless\n return (forall (_ : Point) (_ : hilbert_axioms.Plane), Prop) :=\n Hilbert_neutral_follows_from_Tarski_neutral in\n IncidP) A {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
P1,P2,P3 : Tpoint
A : Point
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Point => and ((let (Point, Line, Plane, EqL, _, EqP, _, IncidL, IncidP, _, _, _, _, _, _, _, _, _, PP, PQ, PR, _, _, _, _, _, _, BetH, _, _, _, _, _, _, _, CongH, _, _, _, _, _, _, CongaH, _, _, _, _, _, _, _, _, _) as Hilbert_neutral_dimensionless return (forall (_ : Point) (_ : hilbert_axioms.Plane), Prop) := Hilbert_neutral_follows_from_Tarski_neutral in IncidP) B {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) (and ((let (Point, Line, Plane, EqL, _, EqP, _, IncidL, IncidP, _, _, _, _, _, _, _, _, _, PP, PQ, PR, _, _, _, _, _, _, BetH, _, _, _, _, _, _, _, CongH, _, _, _, _, _, _, CongaH, _, _, _, _, _, _, _, _, _) as Hilbert_neutral_dimensionless return (forall (_ : Point) (_ : hilbert_axioms.Plane), Prop) := Hilbert_neutral_follows_from_Tarski_neutral in IncidP) B {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) (not (eq A B))))
+++++
simpl in *.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.

*****
HAq : IncidentP A {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}
HAp : IncidentP A {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (IncidentP B {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) (and (IncidentP B {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) (not (eq A B))))
+++++
unfold IncidentP in *.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.

*****
HAq : Coplanar (M1 {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |})\n (M2 {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |})\n (M3 {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) A
HAp : Coplanar (M1 {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |})\n (M2 {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |})\n (M3 {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (Coplanar (M1 {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) (M2 {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) (M3 {| M1 := P1; M2 := P2; M3 := P3; NCol := HP |}) B) (and (Coplanar (M1 {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) (M2 {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) (M3 {| M1 := Q1; M2 := Q2; M3 := Q3; NCol := HQ |}) B) (not (eq A B))))
+++++
simpl in *.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (Coplanar P1 P2 P3 B) (and (Coplanar Q1 Q2 Q3 B) (not (eq A B))))
+++++
assert (pi : plane_intersection_axiom).
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
plane_intersection_axiom
+++++
cut upper_dim_3_axiom.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : upper_dim_3_axiom, plane_intersection_axiom
+++++
apply upper_dim_3_equivalent_axioms.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.
apply upper_dim_3_equivalent_axioms.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In plane_intersection_axiom (cons upper_dim_3_axiom (cons orthonormal_family_axiom (cons space_separation_axiom (cons plane_intersection_axiom (cons median_planes_axiom nil)))))
+++++
simpl.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.
apply upper_dim_3_equivalent_axioms.
simpl.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq upper_dim_3_axiom plane_intersection_axiom) (or (eq orthonormal_family_axiom plane_intersection_axiom) (or (eq space_separation_axiom plane_intersection_axiom) (or (eq plane_intersection_axiom plane_intersection_axiom) (or (eq median_planes_axiom plane_intersection_axiom) False))))
+++++
tauto.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.
apply upper_dim_3_equivalent_axioms.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In upper_dim_3_axiom (cons upper_dim_3_axiom (cons orthonormal_family_axiom (cons space_separation_axiom (cons plane_intersection_axiom (cons median_planes_axiom nil)))))
+++++
simpl.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.
apply upper_dim_3_equivalent_axioms.
simpl.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq upper_dim_3_axiom upper_dim_3_axiom) (or (eq orthonormal_family_axiom upper_dim_3_axiom) (or (eq space_separation_axiom upper_dim_3_axiom) (or (eq plane_intersection_axiom upper_dim_3_axiom) (or (eq median_planes_axiom upper_dim_3_axiom) False))))
+++++
tauto.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
upper_dim_3_axiom
+++++
unfold upper_dim_3_axiom.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
cut upper_dim_3_axiom.
unfold upper_dim_3_axiom.

*****
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C P Q R : Tpoint) (_ : not (eq P Q)) (_ : not (eq Q R)) (_ : not (eq P R)) (_ : Cong A P A Q) (_ : Cong B P B Q) (_ : Cong C P C Q) (_ : Cong A P A R) (_ : Cong B P B R) (_ : Cong C P C R), or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
apply upper_dim_3.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).

*****
pi : plane_intersection_axiom
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => and (Coplanar P1 P2 P3 B) (and (Coplanar Q1 Q2 Q3 B) (not (eq A B))))
+++++
apply pi.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
apply pi.

*****
pi : plane_intersection_axiom
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P1 P2 P3 A
+++++
assumption.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.
idtac.
clear A B C D n.
intros A p q HAp HAq.
destruct p as [P1 P2 P3 HP].
destruct q as [Q1 Q2 Q3 HQ].
unfold IncidP in *.
simpl in *.
unfold IncidentP in *.
simpl in *.
assert (pi : plane_intersection_axiom).
apply pi.

*****
pi : plane_intersection_axiom
HAq : Coplanar Q1 Q2 Q3 A
HAp : Coplanar P1 P2 P3 A
HQ : not (Col_H Q1 Q2 Q3)
Q1,Q2,Q3 : Tpoint
HP : not (Col_H P1 P2 P3)
A,P1,P2,P3 : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Q1 Q2 Q3 A
+++++
assumption.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.

*****
n : not\n (ex\n (fun p : Plane =>\n and (IncidentP A p)\n (and (IncidentP B p) (and (IncidentP C p) (IncidentP D p)))))
A,B,C,D : Tpoint
T3D : Tarski_3D TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (ex (fun p : hilbert_axioms.Plane => and (IncidP A p) (and (IncidP B p) (and (IncidP C p) (IncidP D p)))))
+++++
assumption.
-----
Instance Hilbert_3D_follows_from_Tarski_3D : Hilbert_neutral_3D Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
destruct lower_dim_3' as [A [B [C [D n]]]].
exists A B C D.

*****

*****

+++++
Defined.
-----
End Tarski_neutral_3D_to_Hilbert_neutral_3D.
-----
Section Tarski_Euclidean_to_Hilbert_Euclidean.
-----
Context `{TE:Tarski_euclidean}.
-----
Definition Para := fun l m =>\n  (~ exists X, IncidentL X l /\ IncidentL X m) /\ exists p, IncidentLP l p /\ IncidentLP m p.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D),\n Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : Para (Lin A B HAB) (Lin C D HCD)), Par A B C D
+++++
Proof.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : Para (Lin A B HAB) (Lin C D HCD)), Par A B C D
+++++
unfold Para.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : and (not (ex (fun X : Tpoint => and (IncidentL X (Lin A B HAB)) (IncidentL X (Lin C D HCD))))) (ex (fun p : Plane => and (IncidentLP (Lin A B HAB) p) (IncidentLP (Lin C D HCD) p)))), Par A B C D
+++++
unfold IncidentL.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : and (not (ex (fun X : Tpoint => and (Col X (P1 (Lin A B HAB)) (P2 (Lin A B HAB))) (Col X (P1 (Lin C D HCD)) (P2 (Lin C D HCD)))))) (ex (fun p : Plane => and (IncidentLP (Lin A B HAB) p) (IncidentLP (Lin C D HCD) p)))), Par A B C D
+++++
unfold Par.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : and (not (ex (fun X : Tpoint => and (Col X (P1 (Lin A B HAB)) (P2 (Lin A B HAB))) (Col X (P1 (Lin C D HCD)) (P2 (Lin C D HCD)))))) (ex (fun p : Plane => and (IncidentLP (Lin A B HAB) p) (IncidentLP (Lin C D HCD) p)))), or (Par_strict A B C D) (and (not (eq A B)) (and (not (eq C D)) (and (Col A C D) (Col B C D))))
+++++
unfold Par_strict.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : and (not (ex (fun X : Tpoint => and (Col X (P1 (Lin A B HAB)) (P2 (Lin A B HAB))) (Col X (P1 (Lin C D HCD)) (P2 (Lin C D HCD)))))) (ex (fun p : Plane => and (IncidentLP (Lin A B HAB) p) (IncidentLP (Lin C D HCD) p)))), or (and (not (eq A B)) (and (not (eq C D)) (and (Coplanar A B C D) (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D))))))) (and (not (eq A B)) (and (not (eq C D)) (and (Col A C D) (Col B C D))))
+++++
simpl.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (HAB : not (eq A B)) (HCD : not (eq C D)) (_ : and (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))) (ex (fun p : Plane => and (IncidentLP (Lin A B HAB) p) (IncidentLP (Lin C D HCD) p)))), or (and (not (eq A B)) (and (not (eq C D)) (and (Coplanar A B C D) (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D))))))) (and (not (eq A B)) (and (not (eq C D)) (and (Col A C D) (Col B C D))))
+++++
intros.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.

*****
H : and (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D))))\n (ex\n (fun p : Plane =>\n and (IncidentLP (Lin A B HAB) p) (IncidentLP (Lin C D HCD) p)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (not (eq A B)) (and (not (eq C D)) (and (Coplanar A B C D) (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D))))))) (and (not (eq A B)) (and (not (eq C D)) (and (Col A C D) (Col B C D))))
+++++
destruct H as [HNI [p []]].
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (not (eq A B)) (and (not (eq C D)) (and (Coplanar A B C D) (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D))))))) (and (not (eq A B)) (and (not (eq C D)) (and (Col A C D) (Col B C D))))
+++++
left.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A B)) (and (not (eq C D)) (and (Coplanar A B C D) (not (ex (fun X : Tpoint => and (Col X A B) (Col X C D))))))
+++++
repeat split.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C D)
+++++
auto.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C D
+++++
auto.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C D
+++++
apply plane_cop with p.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP A p
+++++
apply H.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL A (Lin A B HAB)
+++++
unfold IncidentL.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H.
unfold IncidentL.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A (P1 (Lin A B HAB)) (P2 (Lin A B HAB))
+++++
simpl.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H.
unfold IncidentL.
simpl.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A A B
+++++
Col.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP B p
+++++
apply H.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL B (Lin A B HAB)
+++++
unfold IncidentL.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H.
unfold IncidentL.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B (P1 (Lin A B HAB)) (P2 (Lin A B HAB))
+++++
simpl.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H.
unfold IncidentL.
simpl.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A B
+++++
Col.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP C p
+++++
apply H0.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H0.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL C (Lin C D HCD)
+++++
unfold IncidentL.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H0.
unfold IncidentL.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C (P1 (Lin C D HCD)) (P2 (Lin C D HCD))
+++++
simpl.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H0.
unfold IncidentL.
simpl.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C C D
+++++
Col.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentP D p
+++++
apply H0.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H0.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL D (Lin C D HCD)
+++++
unfold IncidentL.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H0.
unfold IncidentL.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D (P1 (Lin C D HCD)) (P2 (Lin C D HCD))
+++++
simpl.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.
auto.
apply plane_cop with p.
apply H0.
unfold IncidentL.
simpl.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D C D
+++++
Col.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.

*****
H0 : IncidentLP (Lin C D HCD) p
H : IncidentLP (Lin A B HAB) p
p : Plane
HNI : not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
HCD : not (eq C D)
HAB : not (eq A B)
A,B,C,D : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (ex (fun X : Tpoint => and (Col X A B) (Col X C D)))
+++++
auto.
-----
Lemma Para_Par : forall A B C D (HAB : A<>B) (HCD: C<>D), Para (Lin A B HAB) (Lin C D HCD) -> Par A B C D.
Proof.
unfold Para.
unfold IncidentL.
unfold Par.
unfold Par_strict.
simpl.
intros.
destruct H as [HNI [p []]].
left.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma axiom_euclid_uniqueness :\n  forall l P m1 m2,\n  ~ IncidentL P l ->\n   Para l m1 -> IncidentL P m1 ->\n   Para l m2 -> IncidentL P m2 ->\n   EqL m1 m2.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l : Couple) (P : Tpoint) (m1 m2 : Couple) (_ : not (IncidentL P l)) (_ : Para l m1) (_ : IncidentL P m1) (_ : Para l m2) (_ : IncidentL P m2), EqL m1 m2
+++++
Proof.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l : Couple) (P : Tpoint) (m1 m2 : Couple) (_ : not (IncidentL P l)) (_ : Para l m1) (_ : IncidentL P m1) (_ : Para l m2) (_ : IncidentL P m2), EqL m1 m2
+++++
intros.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.

*****
H3 : IncidentL P m2
H2 : Para l m2
H1 : IncidentL P m1
H0 : Para l m1
H : not (IncidentL P l)
m1,m2 : Couple
P : Tpoint
l : Couple
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL m1 m2
+++++
destruct l as [A B HAB].
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].

*****
H3 : IncidentL P m2
H2 : Para {| P1 := A; P2 := B; Cond := HAB |} m2
H1 : IncidentL P m1
H0 : Para {| P1 := A; P2 := B; Cond := HAB |} m1
H : not (IncidentL P {| P1 := A; P2 := B; Cond := HAB |})
m1,m2 : Couple
P : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL m1 m2
+++++
destruct m1 as [C D HCD].
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].

*****
H3 : IncidentL P m2
H2 : Para {| P1 := A; P2 := B; Cond := HAB |} m2
H1 : IncidentL P {| P1 := C; P2 := D; Cond := HCD |}
H0 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C; P2 := D; Cond := HCD |}
H : not (IncidentL P {| P1 := A; P2 := B; Cond := HAB |})
m2 : Couple
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} m2
+++++
destruct m2 as [C' D' HCD'].
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].

*****
H3 : IncidentL P {| P1 := C'; P2 := D'; Cond := HCD' |}
H2 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C'; P2 := D'; Cond := HCD' |}
H1 : IncidentL P {| P1 := C; P2 := D; Cond := HCD |}
H0 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C; P2 := D; Cond := HCD |}
H : not (IncidentL P {| P1 := A; P2 := B; Cond := HAB |})
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
unfold IncidentL in *.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.

*****
H3 : Col P (P1 {| P1 := C'; P2 := D'; Cond := HCD' |})\n (P2 {| P1 := C'; P2 := D'; Cond := HCD' |})
H2 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C'; P2 := D'; Cond := HCD' |}
H1 : Col P (P1 {| P1 := C; P2 := D; Cond := HCD |})\n (P2 {| P1 := C; P2 := D; Cond := HCD |})
H0 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C; P2 := D; Cond := HCD |}
H : not\n (Col P (P1 {| P1 := A; P2 := B; Cond := HAB |})\n (P2 {| P1 := A; P2 := B; Cond := HAB |}))
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
simpl in *.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.

*****
H3 : Col P C' D'
H2 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C'; P2 := D'; Cond := HCD' |}
H1 : Col P C D
H0 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C; P2 := D; Cond := HCD |}
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
apply Para_Par in H0.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.

*****
H3 : Col P C' D'
H2 : Para {| P1 := A; P2 := B; Cond := HAB |}\n {| P1 := C'; P2 := D'; Cond := HCD' |}
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
apply Para_Par in H2.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.

*****
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).

*****
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Col C' C D) (_ : Col D' C D), EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
intros.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
EqL {| P1 := C; P2 := D; Cond := HCD |} {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
apply axiom_line_uniqueness with C' D'.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C' D')
+++++
unfold IncidentL.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C' D')
+++++
simpl.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.
simpl.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C' D')
+++++
Col.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL C' {| P1 := C; P2 := D; Cond := HCD |}
+++++
unfold IncidentL.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C' (P1 {| P1 := C; P2 := D; Cond := HCD |}) (P2 {| P1 := C; P2 := D; Cond := HCD |})
+++++
simpl.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.
simpl.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C' C D
+++++
Col.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL D' {| P1 := C; P2 := D; Cond := HCD |}
+++++
unfold IncidentL.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D' (P1 {| P1 := C; P2 := D; Cond := HCD |}) (P2 {| P1 := C; P2 := D; Cond := HCD |})
+++++
simpl.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.
simpl.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D' C D
+++++
Col.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL C' {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
unfold IncidentL.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C' (P1 {| P1 := C'; P2 := D'; Cond := HCD' |}) (P2 {| P1 := C'; P2 := D'; Cond := HCD' |})
+++++
simpl.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.
simpl.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C' C' D'
+++++
Col.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
IncidentL D' {| P1 := C'; P2 := D'; Cond := HCD' |}
+++++
unfold IncidentL.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D' (P1 {| P1 := C'; P2 := D'; Cond := HCD' |}) (P2 {| P1 := C'; P2 := D'; Cond := HCD' |})
+++++
simpl.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.
unfold IncidentL.
simpl.

*****
H5 : Col D' C D
H4 : Col C' C D
H3 : Col P C' D'
H2 : Par A B C' D'
H1 : Col P C D
H0 : Par A B C D
H : not (Col P A B)
HCD' : not (eq C' D')
C',D' : Tpoint
HCD : not (eq C D)
P,C,D : Tpoint
HAB : not (eq A B)
A,B : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D' C' D'
+++++
Col.
-----
Lemma axiom_euclid_uniqueness : forall l P m1 m2, ~ IncidentL P l -> Para l m1 -> IncidentL P m1 -> Para l m2 -> IncidentL P m2 -> EqL m1 m2.
Proof.
intros.
destruct l as [A B HAB].
destruct m1 as [C D HCD].
destruct m2 as [C' D' HCD'].
unfold IncidentL in *.
simpl in *.
apply Para_Par in H0.
apply Para_Par in H2.
elim (tarski_s_euclid_implies_playfair euclid A B C D C' D' P H0 H1 H2 H3).
intros.
apply axiom_line_uniqueness with C' D'.

*****

*****

+++++
Qed.
-----
Instance Hilbert_euclidean_follows_from_Tarski_euclidean :\n  Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral.
-----
Instance Hilbert_euclidean_follows_from_Tarski_euclidean : Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral
+++++
Proof.
-----
Instance Hilbert_euclidean_follows_from_Tarski_euclidean : Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral.
Proof.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral
+++++
split.
-----
Instance Hilbert_euclidean_follows_from_Tarski_euclidean : Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (l : hilbert_axioms.Line) (P : Point) (m1 m2 : hilbert_axioms.Line) (_ : not (IncidL P l)) (_ : and (not (ex (fun X : Point => and (IncidL X l) (IncidL X m1)))) (ex (fun p : hilbert_axioms.Plane => and (IncidLP l p) (IncidLP m1 p)))) (_ : IncidL P m1) (_ : and (not (ex (fun X : Point => and (IncidL X l) (IncidL X m2)))) (ex (fun p : hilbert_axioms.Plane => and (IncidLP l p) (IncidLP m2 p)))) (_ : IncidL P m2), hilbert_axioms.EqL m1 m2
+++++
apply axiom_euclid_uniqueness.
-----
Instance Hilbert_euclidean_follows_from_Tarski_euclidean : Hilbert_euclidean Hilbert_neutral_follows_from_Tarski_neutral.
Proof.
split.
apply axiom_euclid_uniqueness.

*****

*****

+++++
Defined.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean :\n  Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean
+++++
Proof.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean
+++++
split.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.

*****
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall l m : hilbert_axioms.Line, or (ex (fun I : Point => and (IncidL I l) (IncidL I m))) (not (ex (fun I : Point => and (IncidL I l) (IncidL I m))))
+++++
intros l m.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Point => and (IncidL I l) (IncidL I m))) (not (ex (fun I : Point => and (IncidL I l) (IncidL I m))))
+++++
assert (ID : decidability_of_intersection).
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
decidability_of_intersection
+++++
apply strong_parallel_postulate_implies_inter_dec.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
strong_parallel_postulate
+++++
cut tarski_s_parallel_postulate.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, strong_parallel_postulate
+++++
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In strong_parallel_postulate (cons alternative_strong_parallel_postulate (cons alternative_proclus_postulate (cons euclid_5 (cons euclid_s_parallel_postulate (cons inverse_projection_postulate (cons proclus_postulate (cons strong_parallel_postulate (cons tarski_s_parallel_postulate (cons triangle_circumscription_principle nil)))))))))
+++++
simpl.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis.
simpl.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq alternative_strong_parallel_postulate strong_parallel_postulate) (or (eq alternative_proclus_postulate strong_parallel_postulate) (or (eq euclid_5 strong_parallel_postulate) (or (eq euclid_s_parallel_postulate strong_parallel_postulate) (or (eq inverse_projection_postulate strong_parallel_postulate) (or (eq proclus_postulate strong_parallel_postulate) (or (eq strong_parallel_postulate strong_parallel_postulate) (or (eq tarski_s_parallel_postulate strong_parallel_postulate) (or (eq triangle_circumscription_principle strong_parallel_postulate) False))))))))
+++++
tauto.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In tarski_s_parallel_postulate (cons alternative_strong_parallel_postulate (cons alternative_proclus_postulate (cons euclid_5 (cons euclid_s_parallel_postulate (cons inverse_projection_postulate (cons proclus_postulate (cons strong_parallel_postulate (cons tarski_s_parallel_postulate (cons triangle_circumscription_principle nil)))))))))
+++++
simpl.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis.
simpl.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq alternative_strong_parallel_postulate tarski_s_parallel_postulate) (or (eq alternative_proclus_postulate tarski_s_parallel_postulate) (or (eq euclid_5 tarski_s_parallel_postulate) (or (eq euclid_s_parallel_postulate tarski_s_parallel_postulate) (or (eq inverse_projection_postulate tarski_s_parallel_postulate) (or (eq proclus_postulate tarski_s_parallel_postulate) (or (eq strong_parallel_postulate tarski_s_parallel_postulate) (or (eq tarski_s_parallel_postulate tarski_s_parallel_postulate) (or (eq triangle_circumscription_principle tarski_s_parallel_postulate) False))))))))
+++++
tauto.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_s_parallel_postulate
+++++
unfold tarski_s_parallel_postulate.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
apply strong_parallel_postulate_implies_inter_dec.
cut tarski_s_parallel_postulate.
unfold tarski_s_parallel_postulate.

*****
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Bet A B X) (and (Bet A C Y) (Bet X T Y))))
+++++
apply euclid.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).

*****
ID : decidability_of_intersection
l,m : hilbert_axioms\.Line
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Point => and (IncidL I l) (IncidL I m))) (not (ex (fun I : Point => and (IncidL I l) (IncidL I m))))
+++++
destruct l as [L1 L2 HL].
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
destruct l as [L1 L2 HL].

*****
ID : decidability_of_intersection
m : hilbert_axioms\.Line
HL : not (eq L1 L2)
L1,L2 : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Point => and (IncidL I {| P1 := L1; P2 := L2; Cond := HL |}) (IncidL I m))) (not (ex (fun I : Point => and (IncidL I {| P1 := L1; P2 := L2; Cond := HL |}) (IncidL I m))))
+++++
destruct m as [M1 M2 HM].
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
destruct l as [L1 L2 HL].
destruct m as [M1 M2 HM].

*****
ID : decidability_of_intersection
HM : not (eq M1 M2)
M1,M2 : Tpoint
HL : not (eq L1 L2)
L1,L2 : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Point => and (IncidL I {| P1 := L1; P2 := L2; Cond := HL |}) (IncidL I {| P1 := M1; P2 := M2; Cond := HM |}))) (not (ex (fun I : Point => and (IncidL I {| P1 := L1; P2 := L2; Cond := HL |}) (IncidL I {| P1 := M1; P2 := M2; Cond := HM |}))))
+++++
simpl.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
destruct l as [L1 L2 HL].
destruct m as [M1 M2 HM].
simpl.

*****
ID : decidability_of_intersection
HM : not (eq M1 M2)
M1,M2 : Tpoint
HL : not (eq L1 L2)
L1,L2 : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Tpoint => and (IncidentL I {| P1 := L1; P2 := L2; Cond := HL |}) (IncidentL I {| P1 := M1; P2 := M2; Cond := HM |}))) (not (ex (fun I : Tpoint => and (IncidentL I {| P1 := L1; P2 := L2; Cond := HL |}) (IncidentL I {| P1 := M1; P2 := M2; Cond := HM |}))))
+++++
unfold IncidentL.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
destruct l as [L1 L2 HL].
destruct m as [M1 M2 HM].
simpl.
unfold IncidentL.

*****
ID : decidability_of_intersection
HM : not (eq M1 M2)
M1,M2 : Tpoint
HL : not (eq L1 L2)
L1,L2 : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Tpoint => and (Col I (P1 {| P1 := L1; P2 := L2; Cond := HL |}) (P2 {| P1 := L1; P2 := L2; Cond := HL |})) (Col I (P1 {| P1 := M1; P2 := M2; Cond := HM |}) (P2 {| P1 := M1; P2 := M2; Cond := HM |})))) (not (ex (fun I : Tpoint => and (Col I (P1 {| P1 := L1; P2 := L2; Cond := HL |}) (P2 {| P1 := L1; P2 := L2; Cond := HL |})) (Col I (P1 {| P1 := M1; P2 := M2; Cond := HM |}) (P2 {| P1 := M1; P2 := M2; Cond := HM |})))))
+++++
simpl.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).
destruct l as [L1 L2 HL].
destruct m as [M1 M2 HM].
simpl.
unfold IncidentL.
simpl.

*****
ID : decidability_of_intersection
HM : not (eq M1 M2)
M1,M2 : Tpoint
HL : not (eq L1 L2)
L1,L2 : Tpoint
TE : Tarski_euclidean TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (ex (fun I : Tpoint => and (Col I L1 L2) (Col I M1 M2))) (not (ex (fun I : Tpoint => and (Col I L1 L2) (Col I M1 M2))))
+++++
apply ID.
-----
Instance Hilbert_euclidean_ID_follows_from_Tarski_euclidean : Hilbert_euclidean_ID Hilbert_euclidean_follows_from_Tarski_euclidean.
Proof.
split.
intros l m.
assert (ID : decidability_of_intersection).

*****

*****

+++++
Defined.
-----
End Tarski_Euclidean_to_Hilbert_Euclidean.
-----
