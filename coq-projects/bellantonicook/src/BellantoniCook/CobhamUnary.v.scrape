From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import BellantoniCook.Lib BellantoniCook.MultiPoly BellantoniCook.Cobham BellantoniCook.CobhamLib.
-----
Lemma Zero_correct n l: \n  length (Sem (Zero_e n) l) = 0.
-----
Lemma Zero_correct n l: length (Sem (Zero_e n) l) = 0.

*****
l : list (list bool)
n : nat
*****
eq (length (Sem (Zero_e n) l)) O
+++++
Proof.
-----
Lemma Zero_correct n l: length (Sem (Zero_e n) l) = 0.
Proof.

*****
l : list (list bool)
n : nat
*****
eq (length (Sem (Zero_e n) l)) O
+++++
trivial.
-----
Lemma Zero_correct n l: length (Sem (Zero_e n) l) = 0.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma One_correct n l: \n  length (Sem (One_e n) l) = 1.
-----
Lemma One_correct n l: length (Sem (One_e n) l) = 1.

*****
l : list (list bool)
n : nat
*****
eq (length (Sem (One_e n) l)) (S O)
+++++
Proof.
-----
Lemma One_correct n l: length (Sem (One_e n) l) = 1.
Proof.

*****
l : list (list bool)
n : nat
*****
eq (length (Sem (One_e n) l)) (S O)
+++++
trivial.
-----
Lemma One_correct n l: length (Sem (One_e n) l) = 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Definition Succ_e : Cobham :=\n  Comp 1 (Succ true) [Proj 1 0].
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.

*****

*****
eq (arity Succ_e) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.
Proof.

*****

*****
eq (arity Succ_e) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Succ : arity Succ_e = ok_arity 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Succ :\n  rec_bounded Succ_e.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.

*****

*****
rec_bounded Succ_e
+++++
Proof.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.

*****

*****
rec_bounded Succ_e
+++++
simpl.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.

*****

*****
and True (and True True)
+++++
tauto.
-----
Lemma rec_bounded_Succ : rec_bounded Succ_e.
Proof.
simpl.
tauto.

*****

*****

+++++
Qed.
-----
Lemma Succ_correct l : \n  length (Sem Succ_e l) = S (length (Sem (Proj 1 0) l)).
-----
Lemma Succ_correct l : length (Sem Succ_e l) = S (length (Sem (Proj 1 0) l)).

*****
l : list (list bool)
*****
eq (length (Sem Succ_e l)) (S (length (Sem (Proj (S O) O) l)))
+++++
Proof.
-----
Lemma Succ_correct l : length (Sem Succ_e l) = S (length (Sem (Proj 1 0) l)).
Proof.

*****
l : list (list bool)
*****
eq (length (Sem Succ_e l)) (S (length (Sem (Proj (S O) O) l)))
+++++
trivial.
-----
Lemma Succ_correct l : length (Sem Succ_e l) = S (length (Sem (Proj 1 0) l)).
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Opaque Succ_e.
-----
Fixpoint Nat_e (n:nat) : Cobham :=\n  match n with\n    | 0 => Zero\n    | S n' => Comp 0 Succ_e [Nat_e n']\n  end.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.

*****
n : nat
*****
eq (arity (Nat_e n)) (ok_arity O)
+++++
Proof.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.

*****
n : nat
*****
eq (arity (Nat_e n)) (ok_arity O)
+++++
induction n.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.

*****

*****
eq (arity (Nat_e O)) (ok_arity O)
+++++
trivial.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.

*****
IHn : eq (arity (Nat_e n)) (ok_arity O)
n : nat
*****
eq (arity (Nat_e (S n))) (ok_arity O)
+++++
trivial.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.
trivial.

*****
IHn : eq (arity (Nat_e n)) (ok_arity O)
n : nat
*****
eq (arity (Nat_e (S n))) (ok_arity O)
+++++
simpl.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.
trivial.
simpl.

*****
IHn : eq (arity (Nat_e n)) (ok_arity O)
n : nat
*****
eq match arity Succ_e with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) (cons (arity (Nat_e n)) nil) | error_Comp a l => error_Comp (error_Comp a l) (cons (arity (Nat_e n)) nil) | error_Proj n0 n1 => error_Comp (error_Proj n0 n1) (cons (arity (Nat_e n)) nil) | ok_arity nh => if andb (Nat.eqb nh (S O)) (andb (arity_eq (arity (Nat_e n)) (ok_arity O)) true) then ok_arity O else error_Comp (ok_arity nh) (cons (arity (Nat_e n)) nil) end (ok_arity O)
+++++
rewrite arity_Succ.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.
trivial.
simpl.
rewrite arity_Succ.

*****
IHn : eq (arity (Nat_e n)) (ok_arity O)
n : nat
*****
eq (if andb (Nat.eqb (S O) (S O)) (andb (arity_eq (arity (Nat_e n)) (ok_arity O)) true) then ok_arity O else error_Comp (ok_arity (S O)) (cons (arity (Nat_e n)) nil)) (ok_arity O)
+++++
rewrite IHn.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.
trivial.
simpl.
rewrite arity_Succ.
rewrite IHn.

*****
IHn : eq (arity (Nat_e n)) (ok_arity O)
n : nat
*****
eq (if andb (Nat.eqb (S O) (S O)) (andb (arity_eq (ok_arity O) (ok_arity O)) true) then ok_arity O else error_Comp (ok_arity (S O)) (cons (ok_arity O) nil)) (ok_arity O)
+++++
simpl.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.
trivial.
simpl.
rewrite arity_Succ.
rewrite IHn.
simpl.

*****
IHn : eq (arity (Nat_e n)) (ok_arity O)
n : nat
*****
eq (ok_arity O) (ok_arity O)
+++++
trivial.
-----
Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Nat n :\n  rec_bounded (Nat_e n).
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).

*****
n : nat
*****
rec_bounded (Nat_e n)
+++++
Proof.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.

*****
n : nat
*****
rec_bounded (Nat_e n)
+++++
induction n.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.

*****

*****
rec_bounded (Nat_e O)
+++++
simpl.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.
simpl.

*****

*****
True
+++++
trivial.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.

*****
IHn : rec_bounded (Nat_e n)
n : nat
*****
rec_bounded (Nat_e (S n))
+++++
simpl.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.
simpl.

*****
IHn : rec_bounded (Nat_e n)
n : nat
*****
and (rec_bounded Succ_e) (and (rec_bounded (Nat_e n)) True)
+++++
trivial.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.
simpl.
trivial.

*****
IHn : rec_bounded (Nat_e n)
n : nat
*****
and (rec_bounded Succ_e) (and (rec_bounded (Nat_e n)) True)
+++++
split.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.
simpl.
trivial.
split.

*****
IHn : rec_bounded (Nat_e n)
n : nat
*****
rec_bounded Succ_e
+++++
auto.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.
simpl.
trivial.
split.
auto.

*****
IHn : rec_bounded (Nat_e n)
n : nat
*****
rec_bounded Succ_e
+++++
apply rec_bounded_Succ.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.
simpl.
trivial.
split.

*****
IHn : rec_bounded (Nat_e n)
n : nat
*****
and (rec_bounded (Nat_e n)) True
+++++
auto.
-----
Lemma rec_bounded_Nat n : rec_bounded (Nat_e n).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma Nat_correct : forall n l,\n  length (Sem (Nat_e n) l) = n.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.

*****

*****
forall (n : nat) (l : list (list bool)), eq (length (Sem (Nat_e n) l)) n
+++++
Proof.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.

*****

*****
forall (n : nat) (l : list (list bool)), eq (length (Sem (Nat_e n) l)) n
+++++
induction n.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.

*****

*****
forall l : list (list bool), eq (length (Sem (Nat_e O) l)) O
+++++
simpl.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.

*****

*****
forall _ : list (list bool), eq O O
+++++
intros.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.
intros.

*****
l : list (list bool)
*****
eq O O
+++++
trivial.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.

*****
IHn : forall l : list (list bool), eq (length (Sem (Nat_e n) l)) n
n : nat
*****
forall l : list (list bool), eq (length (Sem (Nat_e (S n)) l)) (S n)
+++++
simpl.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.

*****
IHn : forall l : list (list bool), eq (length (Sem (Nat_e n) l)) n
n : nat
*****
forall l : list (list bool), eq (length (Sem Succ_e (cons (Sem (Nat_e n) l) nil))) (S n)
+++++
intros.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.
intros.

*****
l : list (list bool)
IHn : forall l : list (list bool), eq (length (Sem (Nat_e n) l)) n
n : nat
*****
eq (length (Sem Succ_e (cons (Sem (Nat_e n) l) nil))) (S n)
+++++
trivial.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.
intros.
trivial.

*****
l : list (list bool)
IHn : forall l : list (list bool), eq (length (Sem (Nat_e n) l)) n
n : nat
*****
eq (length (Sem Succ_e (cons (Sem (Nat_e n) l) nil))) (S n)
+++++
rewrite Succ_correct.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.
intros.
trivial.
rewrite Succ_correct.

*****
l : list (list bool)
IHn : forall l : list (list bool), eq (length (Sem (Nat_e n) l)) n
n : nat
*****
eq (S (length (Sem (Proj (S O) O) (cons (Sem (Nat_e n) l) nil)))) (S n)
+++++
simpl.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.
simpl.
intros.
trivial.
rewrite Succ_correct.
simpl.

*****
l : list (list bool)
IHn : forall l : list (list bool), eq (length (Sem (Nat_e n) l)) n
n : nat
*****
eq (S (length (Sem (Nat_e n) l))) (S n)
+++++
auto.
-----
Lemma Nat_correct : forall n l, length (Sem (Nat_e n) l) = n.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Notation Plus_e := App_e.
-----
Notation arity_Plus := arity_App.
-----
Notation rec_bounded_Plus := rec_bounded_App.
-----
Lemma Plus_correct : forall l,\n  length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).
-----
Lemma Plus_correct : forall l, length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).

*****

*****
forall l : list (list bool), eq (length (Sem App_e l)) (Init.Nat.add (length (hd nil l)) (length (hd nil (tl l))))
+++++
Proof.
-----
Lemma Plus_correct : forall l, length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).
Proof.

*****

*****
forall l : list (list bool), eq (length (Sem App_e l)) (Init.Nat.add (length (hd nil l)) (length (hd nil (tl l))))
+++++
intro l.
-----
Lemma Plus_correct : forall l, length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).
Proof.
intro l.

*****
l : list (list bool)
*****
eq (length (Sem App_e l)) (Init.Nat.add (length (hd nil l)) (length (hd nil (tl l))))
+++++
rewrite App_correct.
-----
Lemma Plus_correct : forall l, length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).
Proof.
intro l.
rewrite App_correct.

*****
l : list (list bool)
*****
eq (length (app (hd nil l) (hd nil (tl l)))) (Init.Nat.add (length (hd nil l)) (length (hd nil (tl l))))
+++++
apply app_length.
-----
Lemma Plus_correct : forall l, length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).
Proof.
intro l.
rewrite App_correct.
apply app_length.

*****

*****

+++++
Qed.
-----
Opaque Plus_e.
-----
Fixpoint Plusl_e (ar:nat)(el:list Cobham) : Cobham :=\n  match el with\n    | nil => Zero_e ar\n    | e' :: el' => Comp ar Plus_e [e'; Plusl_e ar el']\n  end.
-----
Lemma arity_Plusl ar el : \n  andl (fun e => arity e = ok_arity ar) el ->\n  arity (Plusl_e ar el) = ok_arity ar.
-----
Lemma arity_Plusl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Plusl_e ar el) = ok_arity ar.

*****
el : list Cobham
ar : nat
*****
forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el, eq (arity (Plusl_e ar el)) (ok_arity ar)
+++++
Proof.
-----
Lemma arity_Plusl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Plusl_e ar el) = ok_arity ar.
Proof.

*****
el : list Cobham
ar : nat
*****
forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el, eq (arity (Plusl_e ar el)) (ok_arity ar)
+++++
induction el as [ | e' el' IH]; simpl; trivial; intros (H1, H2).
-----
Lemma arity_Plusl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Plusl_e ar el) = ok_arity ar.
Proof.
induction el as [ | e' el' IH]; simpl; trivial; intros (H1, H2).

*****
H2 : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el'
H1 : eq (arity e') (ok_arity ar)
IH : forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el',\neq (arity (Plusl_e ar el')) (ok_arity ar)
el' : list Cobham
e' : Cobham
ar : nat
*****
eq match arity App_e with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) (cons (arity e') (cons (arity (Plusl_e ar el')) nil)) | error_Comp a l => error_Comp (error_Comp a l) (cons (arity e') (cons (arity (Plusl_e ar el')) nil)) | error_Proj n n0 => error_Comp (error_Proj n n0) (cons (arity e') (cons (arity (Plusl_e ar el')) nil)) | ok_arity nh => if andb (Nat.eqb nh (S (S O))) (andb (arity_eq (arity e') (ok_arity ar)) (andb (arity_eq (arity (Plusl_e ar el')) (ok_arity ar)) true)) then ok_arity ar else error_Comp (ok_arity nh) (cons (arity e') (cons (arity (Plusl_e ar el')) nil)) end (ok_arity ar)
+++++
rewrite arity_Plus, IH, H1; simpl; trivial.
-----
Lemma arity_Plusl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Plusl_e ar el) = ok_arity ar.
Proof.
induction el as [ | e' el' IH]; simpl; trivial; intros (H1, H2).
rewrite arity_Plus, IH, H1; simpl; trivial.

*****
H2 : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el'
H1 : eq (arity e') (ok_arity ar)
IH : forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el',\neq (arity (Plusl_e ar el')) (ok_arity ar)
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (if andb (Nat.eqb ar ar) (andb (Nat.eqb ar ar) true) then ok_arity ar else error_Comp (ok_arity (S (S O))) (cons (ok_arity ar) (cons (ok_arity ar) nil))) (ok_arity ar)
+++++
rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma arity_Plusl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Plusl_e ar el) = ok_arity ar.
Proof.
induction el as [ | e' el' IH]; simpl; trivial; intros (H1, H2).
rewrite arity_Plus, IH, H1; simpl; trivial.
rewrite <- beq_nat_refl; simpl; trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Plusl ar el :\n  andl rec_bounded el -> rec_bounded (Plusl_e ar el).
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).

*****
el : list Cobham
ar : nat
*****
forall _ : andl rec_bounded el, rec_bounded (Plusl_e ar el)
+++++
Proof.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.

*****
el : list Cobham
ar : nat
*****
forall _ : andl rec_bounded el, rec_bounded (Plusl_e ar el)
+++++
induction el as [ | e' el' IH].
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].

*****
ar : nat
*****
forall _ : andl rec_bounded nil, rec_bounded (Plusl_e ar nil)
+++++
simpl.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
ar : nat
*****
forall _ : True, and True True
+++++
auto.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].

*****
IH : forall _ : andl rec_bounded el', rec_bounded (Plusl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
forall _ : andl rec_bounded (cons e' el'), rec_bounded (Plusl_e ar (cons e' el'))
+++++
simpl.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
IH : forall _ : andl rec_bounded el', rec_bounded (Plusl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
forall _ : and (rec_bounded e') (andl rec_bounded el'), and (rec_bounded App_e) (and (rec_bounded e') (and (rec_bounded (Plusl_e ar el')) True))
+++++
auto.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.

*****
IH : forall _ : andl rec_bounded el', rec_bounded (Plusl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
forall _ : and (rec_bounded e') (andl rec_bounded el'), and (rec_bounded App_e) (and (rec_bounded e') (and (rec_bounded (Plusl_e ar el')) True))
+++++
intros [H1 H2].
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.
intros [H1 H2].

*****
H2 : andl rec_bounded el'
H1 : rec_bounded e'
IH : forall _ : andl rec_bounded el', rec_bounded (Plusl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
and (rec_bounded App_e) (and (rec_bounded e') (and (rec_bounded (Plusl_e ar el')) True))
+++++
split.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.
intros [H1 H2].
split.

*****
H2 : andl rec_bounded el'
H1 : rec_bounded e'
IH : forall _ : andl rec_bounded el', rec_bounded (Plusl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
rec_bounded App_e
+++++
apply rec_bounded_Plus.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.
intros [H1 H2].
split.

*****
H2 : andl rec_bounded el'
H1 : rec_bounded e'
IH : forall _ : andl rec_bounded el', rec_bounded (Plusl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
and (rec_bounded e') (and (rec_bounded (Plusl_e ar el')) True)
+++++
tauto.
-----
Lemma rec_bounded_Plusl ar el : andl rec_bounded el -> rec_bounded (Plusl_e ar el).
Proof.
induction el as [ | e' el' IH].

*****

*****

+++++
Qed.
-----
Lemma Plusl_correct : forall ar el l,\n  length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).

*****

*****
forall (ar : nat) (el : list Cobham) (l : list (list bool)), eq (length (Sem (Plusl_e ar el) l)) (plusl (map (fun e : Cobham => length (Sem e l)) el))
+++++
Proof.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.

*****

*****
forall (ar : nat) (el : list Cobham) (l : list (list bool)), eq (length (Sem (Plusl_e ar el) l)) (plusl (map (fun e : Cobham => length (Sem e l)) el))
+++++
induction el as [ | e' el' IH].
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].

*****
ar : nat
*****
forall l : list (list bool), eq (length (Sem (Plusl_e ar nil) l)) (plusl (map (fun e : Cobham => length (Sem e l)) nil))
+++++
simpl.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
ar : nat
*****
forall _ : list (list bool), eq O O
+++++
trivial.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].

*****
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
forall l : list (list bool), eq (length (Sem (Plusl_e ar (cons e' el')) l)) (plusl (map (fun e : Cobham => length (Sem e l)) (cons e' el')))
+++++
simpl.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
forall l : list (list bool), eq (length (Sem App_e (cons (Sem e' l) (cons (Sem (Plusl_e ar el') l) nil)))) (Init.Nat.add (length (Sem e' l)) (plusl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
trivial.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.

*****
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
forall l : list (list bool), eq (length (Sem App_e (cons (Sem e' l) (cons (Sem (Plusl_e ar el') l) nil)))) (Init.Nat.add (length (Sem e' l)) (plusl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
intros.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (length (Sem App_e (cons (Sem e' l) (cons (Sem (Plusl_e ar el') l) nil)))) (Init.Nat.add (length (Sem e' l)) (plusl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
rewrite Plus_correct.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.
rewrite Plus_correct.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (Init.Nat.add (length (hd nil (cons (Sem e' l) (cons (Sem (Plusl_e ar el') l) nil)))) (length (hd nil (tl (cons (Sem e' l) (cons (Sem (Plusl_e ar el') l) nil)))))) (Init.Nat.add (length (Sem e' l)) (plusl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
simpl.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.
rewrite Plus_correct.
simpl.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (Init.Nat.add (length (Sem e' l)) (length (Sem (Plusl_e ar el') l))) (Init.Nat.add (length (Sem e' l)) (plusl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
f_equal.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.
rewrite Plus_correct.
simpl.
f_equal.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Plusl_e ar el') l))\n (plusl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (length (Sem (Plusl_e ar el') l)) (plusl (map (fun e : Cobham => length (Sem e l)) el'))
+++++
apply IH.
-----
Lemma Plusl_correct : forall ar el l, length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].

*****

*****

+++++
Qed.
-----
Opaque Plusl_e.
-----
Definition Mult_e : Cobham :=\n  Rec2\n  (Zero_e 1)\n  (Comp 3 Plus_e [Proj 3 1; Proj 3 2])\n  (Comp 2 Smash [\n    One_e 2;\n    Comp 2 Smash [Comp 2 (Succ true) [Proj 2 0]; Comp 2 (Succ true) [Proj 2 1] ] ] ).
-----
Lemma arity_Mult : arity Mult_e = ok_arity 2.
-----
Lemma arity_Mult : arity Mult_e = ok_arity 2.

*****

*****
eq (arity Mult_e) (ok_arity (S (S O)))
+++++
Proof.
-----
Lemma arity_Mult : arity Mult_e = ok_arity 2.
Proof.

*****

*****
eq (arity Mult_e) (ok_arity (S (S O)))
+++++
trivial.
-----
Lemma arity_Mult : arity Mult_e = ok_arity 2.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.

*****

*****
rec_bounded Mult_e
+++++
Proof.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.

*****

*****
rec_bounded Mult_e
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.

*****

*****
and (and True (and (and (and True (and True True)) True) (and (and True (and (and True (and True True)) (and (and True (and True True)) True))) True))) (and (and True True) (and (and (rec_bounded App_e) (and True (and True True))) (and (and (rec_bounded App_e) (and True (and True True))) (forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil l) (tl l))) (S (length (smash' (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil)))) (cons true nil))))))))
+++++
repeat (split; trivial).
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).

*****

*****
forall l : list (list bool), le (length (Sem (Rec (Proj (S O) O) (Comp (S (S (S O))) (Succ false) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S (S O))) (Succ true) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil)))) l)) (length (Sem (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil))) l))
+++++
intros.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.

*****
l : list (list bool)
*****
le (length (Sem (Rec (Proj (S O) O) (Comp (S (S (S O))) (Succ false) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S (S O))) (Succ true) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil)))) l)) (length (Sem (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil))) l))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (hd nil l) (tl l))) (S (length (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil))))))
+++++
destruct l.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (hd nil nil) (tl nil))) (S (length (smash' (nth (S O) nil nil) (smash_bs (nth O nil nil) (cons true (nth (S O) nil nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.

*****

*****
le O (S (S O))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (hd nil (cons l l0)) (tl (cons l l0)))) (S (length (smash' (nth (S O) (cons l l0) nil) (smash_bs (nth O (cons l l0) nil) (cons true (nth (S O) (cons l l0) nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs l (cons true (nth O l0 nil))))))
+++++
induction l.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.

*****
l0 : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) nil l0)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs nil (cons true (nth O l0 nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.

*****
l0 : list (list bool)
*****
le (length (nth O l0 nil)) (S (Init.Nat.add (length (nth O l0 nil)) (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (cons a l) l0)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs (cons a l) (cons true (nth O l0 nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (if a then cons true (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0) else cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (if a then cons true (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0) else cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
case a.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (cons true (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs l (cons true (nth O l0 nil))))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs l (cons true (nth O l0 nil))))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).

*****

*****
forall l : list (list bool), le (length (Sem (Rec (Proj (S O) O) (Comp (S (S (S O))) (Succ false) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S (S O))) (Succ true) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil)))) l)) (length (Sem (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil))) l))
+++++
intros.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.

*****
l : list (list bool)
*****
le (length (Sem (Rec (Proj (S O) O) (Comp (S (S (S O))) (Succ false) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S (S O))) (Succ true) (cons (Proj (S (S (S O))) (S O)) nil)) (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil)))) l)) (length (Sem (Comp (S (S O)) Smash (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) O) nil)) (cons (Comp (S (S O)) (Succ true) (cons (Proj (S (S O)) (S O)) nil)) nil))) l))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (hd nil l) (tl l))) (S (length (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil))))))
+++++
destruct l.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.

*****

*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (hd nil nil) (tl nil))) (S (length (smash' (nth (S O) nil nil) (smash_bs (nth O nil nil) (cons true (nth (S O) nil nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.

*****

*****
le O (S (S O))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (hd nil (cons l l0)) (tl (cons l l0)))) (S (length (smash' (nth (S O) (cons l l0) nil) (smash_bs (nth O (cons l l0) nil) (cons true (nth (S O) (cons l l0) nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs l (cons true (nth O l0 nil))))))
+++++
induction l.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.

*****
l0 : list (list bool)
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) nil l0)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs nil (cons true (nth O l0 nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.

*****
l0 : list (list bool)
*****
le (length (nth O l0 nil)) (S (Init.Nat.add (length (nth O l0 nil)) (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) (cons a l) l0)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs (cons a l) (cons true (nth O l0 nil))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (if a then cons true (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0) else cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (if a then cons true (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0) else cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
case a.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (cons true (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs l (cons true (nth O l0 nil))))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (cons false (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.

*****
IHl : le\n (length\n (sem_Rec (fun vl : list (list bool) => nth O vl nil)\n (fun vl : list (list bool) => cons false (nth (S O) vl nil))\n (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l\n l0))\n (S\n (Init.Nat.add (length (nth O l0 nil))\n (length (smash_bs l (cons true (nth O l0 nil))))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (length (sem_Rec (fun vl : list (list bool) => nth O vl nil) (fun vl : list (list bool) => cons false (nth (S O) vl nil)) (fun vl : list (list bool) => cons true (nth (S O) vl nil)) l l0))) (S (Init.Nat.add (length (nth O l0 nil)) (S (Init.Nat.add (length (nth O l0 nil)) (length (smash_bs l (cons true (nth O l0 nil))))))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).

*****

*****
forall l : list (list bool), le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil l) (tl l))) (S (length (smash' (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil)))) (cons true nil))))
+++++
intros.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil l) (tl l))) (S (length (smash' (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil)))) (cons true nil))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.

*****
l : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil l) (tl l))) (S (length (smash' (smash' (nth (S O) l nil) (smash_bs (nth O l nil) (cons true (nth (S O) l nil)))) (cons true nil))))
+++++
destruct l.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.

*****

*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil nil) (tl nil))) (S (length (smash' (smash' (nth (S O) nil nil) (smash_bs (nth O nil nil) (cons true (nth (S O) nil nil)))) (cons true nil))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.

*****

*****
le O (S (S (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil (cons l l0)) (tl (cons l l0)))) (S (length (smash' (smash' (nth (S O) (cons l l0) nil) (smash_bs (nth O (cons l l0) nil) (cons true (nth (S O) (cons l l0) nil)))) (cons true nil))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (S (length (smash' (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil)))) (cons true nil))))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (S (length (smash' (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil)))) (cons true nil))))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.

*****
l0 : list (list bool)
l : list bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (S (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))) (length (cons true nil))))
+++++
induction l.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.

*****
l0 : list (list bool)
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) nil l0)) (S (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs nil (cons true (nth O l0 nil))))) (length (cons true nil))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.

*****
l0 : list (list bool)
*****
le O (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons true nil))) (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (cons a l) l0)) (S (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs (cons a l) (cons true (nth O l0 nil))))) (length (cons true nil))))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (if a then Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)) else Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (if a then Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)) else Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
case a.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (length (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (length (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
rewrite App_correct.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (app (hd nil (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil))) (hd nil (tl (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (length (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (app (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (nth O l0 nil))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl_list.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (Init.Nat.add (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (length (nth O l0 nil))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
eapply le_trans.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (Init.Nat.add (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (length (nth O l0 nil))) ?m
+++++
apply plus_le_compat_r.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.
apply plus_le_compat_r.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) ?m
+++++
apply IHl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (Init.Nat.add (S (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))) (length (cons true nil)))) (length (nth O l0 nil))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (Init.Nat.add (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))) (S O)) (length (nth O l0 nil)))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (length (smash' (nth O l0 nil) (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
rewrite length_smash'.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (length (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
try omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (length (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
rewrite App_correct.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (app (hd nil (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil))) (hd nil (tl (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (cons (nth O l0 nil) nil)))))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (length (cons false (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (app (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0) (nth O l0 nil))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl_list.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (Init.Nat.add (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (length (nth O l0 nil))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
eapply le_trans.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (Init.Nat.add (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) (length (nth O l0 nil))) ?m
+++++
apply plus_le_compat_r.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.
apply plus_le_compat_r.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) l l0)) ?m
+++++
apply IHl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (Init.Nat.add (S (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))) (length (cons true nil)))) (length (nth O l0 nil))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
simpl.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).
intros.
simpl.
destruct l.
simpl.
try omega.
rewrite length_smash'.
induction l.
simpl.
try omega.
case a.
simpl.
rewrite length_smash'.
try omega.
rewrite App_correct.
simpl.
simpl_list.
eapply le_trans.
simpl.

*****
IHl : le\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n l l0))\n (S\n (Init.Nat.add\n (length\n (smash' (nth O l0 nil)\n (smash_bs l (cons true (nth O l0 nil)))))\n (length (cons true nil))))
l0 : list (list bool)
l : list bool
a : bool
*****
le (S (Init.Nat.add (Init.Nat.add (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))) (S O)) (length (nth O l0 nil)))) (S (Init.Nat.add (Init.Nat.add (length (nth O l0 nil)) (S (length (smash' (nth O l0 nil) (smash_bs l (cons true (nth O l0 nil))))))) (S O)))
+++++
omega.
-----
Lemma rec_bounded_Mult : rec_bounded Mult_e.
Proof.
simpl.
repeat (split; trivial).

*****

*****

+++++
Qed.
-----
Lemma Mult_correct : forall l,\n  length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).

*****

*****
forall l : list (list bool), eq (length (Sem Mult_e l)) (Init.Nat.mul (length (hd nil l)) (length (hd nil (tl l))))
+++++
Proof.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.

*****

*****
forall l : list (list bool), eq (length (Sem Mult_e l)) (Init.Nat.mul (length (hd nil l)) (length (hd nil (tl l))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.

*****

*****
forall l : list (list bool), eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil l) (tl l))) (Init.Nat.mul (length (hd nil l)) (length (hd nil (tl l))))
+++++
intros [ | v1 ].
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].

*****

*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil nil) (tl nil))) (Init.Nat.mul (length (hd nil nil)) (length (hd nil (tl nil))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.

*****

*****
eq O O
+++++
trivial.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].

*****
l : list (list bool)
v1 : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (hd nil (cons v1 l)) (tl (cons v1 l)))) (Init.Nat.mul (length (hd nil (cons v1 l))) (length (hd nil (tl (cons v1 l)))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.

*****
l : list (list bool)
v1 : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
+++++
trivial.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.

*****
l : list (list bool)
v1 : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
+++++
intros.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.

*****
l : list (list bool)
v1 : list bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
+++++
induction v1.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.

*****
l : list (list bool)
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) nil l)) (Init.Nat.mul (length nil) (length (hd nil l)))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.

*****
l : list (list bool)
*****
eq O O
+++++
trivial.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (cons a v1) l)) (Init.Nat.mul (length (cons a v1)) (length (hd nil l)))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (if a then Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)) else Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
trivial.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (if a then Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)) else Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
case a.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
rewrite Plus_correct.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (Init.Nat.add (length (hd nil (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (length (hd nil (tl (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (Init.Nat.add (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l)) (length (nth O l nil))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
rewrite IHv1.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length (hd nil l))) (length (nth O l nil))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
destruct l.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 nil)) (Init.Nat.mul (length v1) (length (hd nil nil)))
v1 : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length (hd nil nil))) (length (nth O nil nil))) (Init.Nat.add (length (hd nil nil)) (Init.Nat.mul (length v1) (length (hd nil nil))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 nil)) (Init.Nat.mul (length v1) (length (hd nil nil)))
v1 : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) O) O) (Init.Nat.mul (length v1) O)
+++++
omega.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 (cons l l0)))\n (Init.Nat.mul (length v1) (length (hd nil (cons l l0))))
l0 : list (list bool)
v1,l : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length (hd nil (cons l l0)))) (length (nth O (cons l l0) nil))) (Init.Nat.add (length (hd nil (cons l l0))) (Init.Nat.mul (length v1) (length (hd nil (cons l l0)))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 (cons l l0)))\n (Init.Nat.mul (length v1) (length (hd nil (cons l l0))))
l0 : list (list bool)
v1,l : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length l)) (length l)) (Init.Nat.add (length l) (Init.Nat.mul (length v1) (length l)))
+++++
omega.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (length (Sem App_e (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
rewrite Plus_correct.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (Init.Nat.add (length (hd nil (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))) (length (hd nil (tl (cons (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l) (cons (nth O l nil) nil)))))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (Init.Nat.add (length (sem_Rec (fun _ : list (list bool) => nil) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) (fun vl : list (list bool) => Sem App_e (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil))) v1 l)) (length (nth O l nil))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
rewrite IHv1.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 l)) (Init.Nat.mul (length v1) (length (hd nil l)))
l : list (list bool)
v1 : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length (hd nil l))) (length (nth O l nil))) (Init.Nat.add (length (hd nil l)) (Init.Nat.mul (length v1) (length (hd nil l))))
+++++
destruct l.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 nil)) (Init.Nat.mul (length v1) (length (hd nil nil)))
v1 : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length (hd nil nil))) (length (nth O nil nil))) (Init.Nat.add (length (hd nil nil)) (Init.Nat.mul (length v1) (length (hd nil nil))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 nil)) (Init.Nat.mul (length v1) (length (hd nil nil)))
v1 : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) O) O) (Init.Nat.mul (length v1) O)
+++++
omega.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 (cons l l0)))\n (Init.Nat.mul (length v1) (length (hd nil (cons l l0))))
l0 : list (list bool)
v1,l : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length (hd nil (cons l l0)))) (length (nth O (cons l l0) nil))) (Init.Nat.add (length (hd nil (cons l l0))) (Init.Nat.mul (length v1) (length (hd nil (cons l l0)))))
+++++
simpl.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].
simpl.
trivial.
intros.
induction v1.
simpl.
trivial.
case a.
simpl.
rewrite Plus_correct.
simpl.
rewrite IHv1.
destruct l.
simpl.

*****
IHv1 : eq\n (length\n (sem_Rec (fun _ : list (list bool) => nil)\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n (fun vl : list (list bool) =>\n Sem App_e\n (cons (nth (S O) vl nil) (cons (nth (S (S O)) vl nil) nil)))\n v1 (cons l l0)))\n (Init.Nat.mul (length v1) (length (hd nil (cons l l0))))
l0 : list (list bool)
v1,l : list bool
a : bool
*****
eq (Init.Nat.add (Init.Nat.mul (length v1) (length l)) (length l)) (Init.Nat.add (length l) (Init.Nat.mul (length v1) (length l)))
+++++
omega.
-----
Lemma Mult_correct : forall l, length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).
Proof.
simpl.
intros [ | v1 ].

*****

*****

+++++
Qed.
-----
Opaque Mult_e.
-----
Fixpoint Multl_e (ar:nat)(el:list Cobham) : Cobham :=\n  match el with\n    | nil => One_e ar\n    | e' :: el' => Comp ar Mult_e [e'; Multl_e ar el']\n  end.
-----
Lemma arity_Multl ar el : \n  andl (fun e => arity e = ok_arity ar) el ->\n  arity (Multl_e ar el) = ok_arity ar.
-----
Lemma arity_Multl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Multl_e ar el) = ok_arity ar.

*****
el : list Cobham
ar : nat
*****
forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el, eq (arity (Multl_e ar el)) (ok_arity ar)
+++++
Proof.
-----
Lemma arity_Multl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Multl_e ar el) = ok_arity ar.
Proof.

*****
el : list Cobham
ar : nat
*****
forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el, eq (arity (Multl_e ar el)) (ok_arity ar)
+++++
induction el as [ | e' el' IH]; simpl; trivial; intros [H1 H2].
-----
Lemma arity_Multl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Multl_e ar el) = ok_arity ar.
Proof.
induction el as [ | e' el' IH]; simpl; trivial; intros [H1 H2].

*****
H2 : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el'
H1 : eq (arity e') (ok_arity ar)
IH : forall _ : andl (fun e : Cobham => eq (arity e) (ok_arity ar)) el',\neq (arity (Multl_e ar el')) (ok_arity ar)
el' : list Cobham
e' : Cobham
ar : nat
*****
eq match arity Mult_e with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) (cons (arity e') (cons (arity (Multl_e ar el')) nil)) | error_Comp a l => error_Comp (error_Comp a l) (cons (arity e') (cons (arity (Multl_e ar el')) nil)) | error_Proj n n0 => error_Comp (error_Proj n n0) (cons (arity e') (cons (arity (Multl_e ar el')) nil)) | ok_arity nh => if andb (Nat.eqb nh (S (S O))) (andb (arity_eq (arity e') (ok_arity ar)) (andb (arity_eq (arity (Multl_e ar el')) (ok_arity ar)) true)) then ok_arity ar else error_Comp (ok_arity nh) (cons (arity e') (cons (arity (Multl_e ar el')) nil)) end (ok_arity ar)
+++++
rewrite arity_Mult, IH, H1; simpl; trivial; rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma arity_Multl ar el : andl (fun e => arity e = ok_arity ar) el -> arity (Multl_e ar el) = ok_arity ar.
Proof.
induction el as [ | e' el' IH]; simpl; trivial; intros [H1 H2].
rewrite arity_Mult, IH, H1; simpl; trivial; rewrite <- beq_nat_refl; simpl; trivial.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Multl ar el :\n  andl rec_bounded el -> rec_bounded (Multl_e ar el).
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).

*****
el : list Cobham
ar : nat
*****
forall _ : andl rec_bounded el, rec_bounded (Multl_e ar el)
+++++
Proof.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.

*****
el : list Cobham
ar : nat
*****
forall _ : andl rec_bounded el, rec_bounded (Multl_e ar el)
+++++
induction el as [ | e' el' IH].
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].

*****
ar : nat
*****
forall _ : andl rec_bounded nil, rec_bounded (Multl_e ar nil)
+++++
simpl.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
ar : nat
*****
forall _ : True, and (and True (and True True)) True
+++++
auto.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].

*****
IH : forall _ : andl rec_bounded el', rec_bounded (Multl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
forall _ : andl rec_bounded (cons e' el'), rec_bounded (Multl_e ar (cons e' el'))
+++++
simpl.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
IH : forall _ : andl rec_bounded el', rec_bounded (Multl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
forall _ : and (rec_bounded e') (andl rec_bounded el'), and (rec_bounded Mult_e) (and (rec_bounded e') (and (rec_bounded (Multl_e ar el')) True))
+++++
auto.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.

*****
IH : forall _ : andl rec_bounded el', rec_bounded (Multl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
forall _ : and (rec_bounded e') (andl rec_bounded el'), and (rec_bounded Mult_e) (and (rec_bounded e') (and (rec_bounded (Multl_e ar el')) True))
+++++
intros [H1 H2].
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.
intros [H1 H2].

*****
H2 : andl rec_bounded el'
H1 : rec_bounded e'
IH : forall _ : andl rec_bounded el', rec_bounded (Multl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
and (rec_bounded Mult_e) (and (rec_bounded e') (and (rec_bounded (Multl_e ar el')) True))
+++++
split.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.
intros [H1 H2].
split.

*****
H2 : andl rec_bounded el'
H1 : rec_bounded e'
IH : forall _ : andl rec_bounded el', rec_bounded (Multl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
rec_bounded Mult_e
+++++
apply rec_bounded_Mult.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].
simpl.
auto.
intros [H1 H2].
split.

*****
H2 : andl rec_bounded el'
H1 : rec_bounded e'
IH : forall _ : andl rec_bounded el', rec_bounded (Multl_e ar el')
el' : list Cobham
e' : Cobham
ar : nat
*****
and (rec_bounded e') (and (rec_bounded (Multl_e ar el')) True)
+++++
tauto.
-----
Lemma rec_bounded_Multl ar el : andl rec_bounded el -> rec_bounded (Multl_e ar el).
Proof.
induction el as [ | e' el' IH].

*****

*****

+++++
Qed.
-----
Lemma Multl_correct : forall ar el l,\n  length (Sem (Multl_e ar el) l) = \n  multl (map (fun e => length (Sem e l)) el).
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).

*****

*****
forall (ar : nat) (el : list Cobham) (l : list (list bool)), eq (length (Sem (Multl_e ar el) l)) (multl (map (fun e : Cobham => length (Sem e l)) el))
+++++
Proof.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.

*****

*****
forall (ar : nat) (el : list Cobham) (l : list (list bool)), eq (length (Sem (Multl_e ar el) l)) (multl (map (fun e : Cobham => length (Sem e l)) el))
+++++
induction el as [ | e' el' IH].
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].

*****
ar : nat
*****
forall l : list (list bool), eq (length (Sem (Multl_e ar nil) l)) (multl (map (fun e : Cobham => length (Sem e l)) nil))
+++++
simpl.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
ar : nat
*****
forall _ : list (list bool), eq (S O) (S O)
+++++
trivial.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].

*****
IH : forall l : list (list bool),\neq (length (Sem (Multl_e ar el') l))\n (multl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
forall l : list (list bool), eq (length (Sem (Multl_e ar (cons e' el')) l)) (multl (map (fun e : Cobham => length (Sem e l)) (cons e' el')))
+++++
simpl.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.

*****
IH : forall l : list (list bool),\neq (length (Sem (Multl_e ar el') l))\n (multl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
forall l : list (list bool), eq (length (Sem Mult_e (cons (Sem e' l) (cons (Sem (Multl_e ar el') l) nil)))) (Init.Nat.mul (length (Sem e' l)) (multl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
trivial.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.

*****
IH : forall l : list (list bool),\neq (length (Sem (Multl_e ar el') l))\n (multl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
forall l : list (list bool), eq (length (Sem Mult_e (cons (Sem e' l) (cons (Sem (Multl_e ar el') l) nil)))) (Init.Nat.mul (length (Sem e' l)) (multl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
intros.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Multl_e ar el') l))\n (multl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (length (Sem Mult_e (cons (Sem e' l) (cons (Sem (Multl_e ar el') l) nil)))) (Init.Nat.mul (length (Sem e' l)) (multl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
rewrite Mult_correct.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.
rewrite Mult_correct.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Multl_e ar el') l))\n (multl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (Init.Nat.mul (length (hd nil (cons (Sem e' l) (cons (Sem (Multl_e ar el') l) nil)))) (length (hd nil (tl (cons (Sem e' l) (cons (Sem (Multl_e ar el') l) nil)))))) (Init.Nat.mul (length (Sem e' l)) (multl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
simpl.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].
simpl.
trivial.
intros.
rewrite Mult_correct.
simpl.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Multl_e ar el') l))\n (multl (map (fun e : Cobham => length (Sem e l)) el'))
el' : list Cobham
e' : Cobham
ar : nat
*****
eq (Init.Nat.mul (length (Sem e' l)) (length (Sem (Multl_e ar el') l))) (Init.Nat.mul (length (Sem e' l)) (multl (map (fun e : Cobham => length (Sem e l)) el')))
+++++
auto.
-----
Lemma Multl_correct : forall ar el l, length (Sem (Multl_e ar el) l) = multl (map (fun e => length (Sem e l)) el).
Proof.
induction el as [ | e' el' IH].

*****

*****

+++++
Qed.
-----
Fixpoint Power_e (n:nat) : Cobham :=\n  match n with\n    | 0 => One_e 1\n    | S n' => Comp 1 Mult_e [Proj 1 0; Power_e n']\n  end.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.

*****
n : nat
*****
eq (arity (Power_e n)) (ok_arity (S O))
+++++
Proof.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.

*****
n : nat
*****
eq (arity (Power_e n)) (ok_arity (S O))
+++++
induction n as [ | n' IH].
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].

*****

*****
eq (arity (Power_e O)) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq (arity (Power_e (S n'))) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].
trivial.

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq (arity (Power_e (S n'))) (ok_arity (S O))
+++++
simpl.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].
trivial.
simpl.

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq match arity Mult_e with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) (cons (ok_arity (S O)) (cons (arity (Power_e n')) nil)) | error_Comp a l => error_Comp (error_Comp a l) (cons (ok_arity (S O)) (cons (arity (Power_e n')) nil)) | error_Proj n n0 => error_Comp (error_Proj n n0) (cons (ok_arity (S O)) (cons (arity (Power_e n')) nil)) | ok_arity nh => if andb (Nat.eqb nh (S (S O))) (andb (arity_eq (arity (Power_e n')) (ok_arity (S O))) true) then ok_arity (S O) else error_Comp (ok_arity nh) (cons (ok_arity (S O)) (cons (arity (Power_e n')) nil)) end (ok_arity (S O))
+++++
rewrite arity_Mult.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].
trivial.
simpl.
rewrite arity_Mult.

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq (if andb (Nat.eqb (S (S O)) (S (S O))) (andb (arity_eq (arity (Power_e n')) (ok_arity (S O))) true) then ok_arity (S O) else error_Comp (ok_arity (S (S O))) (cons (ok_arity (S O)) (cons (arity (Power_e n')) nil))) (ok_arity (S O))
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].
trivial.
simpl.
rewrite arity_Mult.
rewrite <- beq_nat_refl.

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq (if andb true (andb (arity_eq (arity (Power_e n')) (ok_arity (S O))) true) then ok_arity (S O) else error_Comp (ok_arity (S (S O))) (cons (ok_arity (S O)) (cons (arity (Power_e n')) nil))) (ok_arity (S O))
+++++
rewrite IH.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].
trivial.
simpl.
rewrite arity_Mult.
rewrite <- beq_nat_refl.
rewrite IH.

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq (if andb true (andb (arity_eq (ok_arity (S O)) (ok_arity (S O))) true) then ok_arity (S O) else error_Comp (ok_arity (S (S O))) (cons (ok_arity (S O)) (cons (ok_arity (S O)) nil))) (ok_arity (S O))
+++++
simpl.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].
trivial.
simpl.
rewrite arity_Mult.
rewrite <- beq_nat_refl.
rewrite IH.
simpl.

*****
IH : eq (arity (Power_e n')) (ok_arity (S O))
n' : nat
*****
eq (ok_arity (S O)) (ok_arity (S O))
+++++
trivial.
-----
Lemma arity_Power n : arity (Power_e n) = ok_arity 1.
Proof.
induction n as [ | n' IH].

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).

*****
n : nat
*****
rec_bounded (Power_e n)
+++++
Proof.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.

*****
n : nat
*****
rec_bounded (Power_e n)
+++++
induction n as [ | n' IH].
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.
induction n as [ | n' IH].

*****

*****
rec_bounded (Power_e O)
+++++
simpl.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.
induction n as [ | n' IH].
simpl.

*****

*****
and (and True (and True True)) True
+++++
intuition.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.
induction n as [ | n' IH].

*****
IH : rec_bounded (Power_e n')
n' : nat
*****
rec_bounded (Power_e (S n'))
+++++
simpl.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.
induction n as [ | n' IH].
simpl.

*****
IH : rec_bounded (Power_e n')
n' : nat
*****
and (rec_bounded Mult_e) (and True (and (rec_bounded (Power_e n')) True))
+++++
intuition.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.
induction n as [ | n' IH].
simpl.
intuition.

*****
IH : rec_bounded (Power_e n')
n' : nat
*****
rec_bounded Mult_e
+++++
apply rec_bounded_Mult.
-----
Lemma rec_bounded_Power n : rec_bounded (Power_e n).
Proof.
induction n as [ | n' IH].

*****

*****

+++++
Qed.
-----
Lemma Power_correct : forall n l,\n  length (Sem (Power_e n) l) = power (length (hd nil l)) n.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.

*****

*****
forall (n : nat) (l : list (list bool)), eq (length (Sem (Power_e n) l)) (power (length (hd nil l)) n)
+++++
Proof.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.

*****

*****
forall (n : nat) (l : list (list bool)), eq (length (Sem (Power_e n) l)) (power (length (hd nil l)) n)
+++++
induction n as [ | n' IH].
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].

*****

*****
forall l : list (list bool), eq (length (Sem (Power_e O) l)) (power (length (hd nil l)) O)
+++++
simpl.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.

*****

*****
forall _ : list (list bool), eq (S O) (S O)
+++++
intros.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.

*****
l : list (list bool)
*****
eq (S O) (S O)
+++++
trivial.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].

*****
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
forall l : list (list bool), eq (length (Sem (Power_e (S n')) l)) (power (length (hd nil l)) (S n'))
+++++
simpl.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.

*****
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
forall l : list (list bool), eq (length (Sem Mult_e (cons (nth O l nil) (cons (Sem (Power_e n') l) nil)))) (Init.Nat.mul (length (hd nil l)) (power (length (hd nil l)) n'))
+++++
intros.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
eq (length (Sem Mult_e (cons (nth O l nil) (cons (Sem (Power_e n') l) nil)))) (Init.Nat.mul (length (hd nil l)) (power (length (hd nil l)) n'))
+++++
trivial.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.
trivial.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
eq (length (Sem Mult_e (cons (nth O l nil) (cons (Sem (Power_e n') l) nil)))) (Init.Nat.mul (length (hd nil l)) (power (length (hd nil l)) n'))
+++++
rewrite Mult_correct.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.
trivial.
rewrite Mult_correct.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
eq (Init.Nat.mul (length (hd nil (cons (nth O l nil) (cons (Sem (Power_e n') l) nil)))) (length (hd nil (tl (cons (nth O l nil) (cons (Sem (Power_e n') l) nil)))))) (Init.Nat.mul (length (hd nil l)) (power (length (hd nil l)) n'))
+++++
simpl.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.
trivial.
rewrite Mult_correct.
simpl.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
eq (Init.Nat.mul (length (nth O l nil)) (length (Sem (Power_e n') l))) (Init.Nat.mul (length (hd nil l)) (power (length (hd nil l)) n'))
+++++
rewrite IH.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.
trivial.
rewrite Mult_correct.
simpl.
rewrite IH.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
eq (Init.Nat.mul (length (nth O l nil)) (power (length (hd nil l)) n')) (Init.Nat.mul (length (hd nil l)) (power (length (hd nil l)) n'))
+++++
rewrite hd_nth_0.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].
simpl.
intros.
trivial.
rewrite Mult_correct.
simpl.
rewrite IH.
rewrite hd_nth_0.

*****
l : list (list bool)
IH : forall l : list (list bool),\neq (length (Sem (Power_e n') l)) (power (length (hd nil l)) n')
n' : nat
*****
eq (Init.Nat.mul (length (nth O l nil)) (power (length (nth O l nil)) n')) (Init.Nat.mul (length (nth O l nil)) (power (length (nth O l nil)) n'))
+++++
trivial.
-----
Lemma Power_correct : forall n l, length (Sem (Power_e n) l) = power (length (hd nil l)) n.
Proof.
induction n as [ | n' IH].

*****

*****

+++++
Qed.
-----
Definition Poly_pow (ar:nat) (xn:pow) : Cobham :=\n  Comp ar (Power_e (snd xn)) [Proj ar (fst xn)].
-----
Lemma arity_Poly_pow : forall ar xn,\n  pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.

*****

*****
forall (ar : nat) (xn : pow) (_ : pWF_pow ar xn), eq (arity (Poly_pow ar xn)) (ok_arity ar)
+++++
Proof.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.

*****

*****
forall (ar : nat) (xn : pow) (_ : pWF_pow ar xn), eq (arity (Poly_pow ar xn)) (ok_arity ar)
+++++
unfold pWF_pow.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.

*****

*****
forall (ar : nat) (xn : pow) (_ : lt (fst xn) ar), eq (arity (Poly_pow ar xn)) (ok_arity ar)
+++++
intros ar [x n] H.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.

*****
H : lt (fst (pair x n)) ar
ar,x,n : nat
*****
eq (arity (Poly_pow ar (pair x n))) (ok_arity ar)
+++++
simpl in *.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.

*****
H : lt x ar
ar,x,n : nat
*****
eq match arity (Power_e n) with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil) | error_Comp a l => error_Comp (error_Comp a l) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil) | error_Proj n n0 => error_Comp (error_Proj n n0) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil) | ok_arity nh => if andb (Nat.eqb nh (S O)) (andb (arity_eq (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) (ok_arity ar)) true) then ok_arity ar else error_Comp (ok_arity nh) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil) end (ok_arity ar)
+++++
rewrite arity_Power.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.

*****
H : lt x ar
ar,x,n : nat
*****
eq (if andb (Nat.eqb (S O) (S O)) (andb (arity_eq (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) (ok_arity ar)) true) then ok_arity ar else error_Comp (ok_arity (S O)) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil)) (ok_arity ar)
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.

*****
H : lt x ar
ar,x,n : nat
*****
eq (if andb true (andb (arity_eq (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) (ok_arity ar)) true) then ok_arity ar else error_Comp (ok_arity (S O)) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil)) (ok_arity ar)
+++++
simpl.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.

*****
H : lt x ar
ar,x,n : nat
*****
eq (if andb (arity_eq (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) (ok_arity ar)) true then ok_arity ar else error_Comp (ok_arity (S O)) (cons (if match ar with | O => false | S m' => Nat.leb x m' end then ok_arity ar else error_Proj ar x) nil)) (ok_arity ar)
+++++
destruct ar.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.

*****
H : lt x O
x,n : nat
*****
eq (if andb (arity_eq (error_Proj O x) (ok_arity O)) true then ok_arity O else error_Comp (ok_arity (S O)) (cons (error_Proj O x) nil)) (ok_arity O)
+++++
simpl in *.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.

*****
H : lt x O
x,n : nat
*****
eq (error_Comp (ok_arity (S O)) (cons (error_Proj O x) nil)) (ok_arity O)
+++++
contradict H.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
contradict H.

*****
x,n : nat
*****
not (lt x O)
+++++
omega.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.

*****
H : lt x (S ar)
ar,x,n : nat
*****
eq (if andb (arity_eq (if Nat.leb x ar then ok_arity (S ar) else error_Proj (S ar) x) (ok_arity (S ar))) true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (if Nat.leb x ar then ok_arity (S ar) else error_Proj (S ar) x) nil)) (ok_arity (S ar))
+++++
simpl in *.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.

*****
H : lt x (S ar)
ar,x,n : nat
*****
eq (if andb (arity_eq (if Nat.leb x ar then ok_arity (S ar) else error_Proj (S ar) x) (ok_arity (S ar))) true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (if Nat.leb x ar then ok_arity (S ar) else error_Proj (S ar) x) nil)) (ok_arity (S ar))
+++++
case_eq (leb x ar).
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).

*****
H : lt x (S ar)
ar,x,n : nat
*****
forall _ : eq (Nat.leb x ar) true, eq (if andb (arity_eq (ok_arity (S ar)) (ok_arity (S ar))) true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (ok_arity (S ar)) nil)) (ok_arity (S ar))
+++++
simpl.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.

*****
H : lt x (S ar)
ar,x,n : nat
*****
forall _ : eq (Nat.leb x ar) true, eq (if andb (Nat.eqb ar ar) true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (ok_arity (S ar)) nil)) (ok_arity (S ar))
+++++
intro H0.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.
intro H0.

*****
H0 : eq (Nat.leb x ar) true
H : lt x (S ar)
ar,x,n : nat
*****
eq (if andb (Nat.eqb ar ar) true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (ok_arity (S ar)) nil)) (ok_arity (S ar))
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.
intro H0.
rewrite <- beq_nat_refl.

*****
H0 : eq (Nat.leb x ar) true
H : lt x (S ar)
ar,x,n : nat
*****
eq (if andb true true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (ok_arity (S ar)) nil)) (ok_arity (S ar))
+++++
simpl.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.
intro H0.
rewrite <- beq_nat_refl.
simpl.

*****
H0 : eq (Nat.leb x ar) true
H : lt x (S ar)
ar,x,n : nat
*****
eq (ok_arity (S ar)) (ok_arity (S ar))
+++++
trivial.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).

*****
H : lt x (S ar)
ar,x,n : nat
*****
forall _ : eq (Nat.leb x ar) false, eq (if andb (arity_eq (error_Proj (S ar) x) (ok_arity (S ar))) true then ok_arity (S ar) else error_Comp (ok_arity (S O)) (cons (error_Proj (S ar) x) nil)) (ok_arity (S ar))
+++++
simpl.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.

*****
H : lt x (S ar)
ar,x,n : nat
*****
forall _ : eq (Nat.leb x ar) false, eq (error_Comp (ok_arity (S O)) (cons (error_Proj (S ar) x) nil)) (ok_arity (S ar))
+++++
intro H0.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.
intro H0.

*****
H0 : eq (Nat.leb x ar) false
H : lt x (S ar)
ar,x,n : nat
*****
eq (error_Comp (ok_arity (S O)) (cons (error_Proj (S ar) x) nil)) (ok_arity (S ar))
+++++
apply leb_complete_conv in H0.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.
intro H0.
apply leb_complete_conv in H0.

*****
H0 : lt ar x
H : lt x (S ar)
ar,x,n : nat
*****
eq (error_Comp (ok_arity (S O)) (cons (error_Proj (S ar) x) nil)) (ok_arity (S ar))
+++++
contradict H0.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.
simpl in *.
case_eq (leb x ar).
simpl.
intro H0.
apply leb_complete_conv in H0.
contradict H0.

*****
H : lt x (S ar)
ar,x,n : nat
*****
not (lt ar x)
+++++
omega.
-----
Lemma arity_Poly_pow : forall ar xn, pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.
Proof.
unfold pWF_pow.
intros ar [x n] H.
simpl in *.
rewrite arity_Power.
rewrite <- beq_nat_refl.
simpl.
destruct ar.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Poly_pow : forall ar xn,\n  rec_bounded (Poly_pow ar xn).
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).

*****

*****
forall (ar : nat) (xn : pow), rec_bounded (Poly_pow ar xn)
+++++
Proof.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.

*****

*****
forall (ar : nat) (xn : pow), rec_bounded (Poly_pow ar xn)
+++++
simpl.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.
simpl.

*****

*****
forall (_ : nat) (xn : pow), and (rec_bounded (Power_e (snd xn))) (and True True)
+++++
intros _ xn.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.
simpl.
intros _ xn.

*****
xn : pow
*****
and (rec_bounded (Power_e (snd xn))) (and True True)
+++++
split.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.
simpl.
intros _ xn.
split.

*****
xn : pow
*****
rec_bounded (Power_e (snd xn))
+++++
auto.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.
simpl.
intros _ xn.
split.
auto.

*****
xn : pow
*****
rec_bounded (Power_e (snd xn))
+++++
apply rec_bounded_Power.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.
simpl.
intros _ xn.
split.

*****
xn : pow
*****
and True True
+++++
auto.
-----
Lemma rec_bounded_Poly_pow : forall ar xn, rec_bounded (Poly_pow ar xn).
Proof.
simpl.
intros _ xn.
split.

*****

*****

+++++
Qed.
-----
Lemma Poly_pow_correct : forall ar xn l,\n  length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).

*****

*****
forall (ar : nat) (xn : pow) (l : list (list bool)), eq (length (Sem (Poly_pow ar xn) l)) (peval_pow xn (map (length (A:=bool)) l))
+++++
Proof.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.

*****

*****
forall (ar : nat) (xn : pow) (l : list (list bool)), eq (length (Sem (Poly_pow ar xn) l)) (peval_pow xn (map (length (A:=bool)) l))
+++++
intros ar [x n] l.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.

*****
l : list (list bool)
ar,x,n : nat
*****
eq (length (Sem (Poly_pow ar (pair x n)) l)) (peval_pow (pair x n) (map (length (A:=bool)) l))
+++++
simpl.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.
simpl.

*****
l : list (list bool)
ar,x,n : nat
*****
eq (length (Sem (Power_e n) (cons (nth x l nil) nil))) (peval_pow (pair x n) (map (length (A:=bool)) l))
+++++
rewrite Power_correct.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.
simpl.
rewrite Power_correct.

*****
l : list (list bool)
ar,x,n : nat
*****
eq (power (length (hd nil (cons (nth x l nil) nil))) n) (peval_pow (pair x n) (map (length (A:=bool)) l))
+++++
unfold peval_pow.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.
simpl.
rewrite Power_correct.
unfold peval_pow.

*****
l : list (list bool)
ar,x,n : nat
*****
eq (power (length (hd nil (cons (nth x l nil) nil))) n) (power (nth (fst (pair x n)) (map (length (A:=bool)) l) O) (snd (pair x n)))
+++++
simpl.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.
simpl.
rewrite Power_correct.
unfold peval_pow.
simpl.

*****
l : list (list bool)
ar,x,n : nat
*****
eq (power (length (nth x l nil)) n) (power (nth x (map (length (A:=bool)) l) O) n)
+++++
rewrite (@map_nth _ _ (@length _) l nil).
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.
simpl.
rewrite Power_correct.
unfold peval_pow.
simpl.
rewrite (@map_nth _ _ (@length _) l nil).

*****
l : list (list bool)
ar,x,n : nat
*****
eq (power (length (nth x l nil)) n) (power (length (nth x l nil)) n)
+++++
trivial.
-----
Lemma Poly_pow_correct : forall ar xn l, length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).
Proof.
intros ar [x n] l.
simpl.
rewrite Power_correct.
unfold peval_pow.
simpl.
rewrite (@map_nth _ _ (@length _) l nil).
trivial.

*****

*****

+++++
Qed.
-----
Opaque Poly_pow.
-----
Definition Poly_mon (ar:nat)(m:mon) : Cobham :=\n  Comp ar Mult_e [Comp ar (Nat_e (fst m)) nil; Multl_e ar (map (Poly_pow ar) (snd m))].
-----
Lemma arity_Poly_mon : forall ar m,\n  pWF_mon ar m ->\n  arity (Poly_mon ar m) = ok_arity ar.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.

*****

*****
forall (ar : nat) (m : mon) (_ : pWF_mon ar m), eq (arity (Poly_mon ar m)) (ok_arity ar)
+++++
Proof.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.

*****

*****
forall (ar : nat) (m : mon) (_ : pWF_mon ar m), eq (arity (Poly_mon ar m)) (ok_arity ar)
+++++
unfold pWF_mon.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.

*****

*****
forall (ar : nat) (m : mon) (_ : andl (pWF_pow ar) (snd m)), eq (arity (Poly_mon ar m)) (ok_arity ar)
+++++
intros ar [a xl] H.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (arity (Poly_mon ar (pair a xl))) (ok_arity ar)
+++++
simpl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq match arity Mult_e with | error_Rec a0 a1 a2 a3 => error_Comp (error_Rec a0 a1 a2 a3) (cons match arity (Nat_e a) with | error_Rec a a4 a5 a6 => error_Comp (error_Rec a a4 a5 a6) nil | error_Comp a l => error_Comp (error_Comp a l) nil | error_Proj n n0 => error_Comp (error_Proj n n0) nil | ok_arity nh => if andb (Nat.eqb nh O) true then ok_arity ar else error_Comp (ok_arity nh) nil end (cons (arity (Multl_e ar (map (Poly_pow ar) xl))) nil)) | error_Comp a0 l => error_Comp (error_Comp a0 l) (cons match arity (Nat_e a) with | error_Rec a a1 a2 a3 => error_Comp (error_Rec a a1 a2 a3) nil | error_Comp a l0 => error_Comp (error_Comp a l0) nil | error_Proj n n0 => error_Comp (error_Proj n n0) nil | ok_arity nh => if andb (Nat.eqb nh O) true then ok_arity ar else error_Comp (ok_arity nh) nil end (cons (arity (Multl_e ar (map (Poly_pow ar) xl))) nil)) | error_Proj n n0 => error_Comp (error_Proj n n0) (cons match arity (Nat_e a) with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) nil | error_Comp a l => error_Comp (error_Comp a l) nil | error_Proj n1 n2 => error_Comp (error_Proj n1 n2) nil | ok_arity nh => if andb (Nat.eqb nh O) true then ok_arity ar else error_Comp (ok_arity nh) nil end (cons (arity (Multl_e ar (map (Poly_pow ar) xl))) nil)) | ok_arity nh => if andb (Nat.eqb nh (S (S O))) (andb (arity_eq match arity (Nat_e a) with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) nil | error_Comp a l => error_Comp (error_Comp a l) nil | error_Proj n n0 => error_Comp (error_Proj n n0) nil | ok_arity nh0 => if andb (Nat.eqb nh0 O) true then ok_arity ar else error_Comp (ok_arity nh0) nil end (ok_arity ar)) (andb (arity_eq (arity (Multl_e ar (map (Poly_pow ar) xl))) (ok_arity ar)) true)) then ok_arity ar else error_Comp (ok_arity nh) (cons match arity (Nat_e a) with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) nil | error_Comp a l => error_Comp (error_Comp a l) nil | error_Proj n n0 => error_Comp (error_Proj n n0) nil | ok_arity nh0 => if andb (Nat.eqb nh0 O) true then ok_arity ar else error_Comp (ok_arity nh0) nil end (cons (arity (Multl_e ar (map (Poly_pow ar) xl))) nil)) end (ok_arity ar)
+++++
rewrite arity_Mult.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (if andb (Nat.eqb (S (S O)) (S (S O))) (andb (arity_eq match arity (Nat_e a) with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) nil | error_Comp a l => error_Comp (error_Comp a l) nil | error_Proj n n0 => error_Comp (error_Proj n n0) nil | ok_arity nh => if andb (Nat.eqb nh O) true then ok_arity ar else error_Comp (ok_arity nh) nil end (ok_arity ar)) (andb (arity_eq (arity (Multl_e ar (map (Poly_pow ar) xl))) (ok_arity ar)) true)) then ok_arity ar else error_Comp (ok_arity (S (S O))) (cons match arity (Nat_e a) with | error_Rec a a0 a1 a2 => error_Comp (error_Rec a a0 a1 a2) nil | error_Comp a l => error_Comp (error_Comp a l) nil | error_Proj n n0 => error_Comp (error_Proj n n0) nil | ok_arity nh => if andb (Nat.eqb nh O) true then ok_arity ar else error_Comp (ok_arity nh) nil end (cons (arity (Multl_e ar (map (Poly_pow ar) xl))) nil))) (ok_arity ar)
+++++
rewrite arity_Nat.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (if andb (Nat.eqb (S (S O)) (S (S O))) (andb (arity_eq (if andb (Nat.eqb O O) true then ok_arity ar else error_Comp (ok_arity O) nil) (ok_arity ar)) (andb (arity_eq (arity (Multl_e ar (map (Poly_pow ar) xl))) (ok_arity ar)) true)) then ok_arity ar else error_Comp (ok_arity (S (S O))) (cons (if andb (Nat.eqb O O) true then ok_arity ar else error_Comp (ok_arity O) nil) (cons (arity (Multl_e ar (map (Poly_pow ar) xl))) nil))) (ok_arity ar)
+++++
rewrite arity_Multl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (if andb (Nat.eqb (S (S O)) (S (S O))) (andb (arity_eq (if andb (Nat.eqb O O) true then ok_arity ar else error_Comp (ok_arity O) nil) (ok_arity ar)) (andb (arity_eq (ok_arity ar) (ok_arity ar)) true)) then ok_arity ar else error_Comp (ok_arity (S (S O))) (cons (if andb (Nat.eqb O O) true then ok_arity ar else error_Comp (ok_arity O) nil) (cons (ok_arity ar) nil))) (ok_arity ar)
+++++
simpl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (if andb (Nat.eqb ar ar) (andb (Nat.eqb ar ar) true) then ok_arity ar else error_Comp (ok_arity (S (S O))) (cons (ok_arity ar) (cons (ok_arity ar) nil))) (ok_arity ar)
+++++
rewrite <- beq_nat_refl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
rewrite <- beq_nat_refl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (if andb true (andb true true) then ok_arity ar else error_Comp (ok_arity (S (S O))) (cons (ok_arity ar) (cons (ok_arity ar) nil))) (ok_arity ar)
+++++
simpl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
rewrite <- beq_nat_refl.
simpl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
eq (ok_arity ar) (ok_arity ar)
+++++
trivial.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) xl)
+++++
simpl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.

*****
H : andl (pWF_pow ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) xl)
+++++
induction xl.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.

*****
H : andl (pWF_pow ar) (snd (pair a nil))
ar,a : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) nil)
+++++
simpl in *.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.

*****
H : True
ar,a : nat
*****
True
+++++
trivial.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.

*****
IHxl : forall _ : andl (pWF_pow ar) (snd (pair a xl)),\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : andl (pWF_pow ar) (snd (pair a (cons a0 xl)))
xl : list pow
a0 : pow
ar,a : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) (cons a0 xl))
+++++
simpl in *.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.

*****
IHxl : forall _ : andl (pWF_pow ar) xl,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : and (pWF_pow ar a0) (andl (pWF_pow ar) xl)
xl : list pow
a0 : pow
ar,a : nat
*****
and (eq (arity (Poly_pow ar a0)) (ok_arity ar)) (andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) xl))
+++++
trivial.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.
trivial.

*****
IHxl : forall _ : andl (pWF_pow ar) xl,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : and (pWF_pow ar a0) (andl (pWF_pow ar) xl)
xl : list pow
a0 : pow
ar,a : nat
*****
and (eq (arity (Poly_pow ar a0)) (ok_arity ar)) (andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) xl))
+++++
split.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.
trivial.
split.

*****
IHxl : forall _ : andl (pWF_pow ar) xl,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : and (pWF_pow ar a0) (andl (pWF_pow ar) xl)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (arity (Poly_pow ar a0)) (ok_arity ar)
+++++
try tauto.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.
trivial.
split.
try tauto.

*****
IHxl : forall _ : andl (pWF_pow ar) xl,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : and (pWF_pow ar a0) (andl (pWF_pow ar) xl)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (arity (Poly_pow ar a0)) (ok_arity ar)
+++++
apply arity_Poly_pow.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.
trivial.
split.
try tauto.
apply arity_Poly_pow.

*****
IHxl : forall _ : andl (pWF_pow ar) xl,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : and (pWF_pow ar a0) (andl (pWF_pow ar) xl)
xl : list pow
a0 : pow
ar,a : nat
*****
pWF_pow ar a0
+++++
tauto.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.
simpl.
induction xl.
simpl in *.
trivial.
split.

*****
IHxl : forall _ : andl (pWF_pow ar) xl,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_pow ar) xl)
H : and (pWF_pow ar a0) (andl (pWF_pow ar) xl)
xl : list pow
a0 : pow
ar,a : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_pow ar) xl)
+++++
try tauto.
-----
Lemma arity_Poly_mon : forall ar m, pWF_mon ar m -> arity (Poly_mon ar m) = ok_arity ar.
Proof.
unfold pWF_mon.
intros ar [a xl] H.
simpl.
rewrite arity_Mult.
rewrite arity_Nat.
rewrite arity_Multl.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Poly_mon : forall ar m,\n  rec_bounded (Poly_mon ar m).
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).

*****

*****
forall (ar : nat) (m : mon), rec_bounded (Poly_mon ar m)
+++++
Proof.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.

*****

*****
forall (ar : nat) (m : mon), rec_bounded (Poly_mon ar m)
+++++
intros ar [a xl].
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].

*****
xl : list pow
ar,a : nat
*****
rec_bounded (Poly_mon ar (pair a xl))
+++++
simpl.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.

*****
xl : list pow
ar,a : nat
*****
and (rec_bounded Mult_e) (and (and (rec_bounded (Nat_e a)) True) (and (rec_bounded (Multl_e ar (map (Poly_pow ar) xl))) True))
+++++
split.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.

*****
xl : list pow
ar,a : nat
*****
rec_bounded Mult_e
+++++
apply rec_bounded_Mult.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.

*****
xl : list pow
ar,a : nat
*****
and (and (rec_bounded (Nat_e a)) True) (and (rec_bounded (Multl_e ar (map (Poly_pow ar) xl))) True)
+++++
split.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.

*****
xl : list pow
ar,a : nat
*****
and (rec_bounded (Nat_e a)) True
+++++
split.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.

*****
xl : list pow
ar,a : nat
*****
rec_bounded (Nat_e a)
+++++
trivial.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.

*****
xl : list pow
ar,a : nat
*****
rec_bounded (Nat_e a)
+++++
apply rec_bounded_Nat.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.

*****
xl : list pow
ar,a : nat
*****
True
+++++
trivial.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.

*****
xl : list pow
ar,a : nat
*****
and (rec_bounded (Multl_e ar (map (Poly_pow ar) xl))) True
+++++
split.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.

*****
xl : list pow
ar,a : nat
*****
rec_bounded (Multl_e ar (map (Poly_pow ar) xl))
+++++
trivial.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.

*****
xl : list pow
ar,a : nat
*****
rec_bounded (Multl_e ar (map (Poly_pow ar) xl))
+++++
apply rec_bounded_Multl.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.
apply rec_bounded_Multl.

*****
xl : list pow
ar,a : nat
*****
andl rec_bounded (map (Poly_pow ar) xl)
+++++
rewrite <- forall_andl.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.
apply rec_bounded_Multl.
rewrite <- forall_andl.

*****
xl : list pow
ar,a : nat
*****
forall (x : Cobham) (_ : In x (map (Poly_pow ar) xl)), rec_bounded x
+++++
intros.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.
apply rec_bounded_Multl.
rewrite <- forall_andl.
intros.

*****
H : In x (map (Poly_pow ar) xl)
x : Cobham
xl : list pow
ar,a : nat
*****
rec_bounded x
+++++
rewrite in_map_iff in H.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.
apply rec_bounded_Multl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.

*****
H : ex (fun x0 : pow => and (eq (Poly_pow ar x0) x) (In x0 xl))
x : Cobham
xl : list pow
ar,a : nat
*****
rec_bounded x
+++++
destruct H as [xn [H _] ].
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.
apply rec_bounded_Multl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.
destruct H as [xn [H _] ].

*****
H : eq (Poly_pow ar xn) x
xn : pow
x : Cobham
xl : list pow
ar,a : nat
*****
rec_bounded x
+++++
subst.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.
trivial.
apply rec_bounded_Multl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.
destruct H as [xn [H _] ].
subst.

*****
xn : pow
xl : list pow
ar,a : nat
*****
rec_bounded (Poly_pow ar xn)
+++++
apply rec_bounded_Poly_pow.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.
split.
split.

*****
xl : list pow
ar,a : nat
*****
True
+++++
trivial.
-----
Lemma rec_bounded_Poly_mon : forall ar m, rec_bounded (Poly_mon ar m).
Proof.
intros ar [a xl].
simpl.
split.

*****

*****

+++++
Qed.
-----
Lemma Poly_mon_correct : forall ar m l,\n  length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).

*****

*****
forall (ar : nat) (m : mon) (l : list (list bool)), eq (length (Sem (Poly_mon ar m) l)) (peval_mon m (map (length (A:=bool)) l))
+++++
Proof.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.

*****

*****
forall (ar : nat) (m : mon) (l : list (list bool)), eq (length (Sem (Poly_mon ar m) l)) (peval_mon m (map (length (A:=bool)) l))
+++++
intros ar [a xl] l.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (length (Sem (Poly_mon ar (pair a xl)) l)) (peval_mon (pair a xl) (map (length (A:=bool)) l))
+++++
simpl.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (length (Sem Mult_e (cons (Sem (Nat_e a) nil) (cons (Sem (Multl_e ar (map (Poly_pow ar) xl)) l) nil)))) (peval_mon (pair a xl) (map (length (A:=bool)) l))
+++++
rewrite Mult_correct.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul (length (hd nil (cons (Sem (Nat_e a) nil) (cons (Sem (Multl_e ar (map (Poly_pow ar) xl)) l) nil)))) (length (hd nil (tl (cons (Sem (Nat_e a) nil) (cons (Sem (Multl_e ar (map (Poly_pow ar) xl)) l) nil)))))) (peval_mon (pair a xl) (map (length (A:=bool)) l))
+++++
simpl.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul (length (Sem (Nat_e a) nil)) (length (Sem (Multl_e ar (map (Poly_pow ar) xl)) l))) (peval_mon (pair a xl) (map (length (A:=bool)) l))
+++++
rewrite Nat_correct.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul a (length (Sem (Multl_e ar (map (Poly_pow ar) xl)) l))) (peval_mon (pair a xl) (map (length (A:=bool)) l))
+++++
rewrite Multl_correct.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun e : Cobham => length (Sem e l)) (map (Poly_pow ar) xl)))) (peval_mon (pair a xl) (map (length (A:=bool)) l))
+++++
unfold peval_mon.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun e : Cobham => length (Sem e l)) (map (Poly_pow ar) xl)))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd (pair a xl)))))
+++++
simpl.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun e : Cobham => length (Sem e l)) (map (Poly_pow ar) xl)))) (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl)))
+++++
rewrite map_map.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.

*****
l : list (list bool)
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl))) (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl)))
+++++
induction xl.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.

*****
l : list (list bool)
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) nil))) (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) nil)))
+++++
simpl.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.
simpl.

*****
l : list (list bool)
ar,a : nat
*****
eq (Init.Nat.mul a (S O)) (Init.Nat.mul a (S O))
+++++
trivial.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))\n (Init.Nat.mul a\n (multl\n (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl)))
l : list (list bool)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) (cons a0 xl)))) (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (cons a0 xl))))
+++++
simpl.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.
simpl.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))\n (Init.Nat.mul a\n (multl\n (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl)))
l : list (list bool)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (length (Sem (Poly_pow ar a0) l)) (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (map (length (A:=bool)) l)) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl))))
+++++
trivial.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.
simpl.
trivial.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))\n (Init.Nat.mul a\n (multl\n (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl)))
l : list (list bool)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (length (Sem (Poly_pow ar a0) l)) (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (map (length (A:=bool)) l)) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl))))
+++++
rewrite Poly_pow_correct.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.
simpl.
trivial.
rewrite Poly_pow_correct.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))\n (Init.Nat.mul a\n (multl\n (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl)))
l : list (list bool)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (map (length (A:=bool)) l)) (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (map (length (A:=bool)) l)) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) xl))))
+++++
unfold peval_pow in *.
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.
simpl.
trivial.
rewrite Poly_pow_correct.
unfold peval_pow in *.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))\n (Init.Nat.mul a\n (multl\n (map\n (fun x : pow =>\n power (nth (fst x) (map (length (A:=bool)) l) O) (snd x))\n xl)))
l : list (list bool)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (power (nth (fst a0) (map (length (A:=bool)) l) O) (snd a0)) (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))) (Init.Nat.mul a (Init.Nat.mul (power (nth (fst a0) (map (length (A:=bool)) l) O) (snd a0)) (multl (map (fun x : pow => power (nth (fst x) (map (length (A:=bool)) l) O) (snd x)) xl))))
+++++
rewrite (@map_nth _ _ (@length _) l nil).
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.
simpl.
trivial.
rewrite Poly_pow_correct.
unfold peval_pow in *.
rewrite (@map_nth _ _ (@length _) l nil).

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))\n (Init.Nat.mul a\n (multl\n (map\n (fun x : pow =>\n power (nth (fst x) (map (length (A:=bool)) l) O) (snd x))\n xl)))
l : list (list bool)
xl : list pow
a0 : pow
ar,a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (power (length (nth (fst a0) l nil)) (snd a0)) (multl (map (fun x : pow => length (Sem (Poly_pow ar x) l)) xl)))) (Init.Nat.mul a (Init.Nat.mul (power (length (nth (fst a0) l nil)) (snd a0)) (multl (map (fun x : pow => power (nth (fst x) (map (length (A:=bool)) l) O) (snd x)) xl))))
+++++
ring [IHxl].
-----
Lemma Poly_mon_correct : forall ar m l, length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).
Proof.
intros ar [a xl] l.
simpl.
rewrite Mult_correct.
simpl.
rewrite Nat_correct.
rewrite Multl_correct.
unfold peval_mon.
simpl.
rewrite map_map.
induction xl.

*****

*****

+++++
Qed.
-----
Opaque Poly_mon.
-----
Definition Poly (p : pol) : Cobham :=\n  Plusl_e (fst p) (map (Poly_mon (fst p)) (snd p)).
-----
Lemma arity_Poly : forall p,\n  pWF p ->\n  arity (Poly p) = ok_arity (parity p).
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).

*****

*****
forall (p : pol) (_ : pWF p), eq (arity (Poly p)) (ok_arity (fst p))
+++++
Proof.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.

*****

*****
forall (p : pol) (_ : pWF p), eq (arity (Poly p)) (ok_arity (fst p))
+++++
unfold pWF.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.

*****

*****
forall (p : pol) (_ : pWF' (fst p) (snd p)), eq (arity (Poly p)) (ok_arity (fst p))
+++++
unfold pWF'.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.

*****

*****
forall (p : pol) (_ : andl (pWF_mon (fst p)) (snd p)), eq (arity (Poly p)) (ok_arity (fst p))
+++++
unfold pWF_mon.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.

*****

*****
forall (p : pol) (_ : andl (fun m : mon => andl (pWF_pow (fst p)) (snd m)) (snd p)), eq (arity (Poly p)) (ok_arity (fst p))
+++++
unfold pWF_pow.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (p : pol) (_ : andl (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m)) (snd p)), eq (arity (Poly p)) (ok_arity (fst p))
+++++
intros [ar ml] H.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.

*****
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar ml))) (snd m))\n (snd (pair ar ml))
ml : list mon
ar : nat
*****
eq (arity (Poly (pair ar ml))) (ok_arity (fst (pair ar ml)))
+++++
unfold Poly.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.

*****
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar ml))) (snd m))\n (snd (pair ar ml))
ml : list mon
ar : nat
*****
eq (arity (Plusl_e (fst (pair ar ml)) (map (Poly_mon (fst (pair ar ml))) (snd (pair ar ml))))) (ok_arity (fst (pair ar ml)))
+++++
rewrite arity_Plusl.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.

*****
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar ml))) (snd m))\n (snd (pair ar ml))
ml : list mon
ar : nat
*****
eq (ok_arity (fst (pair ar ml))) (ok_arity (fst (pair ar ml)))
+++++
trivial.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.

*****
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar ml))) (snd m))\n (snd (pair ar ml))
ml : list mon
ar : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity (fst (pair ar ml)))) (map (Poly_mon (fst (pair ar ml))) (snd (pair ar ml)))
+++++
trivial.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.

*****
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar ml))) (snd m))\n (snd (pair ar ml))
ml : list mon
ar : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity (fst (pair ar ml)))) (map (Poly_mon (fst (pair ar ml))) (snd (pair ar ml)))
+++++
induction ml.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.

*****
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar nil))) (snd m))\n (snd (pair ar nil))
ar : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity (fst (pair ar nil)))) (map (Poly_mon (fst (pair ar nil))) (snd (pair ar nil)))
+++++
simpl in *.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.

*****
H : True
ar : nat
*****
True
+++++
trivial.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.

*****
IHml : forall\n _ : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar ml))) (snd m))\n (snd (pair ar ml)),\nandl (fun e : Cobham => eq (arity e) (ok_arity (fst (pair ar ml))))\n (map (Poly_mon (fst (pair ar ml))) (snd (pair ar ml)))
H : andl\n (fun m : mon =>\n andl (fun xn : pow => lt (fst xn) (fst (pair ar (cons a ml))))\n (snd m)) (snd (pair ar (cons a ml)))
ml : list mon
a : mon
ar : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity (fst (pair ar (cons a ml))))) (map (Poly_mon (fst (pair ar (cons a ml)))) (snd (pair ar (cons a ml))))
+++++
simpl in *.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.

*****
IHml : forall\n _ : andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_mon ar) ml)
H : and (andl (fun xn : pow => lt (fst xn) ar) (snd a))\n (andl (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml)
ml : list mon
a : mon
ar : nat
*****
and (eq (arity (Poly_mon ar a)) (ok_arity ar)) (andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_mon ar) ml))
+++++
trivial.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.
trivial.

*****
IHml : forall\n _ : andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_mon ar) ml)
H : and (andl (fun xn : pow => lt (fst xn) ar) (snd a))\n (andl (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml)
ml : list mon
a : mon
ar : nat
*****
and (eq (arity (Poly_mon ar a)) (ok_arity ar)) (andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_mon ar) ml))
+++++
split.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.
trivial.
split.

*****
IHml : forall\n _ : andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_mon ar) ml)
H : and (andl (fun xn : pow => lt (fst xn) ar) (snd a))\n (andl (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml)
ml : list mon
a : mon
ar : nat
*****
eq (arity (Poly_mon ar a)) (ok_arity ar)
+++++
try tauto.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.
trivial.
split.
try tauto.

*****
IHml : forall\n _ : andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_mon ar) ml)
H : and (andl (fun xn : pow => lt (fst xn) ar) (snd a))\n (andl (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml)
ml : list mon
a : mon
ar : nat
*****
eq (arity (Poly_mon ar a)) (ok_arity ar)
+++++
apply arity_Poly_mon.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.
trivial.
split.
try tauto.
apply arity_Poly_mon.

*****
IHml : forall\n _ : andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_mon ar) ml)
H : and (andl (fun xn : pow => lt (fst xn) ar) (snd a))\n (andl (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml)
ml : list mon
a : mon
ar : nat
*****
pWF_mon ar a
+++++
tauto.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.
trivial.
induction ml.
simpl in *.
trivial.
split.

*****
IHml : forall\n _ : andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml,\nandl (fun e : Cobham => eq (arity e) (ok_arity ar))\n (map (Poly_mon ar) ml)
H : and (andl (fun xn : pow => lt (fst xn) ar) (snd a))\n (andl (fun m : mon => andl (fun xn : pow => lt (fst xn) ar) (snd m))\n ml)
ml : list mon
a : mon
ar : nat
*****
andl (fun e : Cobham => eq (arity e) (ok_arity ar)) (map (Poly_mon ar) ml)
+++++
try tauto.
-----
Lemma arity_Poly : forall p, pWF p -> arity (Poly p) = ok_arity (parity p).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] H.
unfold Poly.
rewrite arity_Plusl.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded_Poly : forall p,\n  rec_bounded (Poly p).
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).

*****

*****
forall p : pol, rec_bounded (Poly p)
+++++
Proof.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.

*****

*****
forall p : pol, rec_bounded (Poly p)
+++++
intros [ar ml].
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].

*****
ml : list mon
ar : nat
*****
rec_bounded (Poly (pair ar ml))
+++++
unfold Poly.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.

*****
ml : list mon
ar : nat
*****
rec_bounded (Plusl_e (fst (pair ar ml)) (map (Poly_mon (fst (pair ar ml))) (snd (pair ar ml))))
+++++
simpl.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.

*****
ml : list mon
ar : nat
*****
rec_bounded (Plusl_e ar (map (Poly_mon ar) ml))
+++++
apply rec_bounded_Plusl.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.

*****
ml : list mon
ar : nat
*****
andl rec_bounded (map (Poly_mon ar) ml)
+++++
rewrite <- forall_andl.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.
rewrite <- forall_andl.

*****
ml : list mon
ar : nat
*****
forall (x : Cobham) (_ : In x (map (Poly_mon ar) ml)), rec_bounded x
+++++
intros e He.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.
rewrite <- forall_andl.
intros e He.

*****
He : In e (map (Poly_mon ar) ml)
e : Cobham
ml : list mon
ar : nat
*****
rec_bounded e
+++++
rewrite in_map_iff in He.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.
rewrite <- forall_andl.
intros e He.
rewrite in_map_iff in He.

*****
He : ex (fun x : mon => and (eq (Poly_mon ar x) e) (In x ml))
e : Cobham
ml : list mon
ar : nat
*****
rec_bounded e
+++++
destruct He as [m [He _] ].
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.
rewrite <- forall_andl.
intros e He.
rewrite in_map_iff in He.
destruct He as [m [He _] ].

*****
He : eq (Poly_mon ar m) e
m : mon
e : Cobham
ml : list mon
ar : nat
*****
rec_bounded e
+++++
subst.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.
rewrite <- forall_andl.
intros e He.
rewrite in_map_iff in He.
destruct He as [m [He _] ].
subst.

*****
m : mon
ml : list mon
ar : nat
*****
rec_bounded (Poly_mon ar m)
+++++
apply rec_bounded_Poly_mon.
-----
Lemma rec_bounded_Poly : forall p, rec_bounded (Poly p).
Proof.
intros [ar ml].
unfold Poly.
simpl.
apply rec_bounded_Plusl.
rewrite <- forall_andl.
intros e He.
rewrite in_map_iff in He.
destruct He as [m [He _] ].
subst.
apply rec_bounded_Poly_mon.

*****

*****

+++++
Qed.
-----
Lemma Poly_correct : forall p l,\n  length (Sem (Poly p) l) = peval p (map (@length _) l).
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).

*****

*****
forall (p : pol) (l : list (list bool)), eq (length (Sem (Poly p) l)) (peval p (map (length (A:=bool)) l))
+++++
Proof.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.

*****

*****
forall (p : pol) (l : list (list bool)), eq (length (Sem (Poly p) l)) (peval p (map (length (A:=bool)) l))
+++++
unfold Poly.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.

*****

*****
forall (p : pol) (l : list (list bool)), eq (length (Sem (Plusl_e (fst p) (map (Poly_mon (fst p)) (snd p))) l)) (peval p (map (length (A:=bool)) l))
+++++
intros [ar ml] l.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.

*****
l : list (list bool)
ml : list mon
ar : nat
*****
eq (length (Sem (Plusl_e (fst (pair ar ml)) (map (Poly_mon (fst (pair ar ml))) (snd (pair ar ml)))) l)) (peval (pair ar ml) (map (length (A:=bool)) l))
+++++
simpl.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.

*****
l : list (list bool)
ml : list mon
ar : nat
*****
eq (length (Sem (Plusl_e ar (map (Poly_mon ar) ml)) l)) (peval (pair ar ml) (map (length (A:=bool)) l))
+++++
rewrite Plusl_correct.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.

*****
l : list (list bool)
ml : list mon
ar : nat
*****
eq (plusl (map (fun e : Cobham => length (Sem e l)) (map (Poly_mon ar) ml))) (peval (pair ar ml) (map (length (A:=bool)) l))
+++++
unfold peval.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.

*****
l : list (list bool)
ml : list mon
ar : nat
*****
eq (plusl (map (fun e : Cobham => length (Sem e l)) (map (Poly_mon ar) ml))) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) (snd (pair ar ml))))
+++++
simpl.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.

*****
l : list (list bool)
ml : list mon
ar : nat
*****
eq (plusl (map (fun e : Cobham => length (Sem e l)) (map (Poly_mon ar) ml))) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml))
+++++
rewrite map_map.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.

*****
l : list (list bool)
ml : list mon
ar : nat
*****
eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml)) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml))
+++++
induction ml.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.

*****
l : list (list bool)
ar : nat
*****
eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) nil)) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) nil))
+++++
simpl.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.
simpl.

*****
l : list (list bool)
ar : nat
*****
eq O O
+++++
trivial.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.

*****
IHml : eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))\n (plusl\n (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml))
l : list (list bool)
ml : list mon
a : mon
ar : nat
*****
eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) (cons a ml))) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) (cons a ml)))
+++++
simpl.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.
simpl.

*****
IHml : eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))\n (plusl\n (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml))
l : list (list bool)
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (length (Sem (Poly_mon ar a) l)) (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))) (Init.Nat.add (peval_mon a (map (length (A:=bool)) l)) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml)))
+++++
trivial.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.
simpl.
trivial.

*****
IHml : eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))\n (plusl\n (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml))
l : list (list bool)
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (length (Sem (Poly_mon ar a) l)) (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))) (Init.Nat.add (peval_mon a (map (length (A:=bool)) l)) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml)))
+++++
rewrite Poly_mon_correct.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.
simpl.
trivial.
rewrite Poly_mon_correct.

*****
IHml : eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))\n (plusl\n (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml))
l : list (list bool)
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon a (map (length (A:=bool)) l)) (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))) (Init.Nat.add (peval_mon a (map (length (A:=bool)) l)) (plusl (map (fun m : mon => peval_mon m (map (length (A:=bool)) l)) ml)))
+++++
unfold peval_mon in *.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.
simpl.
trivial.
rewrite Poly_mon_correct.
unfold peval_mon in *.

*****
IHml : eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => peval_pow x (map (length (A:=bool)) l))\n (snd m)))) ml))
l : list (list bool)
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst a) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd a)))) (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))) (Init.Nat.add (Init.Nat.mul (fst a) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd a)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd m)))) ml)))
+++++
rewrite IHml.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.
simpl.
trivial.
rewrite Poly_mon_correct.
unfold peval_mon in *.
rewrite IHml.

*****
IHml : eq (plusl (map (fun x : mon => length (Sem (Poly_mon ar x) l)) ml))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => peval_pow x (map (length (A:=bool)) l))\n (snd m)))) ml))
l : list (list bool)
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst a) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd a)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd m)))) ml))) (Init.Nat.add (Init.Nat.mul (fst a) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd a)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (map (length (A:=bool)) l)) (snd m)))) ml)))
+++++
trivial.
-----
Lemma Poly_correct : forall p l, length (Sem (Poly p) l) = peval p (map (@length _) l).
Proof.
unfold Poly.
intros [ar ml] l.
simpl.
rewrite Plusl_correct.
unfold peval.
simpl.
rewrite map_map.
induction ml.

*****

*****

+++++
Qed.
-----
Opaque Poly.
-----
