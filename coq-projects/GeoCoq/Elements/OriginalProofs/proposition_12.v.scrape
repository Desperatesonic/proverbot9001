Require Export GeoCoq.Elements.OriginalProofs.proposition_10.
-----
Section Euclid.
-----
Context `{Ax:euclidean_neutral_ruler_compass}.
-----
Lemma proposition_12 : \n   forall A B C, \n   nCol A B C ->\n   exists X, Perp_at C X A B X.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : nCol A B C), ex (fun X : Point => Perp_at C X A B X)
+++++
Proof.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : nCol A B C), ex (fun X : Point => Perp_at C X A B X)
+++++
intros.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.

*****
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (~ eq B C).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).

*****
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq B C)
+++++
intro.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
intro.

*****
H0 : eq B C
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col A B C) by (conclude_def Col ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
intro.
assert (Col A B C) by (conclude_def Col ).

*****
H1 : Col A B C
H0 : eq B C
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).

*****
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (neq C B) by (conclude lemma_inequalitysymmetric).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).

*****
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (~ eq A B).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).

*****
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq A B)
+++++
intro.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
intro.

*****
H2 : eq A B
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col A B C) by (conclude_def Col ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
intro.
assert (Col A B C) by (conclude_def Col ).

*****
H3 : Col A B C
H2 : eq A B
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).

*****
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.

*****
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (neq C E) by (forward_using lemma_betweennotequal).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).

*****
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (neq E C) by (conclude lemma_inequalitysymmetric).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).

*****
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.

*****
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong E C C E) by (conclude cn_equalityreverse).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).

*****
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C E C E) by (conclude cn_congruencereflexive).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).

*****
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).

*****
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).

*****
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (BetS E B F) by (conclude lemma_3_6b).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).

*****
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.

*****
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C E C E) by (conclude cn_congruencereflexive).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).

*****
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C B C B) by (conclude cn_congruencereflexive).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).

*****
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (InCirc B K) by (conclude_def InCirc ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).

*****
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\ BetS A B Q /\ OnCirc P K /\ OnCirc Q K /\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.

*****
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col A B Q) by (conclude_def Col ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).

*****
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).

*****
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).

*****
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).

*****
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).

*****
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).

*****
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (neq P Q) by (forward_using lemma_betweennotequal).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).

*****
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.

*****
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).

*****
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col P M Q) by (conclude_def Col ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).

*****
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col P B Q) by (conclude_def Col ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).

*****
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col P Q B) by (forward_using lemma_collinearorder).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).

*****
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col P Q M) by (forward_using lemma_collinearorder).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).

*****
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col Q B M) by (conclude lemma_collinear4).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).

*****
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col Q B A) by (forward_using lemma_collinearorder).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).

*****
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (neq B Q) by (forward_using lemma_betweennotequal).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).

*****
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).

*****
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col B M A) by (conclude lemma_collinear4).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).

*****
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col A B M) by (forward_using lemma_collinearorder).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).

*****
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (~ eq M C).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).

*****
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
not (eq M C)
+++++
intro.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
intro.

*****
H43 : eq M C
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
assert (Col A B C) by (conclude cn_equalitysub).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
intro.
assert (Col A B C) by (conclude cn_equalitysub).

*****
H44 : Col A B C
H43 : eq M C
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
False
+++++
contradict.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).

*****
H43 : not (eq M C)
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Per P M C) by (conclude_def Per ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
assert (Per P M C) by (conclude_def Per ).

*****
H44 : Per P M C
H43 : not (eq M C)
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (eq M M) by (conclude cn_equalityreflexive).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
assert (Per P M C) by (conclude_def Per ).
assert (eq M M) by (conclude cn_equalityreflexive).

*****
H45 : eq M M
H44 : Per P M C
H43 : not (eq M C)
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Col C M M) by (conclude_def Col ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
assert (Per P M C) by (conclude_def Per ).
assert (eq M M) by (conclude cn_equalityreflexive).
assert (Col C M M) by (conclude_def Col ).

*****
H46 : Col C M M
H45 : eq M M
H44 : Per P M C
H43 : not (eq M C)
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
assert (Perp_at C M A B M) by (conclude_def Perp_at ).
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
assert (Per P M C) by (conclude_def Per ).
assert (eq M M) by (conclude cn_equalityreflexive).
assert (Col C M M) by (conclude_def Col ).
assert (Perp_at C M A B M) by (conclude_def Perp_at ).

*****
H47 : Perp_at C M A B M
H46 : Col C M M
H45 : eq M M
H44 : Per P M C
H43 : not (eq M C)
H42 : Col A B M
H41 : Col B M A
H40 : neq Q B
H39 : neq B Q
H38 : Col Q B A
H37 : Col Q B M
H36 : Col P Q M
H35 : Col P Q B
H34 : Col P B Q
H33 : Col P M Q
H32 : Cong P M Q M
H31 : Cong M P M Q
H30 : BetS P M Q
M : Point
H29 : neq P Q
H28 : Cong P C Q C
H27 : Cong C P C Q
H26 : Cong C E C Q
H25 : Cong C Q C E
H24 : Cong C P C E
H23 : Col A B Q
H22 : BetS P B Q
H21 : OnCirc Q K
H20 : OnCirc P K
H19 : BetS A B Q
H18 : Col A B P
P,Q : Point
H17 : InCirc B K
H16 : Cong C B C B
H15 : Cong C E C E
H14 : CI K C C E
K : Circle
H13 : BetS E B F
H12 : BetS E B C
H11 : Cong C F C E
H10 : Cong C E C E
H9 : Cong E C C E
H8 : Cong C F E C
H7 : BetS E C F
F : Point
H6 : neq E C
H5 : neq C E
H4 : Cong B E C B
H3 : BetS C B E
E : Point
H2 : not (eq A B)
H1 : neq C B
H0 : not (eq B C)
H : nCol A B C
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Perp_at C X A B X)
+++++
close.
-----
Lemma proposition_12 : forall A B C, nCol A B C -> exists X, Perp_at C X A B X.
Proof.
intros.
assert (~ eq B C).
assert (neq C B) by (conclude lemma_inequalitysymmetric).
assert (~ eq A B).
let Tf:=fresh in assert (Tf:exists E, (BetS C B E /\\ Cong B E C B)) by (conclude lemma_extension);destruct Tf as [E];spliter.
assert (neq C E) by (forward_using lemma_betweennotequal).
assert (neq E C) by (conclude lemma_inequalitysymmetric).
let Tf:=fresh in assert (Tf:exists F, (BetS E C F /\\ Cong C F E C)) by (conclude lemma_extension);destruct Tf as [F];spliter.
assert (Cong E C C E) by (conclude cn_equalityreverse).
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C F C E) by (conclude lemma_congruencetransitive).
assert (BetS E B C) by (conclude axiom_betweennesssymmetry).
assert (BetS E B F) by (conclude lemma_3_6b).
let Tf:=fresh in assert (Tf:exists K, CI K C C E) by (conclude postulate_Euclid3);destruct Tf as [K];spliter.
assert (Cong C E C E) by (conclude cn_congruencereflexive).
assert (Cong C B C B) by (conclude cn_congruencereflexive).
assert (InCirc B K) by (conclude_def InCirc ).
let Tf:=fresh in assert (Tf:exists P Q, (Col A B P /\\ BetS A B Q /\\ OnCirc P K /\\ OnCirc Q K /\\ BetS P B Q)) by (conclude postulate_line_circle);destruct Tf as [P[Q]];spliter.
assert (Col A B Q) by (conclude_def Col ).
assert (Cong C P C E) by (conclude axiom_circle_center_radius).
assert (Cong C Q C E) by (conclude axiom_circle_center_radius).
assert (Cong C E C Q) by (conclude lemma_congruencesymmetric).
assert (Cong C P C Q) by (conclude lemma_congruencetransitive).
assert (Cong P C Q C) by (forward_using lemma_congruenceflip).
assert (neq P Q) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists M, (BetS P M Q /\\ Cong M P M Q)) by (conclude proposition_10);destruct Tf as [M];spliter.
assert (Cong P M Q M) by (forward_using lemma_congruenceflip).
assert (Col P M Q) by (conclude_def Col ).
assert (Col P B Q) by (conclude_def Col ).
assert (Col P Q B) by (forward_using lemma_collinearorder).
assert (Col P Q M) by (forward_using lemma_collinearorder).
assert (Col Q B M) by (conclude lemma_collinear4).
assert (Col Q B A) by (forward_using lemma_collinearorder).
assert (neq B Q) by (forward_using lemma_betweennotequal).
assert (neq Q B) by (conclude lemma_inequalitysymmetric).
assert (Col B M A) by (conclude lemma_collinear4).
assert (Col A B M) by (forward_using lemma_collinearorder).
assert (~ eq M C).
assert (Per P M C) by (conclude_def Per ).
assert (eq M M) by (conclude cn_equalityreflexive).
assert (Col C M M) by (conclude_def Col ).
assert (Perp_at C M A B M) by (conclude_def Perp_at ).
close.

*****

*****

+++++
Qed.
-----
End Euclid.
-----
