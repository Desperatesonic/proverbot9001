Require  Export parallel_lemmas.
-----
Definition on_line (A B C : Point) : Prop := Col A B C /\ B <> C.
-----
Definition on_line_d (A B C : Point) (lambda : F) : Prop :=\n  Col A B C /\ B <> C /\ B ** A = lambda * B ** C.
-----
Definition inter_ll (I A B C D : Point) : Prop :=\n  Col I A B /\ Col I C D /\ ~ parallel A B C D.
-----
Definition on_parallel (A' A B C : Point) : Prop := B <> C  /\ parallel A A' B C.
-----
Definition on_parallel_d (Y R P Q : Point) (lambda : F) : Prop :=\n  P <> Q  /\ parallel Y R P Q /\ R ** Y = lambda * P ** Q.
-----
Definition on_inter_line_parallel (Y R U V P Q : Point) : Prop :=\n  ~Col R P Q /\ Col Y U V /\ parallel Y R P Q /\ ~ parallel P Q U V.
-----
Definition on_inter_parallel_parallel (Y R U V W P Q : Point) : Prop :=\n  ~Col R P Q /\ parallel Y R U V /\ parallel Y W P Q /\ ~ parallel P Q U V.
-----
Definition is_midpoint (I A B : Point) := on_line_d I A B (1 / 2).
-----
Definition mratio (Y U V : Point) (r : F) :=\n  on_parallel_d Y U U V (r / (1 + r)) /\ 1 + r  <> 0.
-----
Lemma on_line_to_on_line_d : forall A B C,\n on_line A B C -> on_line_d A B C (B**A / B**C).
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).

*****

*****
forall (A B C : Point) (_ : on_line A B C), on_line_d A B C (Fdiv (DSeg B A) (DSeg B C))
+++++
Proof.
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).
Proof.

*****

*****
forall (A B C : Point) (_ : on_line A B C), on_line_d A B C (Fdiv (DSeg B A) (DSeg B C))
+++++
intros.
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).
Proof.
intros.

*****
H : on_line A B C
A,B,C : Point
*****
on_line_d A B C (Fdiv (DSeg B A) (DSeg B C))
+++++
unfold on_line, on_line_d in *.
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).
Proof.
intros.
unfold on_line, on_line_d in *.

*****
H : and (Col A B C) (not (eq B C))
A,B,C : Point
*****
and (Col A B C) (and (not (eq B C)) (eq (DSeg B A) (Fmult (Fdiv (DSeg B A) (DSeg B C)) (DSeg B C))))
+++++
intuition.
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).
Proof.
intros.
unfold on_line, on_line_d in *.
intuition.

*****
H1 : forall _ : eq B C, False
H0 : Col A B C
A,B,C : Point
*****
eq (DSeg B A) (Fmult (Fdiv (DSeg B A) (DSeg B C)) (DSeg B C))
+++++
field.
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).
Proof.
intros.
unfold on_line, on_line_d in *.
intuition.
field.

*****
H1 : forall _ : eq B C, False
H0 : Col A B C
A,B,C : Point
*****
not (eq (DSeg B C) F0)
+++++
Geometry.
-----
Lemma on_line_to_on_line_d : forall A B C, on_line A B C -> on_line_d A B C (B**A / B**C).
Proof.
intros.
unfold on_line, on_line_d in *.
intuition.
field.
Geometry.

*****

*****

+++++
Qed.
-----
Lemma on_parallel_to_on_parallel_d : forall  Y T A B,\n on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).

*****

*****
forall (Y T A B : Point) (_ : on_parallel Y T A B), on_parallel_d Y T A B (Fdiv (DSeg T Y) (DSeg A B))
+++++
Proof.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.

*****

*****
forall (Y T A B : Point) (_ : on_parallel Y T A B), on_parallel_d Y T A B (Fdiv (DSeg T Y) (DSeg A B))
+++++
intros.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.
intros.

*****
H : on_parallel Y T A B
Y,T,A,B : Point
*****
on_parallel_d Y T A B (Fdiv (DSeg T Y) (DSeg A B))
+++++
unfold on_parallel in *.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.
intros.
unfold on_parallel in *.

*****
H : and (not (eq A B)) (parallel T Y A B)
Y,T,A,B : Point
*****
on_parallel_d Y T A B (Fdiv (DSeg T Y) (DSeg A B))
+++++
unfold on_parallel_d in *.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.
intros.
unfold on_parallel in *.
unfold on_parallel_d in *.

*****
H : and (not (eq A B)) (parallel T Y A B)
Y,T,A,B : Point
*****
and (not (eq A B)) (and (parallel Y T A B) (eq (DSeg T Y) (Fmult (Fdiv (DSeg T Y) (DSeg A B)) (DSeg A B))))
+++++
intuition.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.
intros.
unfold on_parallel in *.
unfold on_parallel_d in *.
intuition.

*****
H1 : parallel T Y A B
H0 : forall _ : eq A B, False
Y,T,A,B : Point
*****
eq (DSeg T Y) (Fmult (Fdiv (DSeg T Y) (DSeg A B)) (DSeg A B))
+++++
field.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.
intros.
unfold on_parallel in *.
unfold on_parallel_d in *.
intuition.
field.

*****
H1 : parallel T Y A B
H0 : forall _ : eq A B, False
Y,T,A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
Geometry.
-----
Lemma on_parallel_to_on_parallel_d : forall Y T A B, on_parallel Y T A B -> on_parallel_d Y T A B (T**Y / A**B).
Proof.
intros.
unfold on_parallel in *.
unfold on_parallel_d in *.
intuition.
field.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.

*****

*****
forall (P Q : Point) (_ : not (eq P Q)), sig (fun Y : Point => Col Y P Q)
+++++
Proof.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.

*****

*****
forall (P Q : Point) (_ : not (eq P Q)), sig (fun Y : Point => Col Y P Q)
+++++
intros.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.
intros.

*****
H : not (eq P Q)
P,Q : Point
*****
sig (fun Y : Point => Col Y P Q)
+++++
assert (T := A2a P Q 1).
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.
intros.
assert (T := A2a P Q 1).

*****
T : sig\n (fun P0 : Point =>\n and (Col P Q P0) (eq (DSeg P P0) (Fmult F1 (DSeg P Q))))
H : not (eq P Q)
P,Q : Point
*****
sig (fun Y : Point => Col Y P Q)
+++++
Geometry.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.
intros.
assert (T := A2a P Q 1).
Geometry.

*****
T : sig\n (fun P0 : Point =>\n and (Col P Q P0) (eq (DSeg P P0) (Fmult F1 (DSeg P Q))))
H : not (eq P Q)
P,Q : Point
*****
sig (fun Y : Point => Col Y P Q)
+++++
DecompExAnd T X.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.
intros.
assert (T := A2a P Q 1).
Geometry.
DecompExAnd T X.

*****
H2 : eq (DSeg P X) (Fmult F1 (DSeg P Q))
H1 : Col P Q X
X : Point
H : not (eq P Q)
P,Q : Point
*****
sig (fun Y : Point => Col Y P Q)
+++++
exists X.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.
intros.
assert (T := A2a P Q 1).
Geometry.
DecompExAnd T X.
exists X.

*****
H2 : eq (DSeg P X) (Fmult F1 (DSeg P Q))
H1 : Col P Q X
X : Point
H : not (eq P Q)
P,Q : Point
*****
Col X P Q
+++++
Geometry.
-----
Theorem on_lineex : forall P Q : Point, P <> Q -> {Y : Point | Col Y P Q}.
Proof.
intros.
assert (T := A2a P Q 1).
Geometry.
DecompExAnd T X.
exists X.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.

*****

*****
forall (P Q : Point) (_ : not (eq P Q)), ex (fun Y : Point => on_line Y P Q)
+++++
Proof.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.

*****

*****
forall (P Q : Point) (_ : not (eq P Q)), ex (fun Y : Point => on_line Y P Q)
+++++
intros.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.

*****
H : not (eq P Q)
P,Q : Point
*****
ex (fun Y : Point => on_line Y P Q)
+++++
assert {Y : Point | Col Y P Q}.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.

*****
H : not (eq P Q)
P,Q : Point
*****
sig (fun Y : Point => Col Y P Q)
+++++
apply on_lineex.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.
apply on_lineex.

*****
H : not (eq P Q)
P,Q : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.

*****
H0 : sig (fun Y : Point => Col Y P Q)
H : not (eq P Q)
P,Q : Point
*****
ex (fun Y : Point => on_line Y P Q)
+++++
DecompEx H0 Y.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.
DecompEx H0 Y.

*****
p : Col Y P Q
Y : Point
H : not (eq P Q)
P,Q : Point
*****
ex (fun Y : Point => on_line Y P Q)
+++++
exists Y.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.
DecompEx H0 Y.
exists Y.

*****
p : Col Y P Q
Y : Point
H : not (eq P Q)
P,Q : Point
*****
on_line Y P Q
+++++
unfold on_line.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.
DecompEx H0 Y.
exists Y.
unfold on_line.

*****
p : Col Y P Q
Y : Point
H : not (eq P Q)
P,Q : Point
*****
and (Col Y P Q) (not (eq P Q))
+++++
Geometry.
-----
Theorem on_line_ex : forall P Q : Point, P<>Q -> exists Y, on_line Y P Q.
Proof.
intros.
assert {Y : Point | Col Y P Q}.

*****

*****

+++++
Qed.
-----
Theorem on_line_dex :\n forall (P Q : Point) (lambda : F),\n P <> Q -> {Y : Point | Col Y P Q /\ P ** Y = lambda * P ** Q}.
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.

*****

*****
forall (P Q : Point) (lambda : F) (_ : not (eq P Q)), sig (fun Y : Point => and (Col Y P Q) (eq (DSeg P Y) (Fmult lambda (DSeg P Q))))
+++++
Proof.
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.
Proof.

*****

*****
forall (P Q : Point) (lambda : F) (_ : not (eq P Q)), sig (fun Y : Point => and (Col Y P Q) (eq (DSeg P Y) (Fmult lambda (DSeg P Q))))
+++++
intros.
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.
Proof.
intros.

*****
H : not (eq P Q)
lambda : F
P,Q : Point
*****
sig (fun Y : Point => and (Col Y P Q) (eq (DSeg P Y) (Fmult lambda (DSeg P Q))))
+++++
assert (T := A2a P Q lambda).
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.
Proof.
intros.
assert (T := A2a P Q lambda).

*****
T : sig\n (fun P0 : Point =>\n and (Col P Q P0) (eq (DSeg P P0) (Fmult lambda (DSeg P Q))))
H : not (eq P Q)
lambda : F
P,Q : Point
*****
sig (fun Y : Point => and (Col Y P Q) (eq (DSeg P Y) (Fmult lambda (DSeg P Q))))
+++++
DecompExAnd T X.
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.
Proof.
intros.
assert (T := A2a P Q lambda).
DecompExAnd T X.

*****
H2 : eq (DSeg P X) (Fmult lambda (DSeg P Q))
H1 : Col P Q X
X : Point
H : not (eq P Q)
lambda : F
P,Q : Point
*****
sig (fun Y : Point => and (Col Y P Q) (eq (DSeg P Y) (Fmult lambda (DSeg P Q))))
+++++
exists X.
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.
Proof.
intros.
assert (T := A2a P Q lambda).
DecompExAnd T X.
exists X.

*****
H2 : eq (DSeg P X) (Fmult lambda (DSeg P Q))
H1 : Col P Q X
X : Point
H : not (eq P Q)
lambda : F
P,Q : Point
*****
and (Col X P Q) (eq (DSeg P X) (Fmult lambda (DSeg P Q)))
+++++
Geometry.
-----
Theorem on_line_dex : forall (P Q : Point) (lambda : F), P <> Q -> {Y : Point | Col Y P Q /\\ P ** Y = lambda * P ** Q}.
Proof.
intros.
assert (T := A2a P Q lambda).
DecompExAnd T X.
exists X.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem inter_llex :\n forall P Q U V : Point,\n ~ parallel P Q U V -> {Y : Point | Col Y P Q /\ Col Y U V}.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Proof.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
intros.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
assert (P <> Q).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
eapply par_aux_1.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
eapply par_aux_1.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (parallel P Q ?U ?V)
+++++
apply H.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).

*****
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
assert (T := A2a P Q (S P U V / S4 P U Q V)).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).

*****
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.

*****
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
elim T.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.

*****
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
forall (x : Point) (_ : and (Col P Q x) (eq (DSeg P x) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)))), sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
intro O.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.

*****
O : Point
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
forall _ : and (Col P Q O) (eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))), sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
intros.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.

*****
p : and (Col P Q O)\n (eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)))
O : Point
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.

*****
p : and (Col P Q O)\n (eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)))
O : Point
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
decompose [and] p.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
p : and (Col P Q O)\n (eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)))
O : Point
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
p : and (Col P Q O)\n (eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)))
O : Point
T : sig\n (fun P0 : Point =>\n and (Col P Q P0)\n (eq (DSeg P P0) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))))
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
clear T p.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
forall _ : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V))), sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
forall _ : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V))), sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
intro.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.

*****
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.

*****
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).

*****
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S O U V) (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V)) (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.

*****
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S O U V) (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V)) (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
+++++
apply l2_9.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
apply l2_9.

*****
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
apply l2_9.

*****
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
Col O P Q
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
rewrite H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
rewrite H2.

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
rewrite H2.
Geometry.

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
field.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
rewrite H2.
Geometry.
field.

*****
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
and (not (eq (S4 P U Q V) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).

*****
H5 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.

*****
H5 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
clear H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.

*****
H5 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
rename H5 into H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (DSeg P O) (DSeg P Q)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
rewrite H2 in H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fdiv (DSeg O Q) (DSeg P Q)) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
rewrite H3 in H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
assert (S O U V = 0).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S O U V) F0
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).
Geometry.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S O U V) F0
+++++
rewrite H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).
Geometry.
rewrite H4.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V)) (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V))) F0
+++++
field.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).
Geometry.
rewrite H4.
field.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq (S4 P U Q V) F0)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).

*****
H5 : eq (S O U V) F0
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).
Geometry.

*****
H5 : eq (S O U V) F0
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
exists O.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
intro.
Geometry.
assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H5 into H2.
Geometry.
rewrite H2 in H4.
Geometry.
rewrite H3 in H4.
Geometry.
assert (S O U V = 0).
Geometry.
exists O.

*****
H5 : eq (S O U V) F0
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H4 : eq (S O U V)\n (Fplus (Fmult (Fdiv (S P U V) (S4 P U Q V)) (S Q U V))\n (Fmult (Fopp (Fdiv (S Q U V) (S4 P U Q V))) (S P U V)))
H3 : eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
and (Col O P Q) (Col O U V)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
rewrite H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
rewrite H2.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q)) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
+++++
field.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
rewrite H2.
field.

*****
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
and (not (eq (S4 P U Q V) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).

*****
H3 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.

*****
H3 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H2 : eq (DSeg P O) (Fmult (Fdiv (S P U V) (S4 P U Q V)) (DSeg P Q))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
clear H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.

*****
H3 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
rename H3 into H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
assert (P ** Q + Q ** O = P ** O).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).

*****
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (DSeg P O) (DSeg P Q)) (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
rewrite <- H3 in H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
+++++
rewrite <- H2.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fminus F1 (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fminus F1 (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q)))
+++++
assert (O ** Q = - Q ** O).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.
assert (O ** Q = - Q ** O).

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (DSeg O Q) (Fopp (DSeg Q O))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.
assert (O ** Q = - Q ** O).

*****
H4 : eq (DSeg O Q) (Fopp (DSeg Q O))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fminus F1 (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.
assert (O ** Q = - Q ** O).
Geometry.

*****
H4 : eq (DSeg O Q) (Fopp (DSeg Q O))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fminus F1 (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q)))
+++++
rewrite H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.
assert (O ** Q = - Q ** O).
Geometry.
rewrite H4.

*****
H4 : eq (DSeg O Q) (Fopp (DSeg Q O))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fopp (DSeg Q O)) (DSeg P Q)) (Fminus F1 (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.
assert (O ** Q = - Q ** O).
Geometry.
rewrite H4.
Geometry.

*****
H4 : eq (DSeg O Q) (Fopp (DSeg Q O))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fopp (DSeg Q O)) (DSeg P Q)) (Fminus F1 (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q)))
+++++
field.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
rewrite <- H2.
Geometry.
assert (O ** Q = - Q ** O).
Geometry.
rewrite H4.
Geometry.
field.

*****
H4 : eq (DSeg O Q) (Fopp (DSeg Q O))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus F1 (Fdiv (S P U V) (S4 P U Q V))) (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus F1 (Fdiv (S P U V) (S4 P U Q V))) (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
+++++
field.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
field.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq (S4 P U Q V) F0)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).

*****
H5 : eq (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.

*****
H5 : eq (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
rewrite H5 in H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.

*****
H5 : eq (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.

*****
H5 : eq (Fminus F1 (Fdiv (S P U V) (S4 P U Q V)))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
clear H5.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (S4 P U Q V) (S P U V)) (S4 P U Q V))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
unfold S4 in H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
assert (S P U Q + S P Q V - S P U V = - S Q U V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
+++++
assert (S P Q V = S P Q U + S P U V + S U Q V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).

*****
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).

*****
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.

*****
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
+++++
rewrite H5.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.

*****
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.

*****
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
assert (S P Q U = - S P U Q).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).

*****
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S P Q U) (Fopp (S P U Q))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).

*****
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.

*****
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
rewrite H6.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.

*****
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (Fopp (S P U Q)) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.
Geometry.

*****
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (Fopp (S P U Q)) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
assert (S U Q V = - S Q U V).
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.
Geometry.
assert (S U Q V = - S Q U V).

*****
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (S U Q V) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.
Geometry.
assert (S U Q V = - S Q U V).

*****
H7 : eq (S U Q V) (Fopp (S Q U V))
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (Fopp (S P U Q)) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.
Geometry.
assert (S U Q V = - S Q U V).
Geometry.

*****
H7 : eq (S U Q V) (Fopp (S Q U V))
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (Fopp (S P U Q)) (S P U V)) (S U Q V))) (S P U V)) (Fopp (S Q U V))
+++++
rewrite H7.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.
Geometry.
assert (S U Q V = - S Q U V).
Geometry.
rewrite H7.

*****
H7 : eq (S U Q V) (Fopp (S Q U V))
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (Fopp (S P U Q)) (S P U V)) (Fopp (S Q U V)))) (S P U V)) (Fopp (S Q U V))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
assert (S P Q V = S P Q U + S P U V + S U Q V).
Geometry.
rewrite H5.
Geometry.
assert (S P Q U = - S P U Q).
Geometry.
rewrite H6.
Geometry.
assert (S U Q V = - S Q U V).
Geometry.
rewrite H7.
Geometry.

*****
H7 : eq (S U Q V) (Fopp (S Q U V))
H6 : eq (S P Q U) (Fopp (S P U Q))
H5 : eq (S P Q V) (Fplus (Fplus (S P Q U) (S P U V)) (S U Q V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fminus (Fplus (S P U Q) (Fplus (Fplus (Fopp (S P U Q)) (S P U V)) (Fopp (S Q U V)))) (S P U V)) (Fopp (S Q U V))
+++++
ring.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V))\n (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
rewrite H5 in H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.
Geometry.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (DSeg O Q) (DSeg P Q)) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
rewrite H4.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.
Geometry.
rewrite H4.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V))) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.
Geometry.
rewrite H4.
Geometry.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V))) (Fopp (Fdiv (S Q U V) (S4 P U Q V)))
+++++
unfold S4 in |- *.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.
Geometry.
rewrite H4.
Geometry.
unfold S4 in |- *.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V))) (Fopp (Fdiv (S Q U V) (Fplus (S P U Q) (S P Q V))))
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.
Geometry.
rewrite H4.
Geometry.
unfold S4 in |- *.
Geometry.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
eq (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V))) (Fopp (Fdiv (S Q U V) (Fplus (S P U Q) (S P Q V))))
+++++
field.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).
assert (T := A2a P Q (S P U V / S4 P U Q V)).
Geometry.
elim T.
intro O.
intros.
Geometry.
decompose [and] p.
Geometry.
clear T p.
Geometry.
cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V)).
Geometry.
assert (P ** O / P ** Q = S P U V / S4 P U Q V).
Geometry.
clear H2.
rename H3 into H2.
Geometry.
assert (P ** Q + Q ** O = P ** O).
Geometry.
rewrite <- H3 in H2.
Geometry.
assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V).
Geometry.
assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V).
Geometry.
rewrite H5 in H4.
Geometry.
clear H5.
Geometry.
unfold S4 in H4.
Geometry.
assert (S P U Q + S P Q V - S P U V = - S Q U V).
Geometry.
rewrite H5 in H4.
Geometry.
rewrite H4.
Geometry.
unfold S4 in |- *.
Geometry.
field.

*****
H5 : eq (Fminus (Fplus (S P U Q) (S P Q V)) (S P U V)) (Fopp (S Q U V))
H4 : eq (Fdiv (DSeg O Q) (DSeg P Q))\n (Fdiv (Fopp (S Q U V)) (Fplus (S P U Q) (S P Q V)))
H3 : eq (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P O)
H2 : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q O)) (DSeg P Q))\n (Fdiv (S P U V) (S4 P U Q V))
H1 : Col P Q O
O : Point
H0 : not (eq P Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq (Fplus (S P U Q) (S P Q V)) F0)
+++++
Geometry.
-----
Theorem inter_llex : forall P Q U V : Point, ~ parallel P Q U V -> {Y : Point | Col Y P Q /\\ Col Y U V}.
Proof.
intros.
assert (P <> Q).

*****

*****

+++++
Qed.
-----
Lemma inter_ll_ex :  forall P Q U V : Point,\n ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), ex (fun Y : Point => inter_ll Y P Q U V)
+++++
Proof.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), ex (fun Y : Point => inter_ll Y P Q U V)
+++++
intros.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
ex (fun Y : Point => inter_ll Y P Q U V)
+++++
assert {Y : Point | Col Y P Q /\ Col Y U V}.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
+++++
apply inter_llex.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.
apply inter_llex.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (parallel P Q U V)
+++++
intuition.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.

*****
H0 : sig (fun Y : Point => and (Col Y P Q) (Col Y U V))
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
ex (fun Y : Point => inter_ll Y P Q U V)
+++++
DecompExAnd H0 Y.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.
DecompExAnd H0 Y.

*****
H3 : Col Y U V
H2 : Col Y P Q
Y : Point
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
ex (fun Y : Point => inter_ll Y P Q U V)
+++++
exists Y.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.
DecompExAnd H0 Y.
exists Y.

*****
H3 : Col Y U V
H2 : Col Y P Q
Y : Point
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
inter_ll Y P Q U V
+++++
unfold inter_ll.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.
DecompExAnd H0 Y.
exists Y.
unfold inter_ll.

*****
H3 : Col Y U V
H2 : Col Y P Q
Y : Point
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
and (Col Y P Q) (and (Col Y U V) (not (parallel P Q U V)))
+++++
intuition.
-----
Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V.
Proof.
intros.
assert {Y : Point | Col Y P Q /\\ Col Y U V}.

*****

*****

+++++
Qed.
-----
Theorem on_parallelex : forall P Q R : Point, \n  Q<>R -> \n  ~ Col P Q R ->\n  exists Y, parallel Q R P Y.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.

*****

*****
forall (P Q R : Point) (_ : not (eq Q R)) (_ : not (Col P Q R)), ex (fun Y : Point => parallel Q R P Y)
+++++
Proof.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.

*****

*****
forall (P Q R : Point) (_ : not (eq Q R)) (_ : not (Col P Q R)), ex (fun Y : Point => parallel Q R P Y)
+++++
intros.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.
intros.

*****
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
ex (fun Y : Point => parallel Q R P Y)
+++++
assert ({Y : Point | parallel Q R P Y}).
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).

*****
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
sig (fun Y : Point => parallel Q R P Y)
+++++
apply euclid_parallel_existence.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).

*****
H1 : sig (fun Y : Point => parallel Q R P Y)
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
ex (fun Y : Point => parallel Q R P Y)
+++++
DecompEx H1 Y.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).
DecompEx H1 Y.

*****
p : parallel Q R P Y
Y : Point
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
ex (fun Y : Point => parallel Q R P Y)
+++++
exists Y.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).
DecompEx H1 Y.
exists Y.

*****
p : parallel Q R P Y
Y : Point
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
parallel Q R P Y
+++++
intuition.
-----
Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).

*****

*****

+++++
Qed.
-----
Theorem on_parallel_ex : forall P Q R : Point, \n  Q<>R -> \n  ~ Col P Q R ->\n  exists Y, on_parallel Y P Q R.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.

*****

*****
forall (P Q R : Point) (_ : not (eq Q R)) (_ : not (Col P Q R)), ex (fun Y : Point => on_parallel Y P Q R)
+++++
Proof.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.

*****

*****
forall (P Q R : Point) (_ : not (eq Q R)) (_ : not (Col P Q R)), ex (fun Y : Point => on_parallel Y P Q R)
+++++
intros.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.

*****
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel Y P Q R)
+++++
assert ({Y : Point | parallel Q R P Y}).
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).

*****
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
sig (fun Y : Point => parallel Q R P Y)
+++++
apply euclid_parallel_existence.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).

*****
H1 : sig (fun Y : Point => parallel Q R P Y)
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel Y P Q R)
+++++
elim H1.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).
elim H1.

*****
H1 : sig (fun Y : Point => parallel Q R P Y)
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
forall (x : Point) (_ : parallel Q R P x), ex (fun Y : Point => on_parallel Y P Q R)
+++++
intros.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).
elim H1.
intros.

*****
p : parallel Q R P x
x : Point
H1 : sig (fun Y : Point => parallel Q R P Y)
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel Y P Q R)
+++++
exists x.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).
elim H1.
intros.
exists x.

*****
p : parallel Q R P x
x : Point
H1 : sig (fun Y : Point => parallel Q R P Y)
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
on_parallel x P Q R
+++++
unfold on_parallel.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).
elim H1.
intros.
exists x.
unfold on_parallel.

*****
p : parallel Q R P x
x : Point
H1 : sig (fun Y : Point => parallel Q R P Y)
H0 : not (Col P Q R)
H : not (eq Q R)
P,Q,R : Point
*****
and (not (eq Q R)) (parallel P x Q R)
+++++
intuition.
-----
Theorem on_parallel_ex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, on_parallel Y P Q R.
Proof.
intros.
assert ({Y : Point | parallel Q R P Y}).

*****

*****

+++++
Qed.
-----
Lemma  on_parallel_d_ex :\n    forall (P Q R : Point) (lambda : F),\n   P<>Q -> \n   ~ Col P Q R ->\n   exists Y, on_parallel_d Y R P Q lambda.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.

*****

*****
forall (P Q R : Point) (lambda : F) (_ : not (eq P Q)) (_ : not (Col P Q R)), ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
Proof.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.

*****

*****
forall (P Q R : Point) (lambda : F) (_ : not (eq P Q)) (_ : not (Col P Q R)), ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
intros.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.

*****
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
assert ({Y':Point | (parallel P Q R Y') /\ R<>Y'}).
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).

*****
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
sig (fun Y' : Point => and (parallel P Q R Y') (not (eq R Y')))
+++++
apply euclid_parallel_existence_strong.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
apply euclid_parallel_existence_strong.

*****
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).

*****
H1 : sig (fun Y' : Point => and (parallel P Q R Y') (not (eq R Y')))
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
DecompExAnd H1 Y'.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.

*****
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
assert {Y : Point | Col Y R Y' /\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.

*****
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
sig (fun Y : Point => and (Col Y R Y') (eq (DSeg R Y) (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))))
+++++
apply on_line_dex.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
apply on_line_dex.

*****
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
not (eq R Y')
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.

*****
H1 : sig\n (fun Y : Point =>\n and (Col Y R Y')\n (eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))))
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
DecompExAnd H1 Y.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
ex (fun Y : Point => on_parallel_d Y R P Q lambda)
+++++
exists Y.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
on_parallel_d Y R P Q lambda
+++++
unfold on_parallel_d.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
and (not (eq P Q)) (and (parallel Y R P Q) (eq (DSeg R Y) (Fmult lambda (DSeg P Q))))
+++++
repeat split.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
parallel Y R P Q
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
parallel Y R P Q
+++++
cut (parallel P Q R Y).
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
cut (parallel P Q R Y).

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
forall _ : parallel P Q R Y, parallel Y R P Q
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
cut (parallel P Q R Y).

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
parallel P Q R Y
+++++
eapply col_par_par.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
cut (parallel P Q R Y).
eapply col_par_par.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
not (eq R ?D)
+++++
apply H4.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
cut (parallel P Q R Y).
eapply col_par_par.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
parallel P Q R Y'
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
cut (parallel P Q R Y).
eapply col_par_par.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
Col R Y' Y
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
eq (DSeg R Y) (Fmult lambda (DSeg P Q))
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
eq (DSeg R Y) (Fmult lambda (DSeg P Q))
+++++
rewrite H6.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
rewrite H6.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
eq (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y')) (Fmult lambda (DSeg P Q))
+++++
field.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).
DecompExAnd H1 Y'.
assert {Y : Point | Col Y R Y' /\\ R ** Y = (lambda * P**Q/R**Y') * R ** Y'}.
DecompExAnd H1 Y.
exists Y.
unfold on_parallel_d.
repeat split.
Geometry.
rewrite H6.
field.

*****
H6 : eq (DSeg R Y)\n (Fmult (Fdiv (Fmult lambda (DSeg P Q)) (DSeg R Y')) (DSeg R Y'))
H5 : Col Y R Y'
Y : Point
H4 : not (eq R Y')
H3 : parallel P Q R Y'
Y' : Point
H0 : not (Col P Q R)
H : not (eq P Q)
lambda : F
P,Q,R : Point
*****
not (eq (DSeg R Y') F0)
+++++
Geometry.
-----
Lemma on_parallel_d_ex : forall (P Q R : Point) (lambda : F), P<>Q -> ~ Col P Q R -> exists Y, on_parallel_d Y R P Q lambda.
Proof.
intros.
assert ({Y':Point | (parallel P Q R Y') /\\ R<>Y'}).

*****

*****

+++++
Qed.
-----
