Require Import GeoCoq.Axioms.continuity_axioms.
-----
Require Import GeoCoq.Tarski_dev.Annexes.saccheri.
-----
Require Import GeoCoq.Tarski_dev.Ch13_1.
-----
Require Import GeoCoq.Meta_theory.Continuity.grad.
-----
Section Archimedes.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D,\n  Bet A0 D1 A1 -> Cong E0 E1 A1 D1 ->\n  Grad A0 D1 D ->\n  exists A E, Grad2 A0 A1 A E0 E1 E /\ Cong E0 E A D /\ Bet A0 D A.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A0 A1 E0 E1 D1 D : Tpoint) (_ : Bet A0 D1 A1) (_ : Cong E0 E1 A1 D1) (_ : Grad A0 D1 D), ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A D) (Bet A0 D A))))
+++++
Proof.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A0 A1 E0 E1 D1 D : Tpoint) (_ : Bet A0 D1 A1) (_ : Cong E0 E1 A1 D1) (_ : Grad A0 D1 D), ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A D) (Bet A0 D A))))
+++++
intros A0 A1 E0 E1 D1 D HBet HCong HG.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.

*****
HG : Grad A0 D1 D
HCong : Cong E0 E1 A1 D1
HBet : Bet A0 D1 A1
A0,A1,E0,E1,D1,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A D) (Bet A0 D A))))
+++++
induction HG.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.

*****
HCong : Cong E0 E1 A1 B
HBet : Bet A B A1
A1,E0,E1,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => ex (fun E : Tpoint => and (Grad2 A A1 A0 E0 E1 E) (and (Cong E0 E A0 B) (Bet A B A0))))
+++++
exists A1; exists E1; repeat split; auto; apply grad2_init.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.

*****
IHHG : forall (_ : Bet A B A1) (_ : Cong E0 E1 A1 B),\nex\n (fun A0 : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Grad2 A A1 A0 E0 E1 E) (and (Cong E0 E A0 C) (Bet A C A0))))
H0 : Cong A B C C'
H : Bet A C C'
HG : Grad A B C
C,C' : Tpoint
HCong : Cong E0 E1 A1 B
HBet : Bet A B A1
A1,E0,E1,A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => ex (fun E : Tpoint => and (Grad2 A A1 A0 E0 E1 E) (and (Cong E0 E A0 C') (Bet A C' A0))))
+++++
rename A into A0.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.

*****
IHHG : forall (_ : Bet A0 B A1) (_ : Cong E0 E1 A1 B),\nex\n (fun A : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C) (Bet A0 C A))))
H0 : Cong A0 B C C'
H : Bet A0 C C'
HG : Grad A0 B C
C,C' : Tpoint
HCong : Cong E0 E1 A1 B
HBet : Bet A0 B A1
A1,E0,E1,A0,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C') (Bet A0 C' A))))
+++++
rename B into C1.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.

*****
IHHG : forall (_ : Bet A0 C1 A1) (_ : Cong E0 E1 A1 C1),\nex\n (fun A : Tpoint =>\n ex\n (fun E : Tpoint =>\n and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C) (Bet A0 C A))))
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C') (Bet A0 C' A))))
+++++
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.

*****
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C') (Bet A0 C' A))))
+++++
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].

*****
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C') (Bet A0 C' A))))
+++++
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].

*****
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => ex (fun E : Tpoint => and (Grad2 A0 A1 A E0 E1 E) (and (Cong E0 E A C') (Bet A0 C' A))))
+++++
exists A'; exists E'.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.

*****
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Grad2 A0 A1 A' E0 E1 E') (and (Cong E0 E' A' C') (Bet A0 C' A'))
+++++
assert(HBet5 : Bet A0 C' A').
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').

*****
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 C' A'
+++++
assert(HBet5 : Bet A0 C A') by eBetween.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 C' A'
+++++
assert(Bet C C' A'); [|eBetween].
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
apply grad2__grad123 in HG2.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
apply grad__bet in HG.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
apply grad__bet in HG2.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
elim(eq_dec_points A0 C).
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A0 C, Bet C C' A'
+++++
intro; treat_equalities; Between.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.

*****
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A0 C), Bet C C' A'
+++++
intro.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.

*****
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
elim(eq_dec_points C C').
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').

*****
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq C C', Bet C C' A'
+++++
intro; treat_equalities; Between.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.

*****
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq C C'), Bet C C' A'
+++++
intro.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.

*****
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
elim(eq_dec_points A' C).
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).

*****
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A' C, Bet C C' A'
+++++
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.

*****
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A' C), Bet C C' A'
+++++
intro.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.
intro.

*****
H3 : not (eq A' C)
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C' A'
+++++
apply l6_13_1.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.
intro.
apply l6_13_1.

*****
H3 : not (eq A' C)
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C C' A'
+++++
destruct (l6_2 C' A' A0 C); Between.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.
intro.
apply l6_13_1.
destruct (l6_2 C' A' A0 C); Between.

*****
H3 : not (eq A' C)
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C C' C A'
+++++
apply (le_transitivity _ _ A A').
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.
intro.
apply l6_13_1.
destruct (l6_2 C' A' A0 C); Between.
apply (le_transitivity _ _ A A').

*****
H3 : not (eq A' C)
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C C' A A'
+++++
apply (l5_6 A0 C1 A0 A1); Cong; exists C1; split; Cong.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
assert(HBet5 : Bet A0 C A') by eBetween.
assert(Bet C C' A'); [|eBetween].
apply grad2__grad123 in HG2.
apply grad__bet in HG.
apply grad__bet in HG2.
elim(eq_dec_points A0 C).
intro; treat_equalities; Between.
intro.
elim(eq_dec_points C C').
intro; treat_equalities; Between.
intro.
elim(eq_dec_points A' C).
intro; subst A'; assert (A=C) by (apply (between_equality _ _ A0); Between); treat_equalities; Between.
intro.
apply l6_13_1.
destruct (l6_2 C' A' A0 C); Between.
apply (le_transitivity _ _ A A').
apply (l5_6 A0 C1 A0 A1); Cong; exists C1; split; Cong.

*****
H3 : not (eq A' C)
H2 : not (eq C C')
H1 : not (eq A0 C)
HBet5 : Bet A0 C A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Bet A0 A1 A
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Bet A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A A' C A'
+++++
destruct(l5_12_a C A A'); eBetween.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').

*****
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Grad2 A0 A1 A' E0 E1 E') (and (Cong E0 E' A' C') (Bet A0 C' A'))
+++++
repeat split; auto.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.

*****
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad2 A0 A1 A' E0 E1 E'
+++++
apply grad2_stab with A E; Cong.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.

*****
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong E0 E' A' C'
+++++
assert (HD : Le E0 E1 A A').
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').

*****
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le E0 E1 A A'
+++++
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.

*****
HD : Le E0 E1 A A'
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong E0 E' A' C'
+++++
destruct HD as [D [HBet6 HCong6]].
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].

*****
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong E0 E' A' C'
+++++
apply (cong_transitivity _ _ C D).
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).

*****
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong E0 E' C D
+++++
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.

*****
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D A' C'
+++++
assert (Bet C D A') by eBetween.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.
assert (Bet C D A') by eBetween.

*****
H1 : Bet C D A'
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D A' C'
+++++
apply (l4_3 _ _ A' _ _ C); Cong; eBetween.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.
assert (Bet C D A') by eBetween.
apply (l4_3 _ _ A' _ _ C); Cong; eBetween.

*****
H1 : Bet C D A'
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D A' C' C
+++++
apply (cong_transitivity _ _ A0 C1); Cong.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.
assert (Bet C D A') by eBetween.
apply (l4_3 _ _ A' _ _ C); Cong; eBetween.
apply (cong_transitivity _ _ A0 C1); Cong.

*****
H1 : Bet C D A'
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D A' A0 C1
+++++
apply cong_left_commutativity; apply (l4_3 _ _ A _ _ A1); Between; Cong.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.
assert (Bet C D A') by eBetween.
apply (l4_3 _ _ A' _ _ C); Cong; eBetween.
apply (cong_transitivity _ _ A0 C1); Cong.
apply cong_left_commutativity; apply (l4_3 _ _ A _ _ A1); Between; Cong.

*****
H1 : Bet C D A'
HCong6 : Cong E0 E1 A D
HBet6 : Bet A D A'
D : Tpoint
HBet5 : Bet A0 C' A'
HCong4 : Cong E E' E0 E1
HBet4 : Bet E0 E E'
E' : Tpoint
HCong3 : Cong A A' A0 A1
HBet3 : Bet A0 A A'
A' : Tpoint
HBet2 : Bet A0 C A
HCong2 : Cong E0 E A C
HG2 : Grad2 A0 A1 A E0 E1 E
A,E : Tpoint
H0 : Cong A0 C1 C C'
H : Bet A0 C C'
HG : Grad A0 C1 C
C,C' : Tpoint
HCong : Cong E0 E1 A1 C1
HBet : Bet A0 C1 A1
A1,E0,E1,A0,C1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D A C1 A1
+++++
apply cong_transitivity with E0 E1; Cong.
-----
Lemma t22_18_aux1 : forall A0 A1 E0 E1 D1 D, Bet A0 D1 A1 -> Cong E0 E1 A1 D1 -> Grad A0 D1 D -> exists A E, Grad2 A0 A1 A E0 E1 E /\\ Cong E0 E A D /\\ Bet A0 D A.
Proof.
intros A0 A1 E0 E1 D1 D HBet HCong HG.
induction HG.
exists A1; exists E1; repeat split; auto; apply grad2_init.
rename A into A0.
rename B into C1.
destruct IHHG as [A [E [HG2 [HCong2 HBet2]]]]; auto.
destruct (segment_construction A0 A A0 A1) as [A' [HBet3 HCong3]].
destruct (segment_construction E0 E E0 E1) as [E' [HBet4 HCong4]].
exists A'; exists E'.
assert(HBet5 : Bet A0 C' A').
repeat split; auto.
apply grad2_stab with A E; Cong.
assert (HD : Le E0 E1 A A').
apply (l5_6 E0 E1 A1 A0); Cong; exists C1; split; Between.
destruct HD as [D [HBet6 HCong6]].
apply (cong_transitivity _ _ C D).
apply (l2_11 _ E _ _ A); Cong; eBetween; apply cong_transitivity with E0 E1; trivial.
assert (Bet C D A') by eBetween.
apply (l4_3 _ _ A' _ _ C); Cong; eBetween.
apply (cong_transitivity _ _ A0 C1); Cong.
apply cong_left_commutativity; apply (l4_3 _ _ A _ _ A1); Between; Cong.
apply cong_transitivity with E0 E1; Cong.

*****

*****

+++++
Qed.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E,\n  Saccheri A0 B0 B1 A1 ->\n  Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A0 A1 B0 B1 A B E : Tpoint) (_ : Saccheri A0 B0 B1 A1) (_ : Grad2 A0 A1 A B0 B1 E) (_ : Saccheri A0 B0 B A), Le B0 B B0 E
+++++
Proof.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A0 A1 B0 B1 A B E : Tpoint) (_ : Saccheri A0 B0 B1 A1) (_ : Grad2 A0 A1 A B0 B1 E) (_ : Saccheri A0 B0 B A), Le B0 B B0 E
+++++
intros A0 A1 B0 B1 A B E HSac1 HG.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.

*****
HG : Grad2 A0 A1 A B0 B1 E
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1,A,B,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Saccheri A0 B0 B A, Le B0 B B0 E
+++++
revert B.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.

*****
HG : Grad2 A0 A1 A B0 B1 E
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1,A,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : Saccheri A0 B0 B A), Le B0 B B0 E
+++++
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.

*****
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : Saccheri A0 B0 B A1), Le B0 B B0 B1
+++++
intros B HSac.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.

*****
HSac : Saccheri A0 B0 B A1
B : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B B0 B1
+++++
assert(B = B1); [|subst B; Le].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].

*****
HSac : Saccheri A0 B0 B A1
B : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B B1
+++++
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.

*****
H4 : not (eq B0 A1)
H3 : not (eq A0 B1)
H2 : not (eq A0 A1)
H1 : not (eq B1 A1)
H0 : not (eq B0 B1)
H : not (eq A0 B0)
H8 : OS A0 A1 B0 B
H7 : Cong A0 B0 B A1
H6 : Per A0 A1 B
H5 : Per B0 A0 A1
B : Tpoint
H12 : OS A0 A1 B0 B1
H11 : Cong A0 B0 B1 A1
H10 : Per A0 A1 B1
H9 : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B B1
+++++
apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.
apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].

*****
H4 : not (eq B0 A1)
H3 : not (eq A0 B1)
H2 : not (eq A0 A1)
H1 : not (eq B1 A1)
H0 : not (eq B0 B1)
H : not (eq A0 B0)
H8 : OS A0 A1 B0 B
H7 : Cong A0 B0 B A1
H6 : Per A0 A1 B
H5 : Per B0 A0 A1
B : Tpoint
H12 : OS A0 A1 B0 B1
H11 : Cong A0 B0 B1 A1
H10 : Per A0 A1 B1
H9 : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A1 B B1
+++++
apply (col_one_side_out _ A0).
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.
apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].
apply (col_one_side_out _ A0).

*****
H4 : not (eq B0 A1)
H3 : not (eq A0 B1)
H2 : not (eq A0 A1)
H1 : not (eq B1 A1)
H0 : not (eq B0 B1)
H : not (eq A0 B0)
H8 : OS A0 A1 B0 B
H7 : Cong A0 B0 B A1
H6 : Per A0 A1 B
H5 : Per B0 A0 A1
B : Tpoint
H12 : OS A0 A1 B0 B1
H11 : Cong A0 B0 B1 A1
H10 : Per A0 A1 B1
H9 : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A1 B B1
+++++
apply col_permutation_2, cop_per2__col with A0; Perp.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.
apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].
apply (col_one_side_out _ A0).
apply col_permutation_2, cop_per2__col with A0; Perp.

*****
H4 : not (eq B0 A1)
H3 : not (eq A0 B1)
H2 : not (eq A0 A1)
H1 : not (eq B1 A1)
H0 : not (eq B0 B1)
H : not (eq A0 B0)
H8 : OS A0 A1 B0 B
H7 : Cong A0 B0 B A1
H6 : Per A0 A1 B
H5 : Per B0 A0 A1
B : Tpoint
H12 : OS A0 A1 B0 B1
H11 : Cong A0 B0 B1 A1
H10 : Per A0 A1 B1
H9 : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A0 B B1 A1
+++++
apply coplanar_perm_3, coplanar_trans_1 with B0; Cop.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.
apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].
apply (col_one_side_out _ A0).
apply col_permutation_2, cop_per2__col with A0; Perp.
apply coplanar_perm_3, coplanar_trans_1 with B0; Cop.

*****
H4 : not (eq B0 A1)
H3 : not (eq A0 B1)
H2 : not (eq A0 A1)
H1 : not (eq B1 A1)
H0 : not (eq B0 B1)
H : not (eq A0 B0)
H8 : OS A0 A1 B0 B
H7 : Cong A0 B0 B A1
H6 : Per A0 A1 B
H5 : Per B0 A0 A1
B : Tpoint
H12 : OS A0 A1 B0 B1
H11 : Cong A0 B0 B1 A1
H10 : Per A0 A1 B1
H9 : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B0 A0 A1)
+++++
apply not_col_permutation_2, one_side_not_col123 with B1; assumption.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
intros B HSac.
assert(B = B1); [|subst B; Le].
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); unfold Saccheri in *; spliter.
apply (l6_11_uniqueness A1 A0 B0 B1); Cong; [|apply out_trivial; auto].
apply (col_one_side_out _ A0).
apply col_permutation_2, cop_per2__col with A0; Perp.
apply coplanar_perm_3, coplanar_trans_1 with B0; Cop.
apply not_col_permutation_2, one_side_not_col123 with B1; assumption.

*****
H4 : not (eq B0 A1)
H3 : not (eq A0 B1)
H2 : not (eq A0 A1)
H1 : not (eq B1 A1)
H0 : not (eq B0 B1)
H : not (eq A0 B0)
H8 : OS A0 A1 B0 B
H7 : Cong A0 B0 B A1
H6 : Per A0 A1 B
H5 : Per B0 A0 A1
B : Tpoint
H12 : OS A0 A1 B0 B1
H11 : Cong A0 B0 B1 A1
H10 : Per A0 A1 B1
H9 : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A1 A0 B B1
+++++
apply (one_side_transitivity _ _ _ B0); Side.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.

*****
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B C),\nLe B0 B B0 F
H2 : Cong B0 B1 F F'
H1 : Bet B0 F F'
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad2 A0 A1 C B0 B1 F
C,C',F,F' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : Saccheri A0 B0 B C'), Le B0 B B0 F'
+++++
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.

*****
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B : Tpoint) (_ : Saccheri A0 B0 B A'), Le B0 B B0 E'
+++++
intros B' HSac'.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.

*****
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
assert (A0 <> A).
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).

*****
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A0 A)
+++++
intro; treat_equalities.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
intro; treat_equalities.

*****
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint)\n (_ : Saccheri A0 B0 B A0), Le B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Grad2 A0 A1 A0 B0 B1 E
H0 : Cong A0 A1 A0 A'
A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (A0 = A1) by (apply between_identity, grad__bet, (grad2__grad123 _ _ _ B0 B1 E); auto).
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
intro; treat_equalities.
assert (A0 = A1) by (apply between_identity, grad__bet, (grad2__grad123 _ _ _ B0 B1 E); auto).

*****
H : eq A0 A1
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint)\n (_ : Saccheri A0 B0 B A0), Le B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Grad2 A0 A1 A0 B0 B1 E
H0 : Cong A0 A1 A0 A'
A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
intro; treat_equalities.
assert (A0 = A1) by (apply between_identity, grad__bet, (grad2__grad123 _ _ _ B0 B1 E); auto).
treat_equalities.

*****
HSac' : Saccheri A0 B0 B' A0
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A0) (B : Tpoint)\n (_ : Saccheri A0 B0 B A0), Le B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Grad2 A0 A0 A0 B0 B1 E
E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A0
A0,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply sac_distincts in HSac1; spliter; auto.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).

*****
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
assert (HB : exists B, Saccheri A0 B0 B A).
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).

*****
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => Saccheri A0 B0 B A)
+++++
clear dependent A'; clear dependent B'; clear IHHG.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.

*****
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Grad2 A0 A1 A B0 B1 E
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => Saccheri A0 B0 B A)
+++++
apply grad2__grad123 in HG.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.

*****
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Grad A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => Saccheri A0 B0 B A)
+++++
apply grad__bet in HG.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.

*****
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => Saccheri A0 B0 B A)
+++++
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.

*****
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A0 A1 B0)
+++++
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.

*****
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => Saccheri A0 B0 B A)
+++++
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].

*****
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
assert_diffs; auto.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.

*****
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A0 B0)
+++++
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.

*****
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => Saccheri A0 B0 B A)
+++++
exists B.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.

*****
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Saccheri A0 B0 B A
+++++
unfold Saccheri in *; spliter; assert_diffs.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Per B0 A0 A) (and (Per A0 A B) (and (Cong A0 B0 B A) (OS A0 A B0 B)))
+++++
repeat split; Cong.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B0 A0 A
+++++
-
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B0 A0 A
+++++
apply (per_col _ _ A1); Col.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.

*****

*****

+++++
-
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A0 A B
+++++
apply perp_per_2; auto.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A A0 A B
+++++
apply (perp_col1 _ _ _ P); Col.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A A0 A P
+++++
apply perp_comm; apply (perp_col _ A1); Col.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.

*****

*****

+++++
-
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A0 A B0 B
+++++
apply invert_one_side.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-
apply invert_one_side.

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A A0 B0 B
+++++
apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-
apply invert_one_side.
apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A A0 B0 P
+++++
apply invert_one_side.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
clear dependent A'; clear dependent B'; clear IHHG.
apply grad2__grad123 in HG.
apply grad__bet in HG.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]]; Col.
assert (HH := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac1); spliter; auto.
exists B.
unfold Saccheri in *; spliter; assert_diffs.
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-
apply invert_one_side.
apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].
apply invert_one_side.

*****
H19 : not (eq A1 P)
H15 : not (eq A0 P)
H12 : not (eq B1 A1)
H10 : not (eq A0 B0)
H11 : not (eq B A)
H9 : not (eq B0 A1)
H6 : not (eq A0 B1)
H8 : not (eq P A)
H7 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
H3 : not (eq A0 A)
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
HG : Bet A0 A1 A
A,E,E' : Tpoint
H5 : OS A0 A1 B0 B1
H4 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A0 A B0 P
+++++
apply (col_one_side _ A1); Col.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).

*****
HB : ex (fun B : Tpoint => Saccheri A0 B0 B A)
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
destruct HB as [B HSac].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].

*****
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
assert (HLe := HSac).
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).

*****
HSac,HLe : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
apply IHHG in HLe; auto.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.

*****
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
IHHG : forall (_ : Saccheri A0 B0 B1 A1) (B : Tpoint) (_ : Saccheri A0 B0 B A),\nLe B0 B B0 E
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
clear IHHG.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.

*****
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].

*****
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
assert (Cong B0 B1 B B').
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').

*****
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0 B1 B B'
+++++
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].

*****
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Saccheri A B B' A'
+++++
apply cop_sac2__sac with A0 B0; Cop.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.

*****
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A A')
+++++
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.

*****
H4 : Cong B0 B1 B B'
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 E'
+++++
apply (le_transitivity _ _ B0 C).
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.
apply (le_transitivity _ _ B0 C).

*****
H4 : Cong B0 B1 B B'
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B' B0 C
+++++
apply (triangle_inequality B0 B B' C); trivial.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.
apply (le_transitivity _ _ B0 C).
apply (triangle_inequality B0 B B' C); trivial.

*****
H4 : Cong B0 B1 B B'
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B B' B C
+++++
apply cong_transitivity with E E'; Cong.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.
apply (le_transitivity _ _ B0 C).
apply (triangle_inequality B0 B B' C); trivial.
apply cong_transitivity with E E'; Cong.

*****
H4 : Cong B0 B1 B B'
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B B' E E'
+++++
apply cong_transitivity with B0 B1; Cong.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.
apply (le_transitivity _ _ B0 C).
apply (triangle_inequality B0 B B' C); trivial.
apply cong_transitivity with E E'; Cong.
apply cong_transitivity with B0 B1; Cong.

*****
H4 : Cong B0 B1 B B'
HCong : Cong B C E E'
HBet : Bet B0 B C
C : Tpoint
HLe : Le B0 B B0 E
HSac : Saccheri A0 B0 B A
B : Tpoint
H3 : not (eq A0 A)
HSac' : Saccheri A0 B0 B' A'
B' : Tpoint
H2 : Cong B0 B1 E E'
H1 : Bet B0 E E'
H0 : Cong A0 A1 A A'
H : Bet A0 A A'
HG : Grad2 A0 A1 A B0 B1 E
A,A',E,E' : Tpoint
HSac1 : Saccheri A0 B0 B1 A1
A0,A1,B0,B1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 C B0 E'
+++++
apply (bet2_le2__le1346 _ B _ _ E); Le.
-----
Lemma t22_18_aux2 : forall A0 A1 B0 B1 A B E, Saccheri A0 B0 B1 A1 -> Grad2 A0 A1 A B0 B1 E -> Saccheri A0 B0 B A -> Le B0 B B0 E.
Proof.
intros A0 A1 B0 B1 A B E HSac1 HG.
revert B.
induction HG; rename A into A0; rename B into A1; rename D into B0; rename E into B1.
rename C into A; rename F into E; rename C' into A'; rename F' into E'.
intros B' HSac'.
assert (A0 <> A).
assert (HB : exists B, Saccheri A0 B0 B A).
destruct HB as [B HSac].
assert (HLe := HSac).
apply IHHG in HLe; auto.
clear IHHG.
destruct (segment_construction B0 B E E') as [C [HBet HCong]].
assert (Cong B0 B1 B B').
apply (cong2_sac2__cong A0 B0 B1 A1 A _ _ A'); auto; [|unfold Saccheri in *; spliter; Cong].
apply cop_sac2__sac with A0 B0; Cop.
intro; treat_equalities; apply sac_distincts in HSac1; spliter; auto.
apply (le_transitivity _ _ B0 C).
apply (triangle_inequality B0 B B' C); trivial.
apply cong_transitivity with E E'; Cong.
apply cong_transitivity with B0 B1; Cong.
apply (bet2_le2__le1346 _ B _ _ E); Le.

*****

*****

+++++
Qed.
-----
Lemma t22_18 :\n  archimedes_axiom ->\n  forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A0 B0 B1 A1 : Tpoint) (_ : Saccheri A0 B0 B1 A1), not (Lt B0 B1 A1 A0)
+++++
Proof.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A0 B0 B1 A1 : Tpoint) (_ : Saccheri A0 B0 B1 A1), not (Lt B0 B1 A1 A0)
+++++
intros Harchi A0 B0 B1 A1 HSac.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.

*****
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Lt B0 B1 A1 A0)
+++++
intro Hlt.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.

*****
Hlt : Lt B0 B1 A1 A0
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct Hlt as [Hle HNcong].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].

*****
HNcong : not (Cong B0 B1 A1 A0)
Hle : Le B0 B1 A1 A0
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct Hle as [D1 [Hbet Hcong]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].

*****
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].

*****
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].

*****
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).

*****
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
+++++
intros D HG.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.

*****
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.

*****
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).

*****
Hbet5 : Grad A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
apply grad__bet in Hbet5.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.

*****
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].

*****
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A0 A1 A
+++++
Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.

*****
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A0 A1 B0)
+++++
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.

*****
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].

*****
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
assert_diffs; auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.

*****
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A0 B0)
+++++
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.

*****
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
assert(HSac2 : Saccheri A0 B0 B A).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).

*****
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Saccheri A0 B0 B A
+++++
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Per B0 A0 A) (and (Per A0 A B) (and (Cong A0 B0 B A) (OS A0 A B0 B)))
+++++
repeat split; Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B0 A0 A
+++++
-
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B0 A0 A
+++++
apply (per_col _ _ A1); Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.

*****

*****

+++++
-
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A0 A B
+++++
apply perp_per_2; auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A A0 A B
+++++
apply (perp_col1 _ _ _ P); Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A A0 A P
+++++
apply perp_comm; apply (perp_col _ A1); Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.

*****

*****

+++++
-
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A0 A B0 B
+++++
apply invert_one_side.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-
apply invert_one_side.

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A A0 B0 B
+++++
apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-
apply invert_one_side.
apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A A0 B0 P
+++++
apply invert_one_side.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
unfold Saccheri in *; spliter; assert_diffs; assert(A0 <> A) by (intro; treat_equalities; auto).
repeat split; Cong.
-
apply (per_col _ _ A1); Col.
-
apply perp_per_2; auto.
apply (perp_col1 _ _ _ P); Col.
apply perp_comm; apply (perp_col _ A1); Col.
-
apply invert_one_side.
apply (out_out_one_side _ _ _ P); [|apply l6_6; auto].
apply invert_one_side.

*****
H15 : not (eq A0 A)
H21 : not (eq A1 P)
H17 : not (eq A0 P)
H14 : not (eq A0 C0)
H13 : not (eq D1 C0)
H12 : not (eq A0 C)
H11 : not (eq C0 C)
H10 : not (eq B1 A1)
H8 : not (eq A0 B0)
H9 : not (eq B A)
H7 : not (eq B0 A1)
H6 : not (eq A0 B1)
H3 : not (eq A0 A)
H5 : not (eq P A)
H4 : not (eq A0 A1)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
H2 : OS A0 A1 B0 B1
H1 : Cong A0 B0 B1 A1
H0 : Per A0 A1 B1
H : Per B0 A0 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A0 A B0 P
+++++
apply (col_one_side _ A1); Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).

*****
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).

*****
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
assert (HLe2 : Le B0 B A A0).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).

*****
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B A A0
+++++
apply (le_transitivity _ _ B0 E); auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.

*****
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E A A0
+++++
apply (l5_6 A D A A0); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.

*****
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A D A A0
+++++
destruct (l5_12_a A D A0); Between.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.

*****
HLe2 : Le B0 B A A0
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
assert (HLe2' := HLe2).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).

*****
HLe2,HLe2' : Le B0 B A A0
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
destruct HLe2' as [Q [Hbet6 Hcong6]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].

*****
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 D A0 C
+++++
apply (le1234_lt__lt _ _ A0 Q).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).

*****
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 D A0 Q
+++++
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.

*****
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le Q A D A
+++++
apply (l5_6 B0 B B0 E); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.

*****
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HLe : Le B0 B B0 E
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
Hbet4 : Bet A0 D A
Hcong4 : Cong B0 E A D
HG2 : Grad2 A0 A1 A B0 B1 E
A,E : Tpoint
HG : Grad A0 D1 D
D : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
clear dependent D; clear dependent E.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.

*****
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).

*****
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].

*****
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].

*****
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
assert (Le A0 A A0 A').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').

*****
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 A A0 A'
+++++
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 A A0 A'
+++++
apply (le_transitivity _ _ A0 B'').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
apply (le_transitivity _ _ A0 B'').

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 A A0 B''
+++++
apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
apply (le_transitivity _ _ A0 B'').
apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 B'' A0 A'
+++++
apply (bet2_le2__le1346 _ B0' _ _ B0'); Le.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
apply (le_transitivity _ _ A0 B'').
apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.
apply (bet2_le2__le1346 _ B0' _ _ B0'); Le.

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 B0' A'
+++++
apply (outer_transitivity_between _ _ B'); auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
apply (le_transitivity _ _ A0 B'').
apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.
apply (bet2_le2__le1346 _ B0' _ _ B0'); Le.
apply (outer_transitivity_between _ _ B'); auto.

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B0' B')
+++++
intro; treat_equalities; apply sac_distincts in HSac2; spliter; auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
apply (le_transitivity _ _ A0 B'').
apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.
apply (bet2_le2__le1346 _ B0' _ _ B0'); Le.
apply (outer_transitivity_between _ _ B'); auto.
intro; treat_equalities; apply sac_distincts in HSac2; spliter; auto.

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0' B'' B0' A'
+++++
apply (l5_6 B0 A B0' A'); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
destruct (segment_construction A0 B0' B0 A) as [B'' [Hbet9 Hcong9]].
apply (le_transitivity _ _ A0 B'').
apply (triangle_inequality_2 _ B0 _ _ B0'); Cong.
apply (bet2_le2__le1346 _ B0' _ _ B0'); Le.
apply (outer_transitivity_between _ _ B'); auto.
intro; treat_equalities; apply sac_distincts in HSac2; spliter; auto.
apply (l5_6 B0 A B0' A'); Cong.

*****
Hcong9 : Cong B0' B'' B0 A
Hbet9 : Bet A0 B0' B''
B'' : Tpoint
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 A B0' A'
+++++
apply (triangle_inequality_2 _ B _ _ B'); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').

*****
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
assert (HLe3 : Le B0 B A' B0').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').

*****
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 B A' B0'
+++++
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.

*****
HLe3 : Le B0 B A' B0'
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
destruct HLe3 as [Q' [Hbet9 Hcong9]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].

*****
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
assert (HBet10 : Bet A0 B0' A').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').

*****
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 B0' A'
+++++
apply sac_distincts in HSac2; spliter; assert_diffs.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.

*****
H26 : not (eq A1 P)
H24 : not (eq A1 B0)
H22 : not (eq A0 P)
H20 : not (eq P A)
H19 : not (eq A0 A1)
H17 : not (eq A0 A')
H16 : not (eq A0 C0)
H15 : not (eq D1 C0)
H14 : not (eq A0 C)
H13 : not (eq C0 C)
H12 : not (eq A0 B0')
H11 : not (eq A0 B')
H10 : not (eq B0' B')
H9 : not (eq B' A')
H8 : not (eq A Q)
H7 : not (eq A' B0')
H6 : not (eq A' Q')
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 B0' A'
+++++
apply (outer_transitivity_between _ _ B'); Between.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q A0 C
+++++
apply (le1234_lt__lt _ _ A0 Q').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 Q A0 Q'
+++++
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le Q' A' Q A
+++++
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q' A0 C
+++++
assert (Cong B0' Q' A0 B0).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A0 B0
+++++
apply (cong_transitivity _ _ A B); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A B
+++++
apply (cong_transitivity _ _ A' B'); Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.

*****
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).

*****
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
elim(bet_dec B0' Q' B').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').

*****
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B0' Q' B', Cong B0' Q' A' B'
+++++
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.

*****
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Bet B0' Q' B'), Cong B0' Q' A' B'
+++++
intro HNBet.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.

*****
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
apply sac_distincts in HSac2; spliter; assert_diffs.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.

*****
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
assert (Q' <> B0') by (intro; apply HNBet; Between).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).

*****
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
assert (A' <> B0') by (intro; treat_equalities; auto).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).
assert (A' <> B0') by (intro; treat_equalities; auto).

*****
H23 : not (eq A' B0')
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
assert (HOut3 : Out B0' B' Q').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).
assert (A' <> B0') by (intro; treat_equalities; auto).
assert (HOut3 : Out B0' B' Q').

*****
H23 : not (eq A' B0')
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B0' B' Q'
+++++
apply (l6_7 _ _ A'); [| apply l6_6]; apply bet_out; Between.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).
assert (A' <> B0') by (intro; treat_equalities; auto).
assert (HOut3 : Out B0' B' Q').
apply (l6_7 _ _ A'); [| apply l6_6]; apply bet_out; Between.

*****
HOut3 : Out B0' B' Q'
H23 : not (eq A' B0')
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
assert (Hbet11 : Bet B0' B' Q').
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).
assert (A' <> B0') by (intro; treat_equalities; auto).
assert (HOut3 : Out B0' B' Q').
apply (l6_7 _ _ A'); [| apply l6_6]; apply bet_out; Between.
assert (Hbet11 : Bet B0' B' Q').

*****
HOut3 : Out B0' B' Q'
H23 : not (eq A' B0')
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B0' B' Q'
+++++
apply out2__bet; auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).
assert (A' <> B0') by (intro; treat_equalities; auto).
assert (HOut3 : Out B0' B' Q').
apply (l6_7 _ _ A'); [| apply l6_6]; apply bet_out; Between.
assert (Hbet11 : Bet B0' B' Q').
apply out2__bet; auto.

*****
HOut3 : Out B0' B' Q'
H23 : not (eq A' B0')
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q' B0' B'
+++++
apply not_bet_out; Col.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
apply (cong_transitivity _ _ A B); Cong.
apply (cong_transitivity _ _ A' B'); Cong.
assert(Hcong10 : Cong B0' B' A' Q') by (apply (cong_transitivity _ _ B0 B); auto).
elim(bet_dec B0' Q' B').
intro; apply (l4_3 _ _ B' _ _ Q'); Cong; eBetween.
intro HNBet.
apply sac_distincts in HSac2; spliter; assert_diffs.
assert (Q' <> B0') by (intro; apply HNBet; Between).
assert (A' <> B0') by (intro; treat_equalities; auto).
assert (HOut3 : Out B0' B' Q').
apply (l6_7 _ _ A'); [| apply l6_6]; apply bet_out; Between.
assert (Hbet11 : Bet B0' B' Q').
apply out2__bet; auto.
apply not_bet_out; Col.

*****
Hbet11 : Bet B0' B' Q'
HOut3 : Out B0' B' Q'
H23 : not (eq A' B0')
H20 : not (eq Q' B0')
H28 : not (eq A1 P)
H26 : not (eq A1 B0)
H24 : not (eq A0 P)
H22 : not (eq P A)
H21 : not (eq A0 A1)
H19 : not (eq A0 C0)
H18 : not (eq D1 C0)
H17 : not (eq A0 C)
H16 : not (eq C0 C)
H15 : not (eq A0 B0')
H14 : not (eq B' A')
H13 : not (eq A0 B')
H12 : not (eq B0' B')
H11 : not (eq A Q)
H10 : not (eq A' Q')
H9 : not (eq A0 A')
H6 : not (eq A' B0')
H8 : not (eq Q' B')
H7 : not (eq B0' Q')
HNBet : not (Bet B0' Q' B')
Hcong10 : Cong B0' B' A' Q'
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
H5 : not (eq B0 A)
H4 : not (eq A0 B)
H3 : not (eq A0 A)
H2 : not (eq B A)
H1 : not (eq B0 B)
H0 : not (eq A0 B0)
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0' Q' A' B'
+++++
apply (l2_11 _ B' _ _ Q'); Cong; eBetween.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).

*****
H0 : Cong B0' Q' A0 B0
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q' A0 C
+++++
assert (Hbet10 : Bet A0 D1 C) by eBetween.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
assert (Hbet10 : Bet A0 D1 C) by eBetween.

*****
Hbet10 : Bet A0 D1 C
H0 : Cong B0' Q' A0 B0
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A0 Q' A0 C
+++++
apply (cong2_lt__lt D1 C A0 C); Cong; [split|].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
assert (Hbet10 : Bet A0 D1 C) by eBetween.
apply (cong2_lt__lt D1 C A0 C); Cong; [split|].

*****
Hbet10 : Bet A0 D1 C
H0 : Cong B0' Q' A0 B0
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D1 C A0 C
+++++
destruct (l5_12_a A0 D1 C); auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
assert (Hbet10 : Bet A0 D1 C) by eBetween.
apply (cong2_lt__lt D1 C A0 C); Cong; [split|].
destruct (l5_12_a A0 D1 C); auto.

*****
Hbet10 : Bet A0 D1 C
H0 : Cong B0' Q' A0 B0
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong D1 C A0 C)
+++++
intro; assert (D1 = A0) by (apply (between_cong C); Between; Cong); treat_equalities; Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
intros D HG.
destruct (t22_18_aux1 A0 A1 B0 B1 D1 D) as [A [E [HG2 [Hcong4 Hbet4]]]]; Between.
assert (Hbet5 := grad2__grad123 A0 A1 A B0 B1 E HG2).
apply grad__bet in Hbet5.
destruct (l10_15 A0 A1 A B0) as [P [HPerp HOS]].
Col.
assert (H := sac__ncol124 A0 B0 B1 A1); Col.
destruct (l6_11_existence A A0 B0 P) as [B [HOut Hcong5]].
assert_diffs; auto.
assert(Hdiff := sac_distincts A0 B0 B1 A1 HSac); spliter; auto.
assert(HSac2 : Saccheri A0 B0 B A).
assert(HLe : Le B0 B B0 E) by (apply (t22_18_aux2 A0 A1 B0 B1 A); auto).
assert (HLe2 : Le B0 B A A0).
apply (le_transitivity _ _ B0 E); auto.
apply (l5_6 A D A A0); Cong.
destruct (l5_12_a A D A0); Between.
assert (HLe2' := HLe2).
destruct HLe2' as [Q [Hbet6 Hcong6]].
apply (le1234_lt__lt _ _ A0 Q).
apply (bet2_le2__le1245 _ _ A _ _ A); Between; Le.
apply (l5_6 B0 B B0 E); Cong.
clear dependent D; clear dependent E.
destruct (l6_11_existence A0 A0 B0 A) as [B0' [HOut2 Hcong4]]; try (assert_diffs; intro; treat_equalities; auto).
destruct (segment_construction A0 B0' B0 B) as [B' [Hbet7 Hcong7]].
destruct (segment_construction B0' B' B A) as [A' [Hbet8 Hcong8]].
assert (Le A0 A A0 A').
assert (HLe3 : Le B0 B A' B0').
apply (l5_6 B0' B' B0' A'); Cong; destruct (l5_12_a B0' B' A'); auto.
destruct HLe3 as [Q' [Hbet9 Hcong9]].
assert (HBet10 : Bet A0 B0' A').
apply sac_distincts in HSac2; spliter; assert_diffs.
apply (outer_transitivity_between _ _ B'); Between.
apply (le1234_lt__lt _ _ A0 Q').
apply (bet2_le2__le1245 _ _ A' _ _ A); eBetween.
apply cong__le; apply (cong_transitivity _ _ B0 B); Cong.
assert (Cong B0' Q' A0 B0).
assert (Hbet10 : Bet A0 D1 C) by eBetween.
apply (cong2_lt__lt D1 C A0 C); Cong; [split|].
destruct (l5_12_a A0 D1 C); auto.
intro; assert (D1 = A0) by (apply (between_cong C); Between; Cong); treat_equalities; Cong.

*****
Hbet10 : Bet A0 D1 C
H0 : Cong B0' Q' A0 B0
HBet10 : Bet A0 B0' A'
Hcong9 : Cong B0 B A' Q'
Hbet9 : Bet A' Q' B0'
Q' : Tpoint
H : Le A0 A A0 A'
Hcong8 : Cong B' A' B A
Hbet8 : Bet B0' B' A'
A' : Tpoint
Hcong7 : Cong B0' B' B0 B
Hbet7 : Bet A0 B0' B'
B' : Tpoint
Hcong4 : Cong A0 B0' A0 B0
HOut2 : Out A0 B0' A
B0' : Tpoint
Hcong6 : Cong B0 B A Q
Hbet6 : Bet A Q A0
Q : Tpoint
HLe2 : Le B0 B A A0
HSac2 : Saccheri A0 B0 B A
Hcong5 : Cong A B A0 B0
HOut : Out A B P
B : Tpoint
HOS : OS A0 A1 B0 P
HPerp : Perp A0 A1 P A
P : Tpoint
Hbet5 : Bet A0 A1 A
A : Tpoint
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D1 C A0 Q'
+++++
apply (l2_11 _ C0 _ _ B0'); eBetween; apply cong_transitivity with A0 B0; Cong.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).

*****
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold archimedes_axiom in *.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.

*****
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
C : Tpoint
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
D1 : Tpoint
HSac : Saccheri A0 B0 B1 A1
A0,B0,B1,A1 : Tpoint
Harchi : forall (A B C D : Tpoint) (_ : not (eq A B)), Reach A B C D
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
specialize Harchi with A0 D1 A0 C.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.

*****
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
HSac : Saccheri A0 B0 B1 A1
B0,B1,A1 : Tpoint
Harchi : forall _ : not (eq A0 D1), Reach A0 D1 A0 C
A0,D1,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct Harchi as [D [HG Hle]].
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.
destruct Harchi as [D [HG Hle]].

*****
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
HSac : Saccheri A0 B0 B1 A1
A0,D1,C,B0,B1,A1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A0 D1)
+++++
intro; treat_equalities; auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.
destruct Harchi as [D [HG Hle]].
intro; treat_equalities; auto.

*****
Hle : Le A0 C A0 D
HG : Grad A0 D1 D
D : Tpoint
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
HSac : Saccheri A0 B0 B1 A1
A0,D1,C,B0,B1,A1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert(HLt := HG).
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.
destruct Harchi as [D [HG Hle]].
intro; treat_equalities; auto.
assert(HLt := HG).

*****
HLt : Grad A0 D1 D
Hle : Le A0 C A0 D
HG : Grad A0 D1 D
D : Tpoint
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
HSac : Saccheri A0 B0 B1 A1
A0,D1,C,B0,B1,A1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H in HLt.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.
destruct Harchi as [D [HG Hle]].
intro; treat_equalities; auto.
assert(HLt := HG).
apply H in HLt.

*****
HLt : Lt A0 D A0 C
Hle : Le A0 C A0 D
HG : Grad A0 D1 D
D : Tpoint
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
HSac : Saccheri A0 B0 B1 A1
A0,D1,C,B0,B1,A1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply grad__le in HG.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.
destruct Harchi as [D [HG Hle]].
intro; treat_equalities; auto.
assert(HLt := HG).
apply H in HLt.
apply grad__le in HG.

*****
HLt : Lt A0 D A0 C
Hle : Le A0 C A0 D
HG : Le A0 D1 A0 D
D : Tpoint
H : forall (D : Tpoint) (_ : Grad A0 D1 D), Lt A0 D A0 C
Hcong3 : Cong C0 C A0 B0
Hbet3 : Bet A0 C0 C
Hcong2 : Cong D1 C0 A0 B0
Hbet2 : Bet A0 D1 C0
C0 : Tpoint
HNcong : not (Cong B0 B1 A1 A0)
Hcong : Cong B0 B1 A1 D1
Hbet : Bet A1 D1 A0
HSac : Saccheri A0 B0 B1 A1
A0,D1,C,B0,B1,A1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (le__nlt A0 C A0 D); auto.
-----
Lemma t22_18 : archimedes_axiom -> forall A0 B0 B1 A1, Saccheri A0 B0 B1 A1 -> ~ Lt B0 B1 A1 A0.
Proof.
intros Harchi A0 B0 B1 A1 HSac.
intro Hlt.
destruct Hlt as [Hle HNcong].
destruct Hle as [D1 [Hbet Hcong]].
destruct (segment_construction A0 D1 A0 B0) as [C0 [Hbet2 Hcong2]].
destruct (segment_construction A0 C0 A0 B0) as [C [Hbet3 Hcong3]].
assert(H : forall D, Grad A0 D1 D -> Lt A0 D A0 C).
unfold archimedes_axiom in *.
specialize Harchi with A0 D1 A0 C.
destruct Harchi as [D [HG Hle]].
intro; treat_equalities; auto.
assert(HLt := HG).
apply H in HLt.
apply grad__le in HG.
apply (le__nlt A0 C A0 D); auto.

*****

*****

+++++
Qed.
-----
Lemma t22_19 :\n  archimedes_axiom ->\n  forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D : Tpoint) (_ : Saccheri A B C D), not (Obtuse A B C)
+++++
Proof.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D : Tpoint) (_ : Saccheri A B C D), not (Obtuse A B C)
+++++
intros archi A B C D HSac HObt.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.

*****
HObt : Obtuse A B C
HSac : Saccheri A B C D
A,B,C,D : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).

*****
H : not (Lt C B A D)
HObt : Obtuse A B C
HSac : Saccheri A B C D
A,B,C,D : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).
apply H.

*****
H : not (Lt C B A D)
HObt : Obtuse A B C
HSac : Saccheri A B C D
A,B,C,D : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C B A D
+++++
apply lt_left_comm.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).
apply H.
apply lt_left_comm.

*****
H : not (Lt C B A D)
HObt : Obtuse A B C
HSac : Saccheri A B C D
A,B,C,D : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt B C A D
+++++
apply <- lt_sac__obtuse.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).
apply H.
apply lt_left_comm.
apply <- lt_sac__obtuse.

*****
H : not (Lt C B A D)
HObt : Obtuse A B C
HSac : Saccheri A B C D
A,B,C,D : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse A B C
+++++
auto.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).
apply H.
apply lt_left_comm.
apply <- lt_sac__obtuse.

*****
H : not (Lt C B A D)
HObt : Obtuse A B C
HSac : Saccheri A B C D
A,B,C,D : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Saccheri A B C D
+++++
auto.
-----
Lemma t22_19 : archimedes_axiom -> forall A B C D, Saccheri A B C D -> ~ Obtuse A B C.
Proof.
intros archi A B C D HSac HObt.
assert (H := t22_18 archi _ _ _ _ (sac_perm _ _ _ _ HSac)).
apply H.
apply lt_left_comm.
apply <- lt_sac__obtuse.

*****

*****

+++++
Qed.
-----
Lemma archi__obtuse_case_elimination :\n  archimedes_axiom ->\n  ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : archimedes_axiom, not hypothesis_of_obtuse_saccheri_quadrilaterals
+++++
Proof.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : archimedes_axiom, not hypothesis_of_obtuse_saccheri_quadrilaterals
+++++
intros archi obtuse.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.

*****
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct ex_saccheri as [A [B [C [D HSac]]]].
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].

*****
HSac : Saccheri A B C D
A,B,C,D : Tpoint
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
absurd(Obtuse A B C).
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].
absurd(Obtuse A B C).

*****
HSac : Saccheri A B C D
A,B,C,D : Tpoint
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Obtuse A B C)
+++++
apply t22_19 with D.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].
absurd(Obtuse A B C).
apply t22_19 with D.

*****
HSac : Saccheri A B C D
A,B,C,D : Tpoint
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
archimedes_axiom
+++++
trivial.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].
absurd(Obtuse A B C).
apply t22_19 with D.

*****
HSac : Saccheri A B C D
A,B,C,D : Tpoint
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Saccheri A B C D
+++++
trivial.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].
absurd(Obtuse A B C).

*****
HSac : Saccheri A B C D
A,B,C,D : Tpoint
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse A B C
+++++
apply obtuse with D.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].
absurd(Obtuse A B C).
apply obtuse with D.

*****
HSac : Saccheri A B C D
A,B,C,D : Tpoint
obtuse : hypothesis_of_obtuse_saccheri_quadrilaterals
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Saccheri A B C D
+++++
trivial.
-----
Lemma archi__obtuse_case_elimination : archimedes_axiom -> ~ hypothesis_of_obtuse_saccheri_quadrilaterals.
Proof.
intros archi obtuse.
destruct ex_saccheri as [A [B [C [D HSac]]]].
absurd(Obtuse A B C).

*****

*****

+++++
Qed.
-----
Lemma t22_23_aux :\n  forall A B C M N L,\n    ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B ->\n    Per M N A -> Col A C N ->\n    Midpoint M N L -> Bet A N C /\ Lambert N L B C /\ Cong B L A N.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C M N L : Tpoint) (_ : not (Col A M N)) (_ : Per B C A) (_ : not (eq A C)) (_ : Midpoint M A B) (_ : Per M N A) (_ : Col A C N) (_ : Midpoint M N L), and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
Proof.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C M N L : Tpoint) (_ : not (Col A M N)) (_ : Per B C A) (_ : not (eq A C)) (_ : Midpoint M A B) (_ : Per M N A) (_ : Col A C N) (_ : Midpoint M N L), and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.

*****
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
assert_diffs.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
assert (HBet : Bet A N C).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A N C
+++++
apply per23_preserves_bet with M B.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.
Perp.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.
Perp.
Col.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A N)
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A N C
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.
Perp.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A N C
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A N M
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
apply per23_preserves_bet with M B.

*****
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A C B
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
idtac.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A M N B M L
+++++
auto with cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A M N B M L
+++++
apply l11_14.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
apply l11_14.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M B
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
apply l11_14.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A M)
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
apply l11_14.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B M)
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
apply l11_14.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet N M L
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
apply l11_14.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M N)
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
apply l11_14.

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M L)
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M A M B
+++++
auto with cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].

*****
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M N M L
+++++
auto with cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].

*****
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A N)
+++++
auto with cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].

*****
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
auto with cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.

*****
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
assert(B <> L).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).

*****
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B L)
+++++
intro.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
intro.

*****
H : eq B L
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
intro.
treat_equalities.

*****
HCongA1 : CongA M A A M B B
H0 : not (eq A B)
H3 : not (eq M B)
H4 : not (eq A A)
H2 : not (eq A M)
HPerN : Per M A A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M A)
A,B,C,M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
idtac.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Lambert N L B C) (Cong B L A N))
+++++
repeat split.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A N C
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N L)
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq L B)
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
intro.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.

*****
H7 : eq B C
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N B
H6 : not (eq M B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A B N
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B B A
HAC : not (eq A B)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply HNCol.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N B
H6 : not (eq M B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A B N
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B B A
HAC : not (eq A B)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A M N
+++++
ColR.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N C)
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N C)
+++++
intro.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.

*****
H7 : eq N C
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H6.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq M B
+++++
apply (l6_21 A M N M).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A M N)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N M)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A M M
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A M B
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col N M M
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col N M B
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).
Col.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col N M B
+++++
apply col_permutation_3, cop_per2__col with A.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).
Col.
apply col_permutation_3, cop_per2__col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B M N
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).
Col.
apply col_permutation_3, cop_per2__col with A.
Col.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B M N
+++++
Cop.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).
Col.
apply col_permutation_3, cop_per2__col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A N)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).
Col.
apply col_permutation_3, cop_per2__col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B N A
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
intro.
treat_equalities.
apply H6.
apply (l6_21 A M N M).
Col.
apply col_permutation_3, cop_per2__col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HPerN : Per M N A
HM : Midpoint M A B
HPerC : Per B N A
HAC : not (eq A N)
HNCol : not (Col A M N)
A,B,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per M N A
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per L N C
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per L N C
+++++
apply per_col with A.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N A)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per L N A
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.
Col.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per L N A
+++++
apply l8_2, per_col with M.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.
Col.
apply l8_2, per_col with M.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N M)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.
Col.
apply l8_2, per_col with M.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A N M
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.
Col.
apply l8_2, per_col with M.
Col.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A N M
+++++
Perp.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.
Col.
apply l8_2, per_col with M.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col N M L
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply per_col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col N A C
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per N C B
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per N C B
+++++
apply l8_2, per_col with A.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l8_2, per_col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l8_2, per_col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B C A
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l8_2, per_col with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C A N
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per N L B
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per N L B
+++++
apply l11_17 with M N A.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per M N A
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA M N A N L B
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA M N A N L B
+++++
apply (out_conga M N A M L B).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA M N A M L B
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out N M M
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out N M M
+++++
try (apply out_trivial; auto).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out N A A
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out N A A
+++++
try (apply out_trivial; auto).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out L M N
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out L M N
+++++
try (apply out_trivial; auto).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.
try (apply out_trivial; auto).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out L M N
+++++
apply bet_out.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.
try (apply out_trivial; auto).
apply bet_out.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M L)
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.
try (apply out_trivial; auto).
apply bet_out.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet L M N
+++++
Between.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out L B B
+++++
auto.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply l11_17 with M N A.
auto.
apply (out_conga M N A M L B).
auto.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out L B B
+++++
try (apply out_trivial; auto).
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar N L B C
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar N L B C
+++++
apply coplanar_perm_16, col_cop__cop with M.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C N M
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.
Col.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C N M
+++++
apply coplanar_perm_12, col_cop__cop with A.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.
Col.
apply coplanar_perm_12, col_cop__cop with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C N B A
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.
Col.
apply coplanar_perm_12, col_cop__cop with A.
Col.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C N B A
+++++
Cop.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.
Col.
apply coplanar_perm_12, col_cop__cop with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.
Col.
apply coplanar_perm_12, col_cop__cop with A.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A M
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq N M)
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.
Cong.
apply coplanar_perm_16, col_cop__cop with M.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col N M L
+++++
Col.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).
idtac.
destruct (l11_49 A M N B M L) as [HCong1 [HCongA1 HCongA2]].
auto with cong.
assert(B <> L).
idtac.
repeat split.

*****
H : not (eq B L)
HCongA2 : CongA M N A M L B
HCongA1 : CongA M A N M B L
HCong1 : Cong A N B L
HBet : Bet A N C
H6 : not (eq M B)
H5 : not (eq A B)
H3 : not (eq M L)
H0 : not (eq N L)
H4 : not (eq A N)
H1 : not (eq M N)
H2 : not (eq A M)
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B L A N
+++++
Cong.
-----
Lemma t22_23_aux : forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Lambert N L B C /\\ Cong B L A N.
Proof.
intros A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
assert_diffs.
assert (HBet : Bet A N C).

*****

*****

+++++
Qed.
-----
Lemma t22_23 :\n  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->\n  forall A B C M N L,\n    ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B ->\n    Per M N A -> Col A C N -> Midpoint M N L ->\n    Bet A N C /\ Le N C A N /\ Le L N B C.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B C M N L : Tpoint) (_ : not (Col A M N)) (_ : Per B C A) (_ : not (eq A C)) (_ : Midpoint M A B) (_ : Per M N A) (_ : Col A C N) (_ : Midpoint M N L), and (Bet A N C) (and (Le N C A N) (Le L N B C))
+++++
Proof.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B C M N L : Tpoint) (_ : not (Col A M N)) (_ : Per B C A) (_ : not (eq A C)) (_ : Midpoint M A B) (_ : Per M N A) (_ : Col A C N) (_ : Midpoint M N L), and (Bet A N C) (and (Le N C A N) (Le L N B C))
+++++
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.

*****
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Le N C A N) (Le L N B C))
+++++
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.

*****
HCong : Cong B L A N
HLam : Lambert N L B C
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A N C) (and (Le N C A N) (Le L N B C))
+++++
split; auto.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.

*****
HCong : Cong B L A N
HLam : Lambert N L B C
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).

*****
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
HLam : Lambert N L B C
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).

*****
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
HLam : Lambert N L B C
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).

*****
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
HLam : Lambert N L B C
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
unfold Lambert in HLam; spliter.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.

*****
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
H6 : Coplanar N L B C
H5 : Per N L B
H4 : Per N C B
H3 : Per L N C
H2 : not (eq N C)
H1 : not (eq B C)
H0 : not (eq L B)
H : not (eq N L)
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].

*****
HAcute : Acute L B C
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
H6 : Coplanar N L B C
H5 : Per N L B
H4 : Per N C B
H3 : Per L N C
H2 : not (eq N C)
H1 : not (eq B C)
H0 : not (eq L B)
H : not (eq N L)
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
-
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-

*****
HAcute : Acute L B C
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
H6 : Coplanar N L B C
H5 : Per N L B
H4 : Per N C B
H3 : Per L N C
H2 : not (eq N C)
H1 : not (eq B C)
H0 : not (eq L B)
H : not (eq N L)
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-
split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].

*****
HAcute : Acute L B C
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
H6 : Coplanar N L B C
H5 : Per N L B
H4 : Per N C B
H3 : Per L N C
H2 : not (eq N C)
H1 : not (eq B C)
H0 : not (eq L B)
H : not (eq N L)
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt N C B L
+++++
apply lta_os_per2__lt; Perp; Side; apply lta_left_comm, acute_per__lta; auto.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-
split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].
apply lta_os_per2__lt; Perp; Side; apply lta_left_comm, acute_per__lta; auto.

*****
HAcute : Acute L B C
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
H6 : Coplanar N L B C
H5 : Per N L B
H4 : Per N C B
H3 : Per L N C
H2 : not (eq N C)
H1 : not (eq B C)
H0 : not (eq L B)
H : not (eq N L)
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt L N B C
+++++
apply lt_left_comm, lta_os_per2__lt; Side; apply acute_per__lta; auto.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-
split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].
apply lta_os_per2__lt; Perp; Side; apply lta_left_comm, acute_per__lta; auto.
apply lt_left_comm, lta_os_per2__lt; Side; apply acute_per__lta; auto.

*****

*****

+++++
-
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-
split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].
apply lta_os_per2__lt; Perp; Side; apply lta_left_comm, acute_per__lta; auto.
apply lt_left_comm, lta_os_per2__lt; Side; apply acute_per__lta; auto.
-

*****
HPer : Per L B C
Hos2 : OS N C B L
Hos1 : OS N L B C
HLBC : not (Obtuse L B C)
HCong : Cong B L A N
H6 : Coplanar N L B C
H5 : Per N L B
H4 : Per N C B
H3 : Per L N C
H2 : not (eq N C)
H1 : not (eq B C)
H0 : not (eq L B)
H : not (eq N L)
HBet : Bet A N C
HN : Midpoint M N L
HColN : Col A C N
HPerN : Per M N A
HM : Midpoint M A B
HAC : not (eq A C)
HPerC : Per B C A
HNCol : not (Col A M N)
A,B,C,M,N,L : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Le N C A N) (Le L N B C)
+++++
split; apply cong__le; [apply cong_transitivity with B L; trivial | apply cong_left_commutativity]; apply conga_per2_os__cong; Perp; Side; apply l11_16; Perp.
-----
Lemma t22_23 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C M N L, ~ Col A M N -> Per B C A -> A <> C -> Midpoint M A B -> Per M N A -> Col A C N -> Midpoint M N L -> Bet A N C /\\ Le N C A N /\\ Le L N B C.
Proof.
intros HNob A B C M N L HNCol HPerC HAC HM HPerN HColN HN.
destruct (t22_23_aux A B C M N L) as [HBet [HLam HCong]]; auto.
split; auto.
assert (HLBC : ~ Obtuse L B C) by (intro; apply HNob, (lam_obtuse__oah N L B C); trivial).
assert (Hos1 : OS N L B C) by (apply lam__os; trivial).
assert (Hos2 : OS N C B L) by (apply lam__os, lam_perm; trivial).
unfold Lambert in HLam; spliter.
destruct (angle_partition L B C) as [HAcute | [HPer | HObtuse]]; trivial; [ | | exfalso; auto].
-
split; apply lt__le; [apply (cong2_lt__lt N C B L); Cong | ].
apply lta_os_per2__lt; Perp; Side; apply lta_left_comm, acute_per__lta; auto.
apply lt_left_comm, lta_os_per2__lt; Side; apply acute_per__lta; auto.
-
split; apply cong__le; [apply cong_transitivity with B L; trivial | apply cong_left_commutativity]; apply conga_per2_os__cong; Perp; Side; apply l11_16; Perp.

*****

*****

+++++
Qed.
-----
Lemma t22_24_aux :\n  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->\n  forall A B0 B00 C0 B C E,\n    ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 ->\n    GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C ->\n    Le B0 E B C.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B0 B00 C0 B C E : Tpoint) (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) (_ : eq B0 B00) (_ : GradExp2 A B0 B B00 C0 E) (_ : Perp A C0 B C) (_ : Col A C0 C), Le B0 E B C
+++++
Proof.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B0 B00 C0 B C E : Tpoint) (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) (_ : eq B0 B00) (_ : GradExp2 A B0 B B00 C0 E) (_ : Perp A C0 B C) (_ : Col A C0 C), Le B0 E B C
+++++
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.

*****
HGE : GradExp2 A B0 B B00 C0 E
Heq : eq B0 B00
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,B00,C0,B,C,E : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Perp A C0 B C) (_ : Col A C0 C), Le B0 E B C
+++++
revert C.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.

*****
HGE : GradExp2 A B0 B B00 C0 E
Heq : eq B0 B00
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,B00,C0,B,E : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Perp A C0 B C) (_ : Col A C0 C), Le B0 E B C
+++++
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.

*****
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Perp A C0 B0 C) (_ : Col A C0 C), Le B0 C0 B0 C
+++++
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.

*****
H1 : Bet B0 F F'
H2 : Cong B0 F F F'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C1 : Tpoint) (_ : Perp A C0 C C1) \n (_ : Col A C0 C1), Le B0 F C C1
H0 : Cong A C C C'
H : Bet A C C'
HGE : GradExp2 A B0 C B0 C0 F
C,C',F,F' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Perp A C0 C' C) (_ : Col A C0 C), Le B0 F' C' C
+++++
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.

*****
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C : Tpoint) (_ : Perp A C0 B C) \n (_ : Col A C0 C), Le B0 E B C
H0 : Cong A B B B'
H : Bet A B B'
HGE : GradExp2 A B0 B B0 C0 E
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C : Tpoint) (_ : Perp A C0 B' C) (_ : Col A C0 C), Le B0 E' B' C
+++++
intros C' HPerp' HCol'.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.

*****
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C : Tpoint) (_ : Perp A C0 B C) \n (_ : Col A C0 C), Le B0 E B C
H0 : Cong A B B B'
H : Bet A B B'
HGE : GradExp2 A B0 B B0 C0 E
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' B' C'
+++++
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.

*****
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C : Tpoint) (_ : Perp A C0 B C) \n (_ : Col A C0 C), Le B0 E B C
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' B' C'
+++++
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].

*****
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C : Tpoint) (_ : Perp A C0 B C) \n (_ : Col A C0 C), Le B0 E B C
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C0 B)
+++++
intro; assert_diffs; apply HNCol; ColR.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.

*****
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C : Tpoint) (_ : Perp A C0 B C) \n (_ : Col A C0 C), Le B0 E B C
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' B' C'
+++++
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).

*****
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) \n (_ : eq B0 B0) (C : Tpoint) (_ : Perp A C0 B C) \n (_ : Col A C0 C), Le B0 E B C
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' B' C'
+++++
clear IHHGE.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.

*****
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' B' C'
+++++
destruct (symmetric_point_construction C B) as [D HD].
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].

*****
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' B' C'
+++++
apply le_transitivity with D C.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.

*****
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E' D C
+++++
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.

*****
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D C B' C'
+++++
assert (HAC : A <> C).
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).

*****
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro; subst C; assert_diffs; assert (A = C0); auto.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
intro; subst C; assert_diffs; assert (A = C0); auto.

*****
H13 : not (eq B' C')
H11 : not (eq B D)
H10 : not (eq A D)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HD : Midpoint B A D
D : Tpoint
HCol : Col A C0 A
HPerp : Perp A C0 B A
HLe : Le B0 E B A
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A C0
+++++
apply (l8_18_uniqueness A C0 B0); Col.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
intro; subst C; assert_diffs; assert (A = C0); auto.
apply (l8_18_uniqueness A C0 B0); Col.

*****
H13 : not (eq B' C')
H11 : not (eq B D)
H10 : not (eq A D)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HD : Midpoint B A D
D : Tpoint
HCol : Col A C0 A
HPerp : Perp A C0 B A
HLe : Le B0 E B A
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B0 A
+++++
apply perp_right_comm, perp_col1 with B; Perp; Col.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).

*****
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D C B' C'
+++++
assert (HAC' : A <> C').
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').

*****
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C')
+++++
intro; subst C'; assert_diffs; assert (A = C0); auto.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
intro; subst C'; assert_diffs; assert (A = C0); auto.

*****
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HPerp' : Perp A C0 B' A
HCol' : Col A C0 A
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A C0
+++++
apply (l8_18_uniqueness A C0 B0); Col.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
intro; subst C'; assert_diffs; assert (A = C0); auto.
apply (l8_18_uniqueness A C0 B0); Col.

*****
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HPerp' : Perp A C0 B' A
HCol' : Col A C0 A
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B0 A
+++++
apply perp_right_comm, perp_col1 with B'; Perp; ColR.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').

*****
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D C B' C'
+++++
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).

*****
HPer : Per A C B
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D C B' C'
+++++
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.

*****
H14 : not (eq B' C')
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HPer : Per A C B
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
-
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-

*****
H14 : not (eq B' C')
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HPer : Per A C B
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
apply per_not_col in HPer; Col.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.

*****

*****

+++++
-
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.
-

*****
H14 : not (eq B' C')
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HPer : Per A C B
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per B' C' A
+++++
apply perp_per_1; auto; apply perp_col1 with C0; Perp.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.
-
apply perp_per_1; auto; apply perp_col1 with C0; Perp.

*****

*****

+++++
-
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.
-
apply perp_per_1; auto; apply perp_col1 with C0; Perp.
-

*****
H14 : not (eq B' C')
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HPer : Per A C B
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint B A B'
+++++
split; auto.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.
-
apply perp_per_1; auto; apply perp_col1 with C0; Perp.
-
split; auto.

*****

*****

+++++
-
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.
-
apply perp_per_1; auto; apply perp_col1 with C0; Perp.
-
split; auto.
-

*****
H14 : not (eq B' C')
H12 : not (eq B D)
H10 : not (eq C D)
H11 : not (eq B C)
H7 : not (eq B B')
H4 : not (eq A B')
H3 : not (eq A B)
H8 : not (eq A C0)
H5 : not (eq B0 C0)
H6 : not (eq A B0)
HPer : Per A C B
HAC' : not (eq A C')
HAC : not (eq A C)
HD : Midpoint B C D
D : Tpoint
HLe : Le B0 E B C
HPerp : Perp A C0 B C
HCol : Col A C0 C
C : Tpoint
HCol' : Col A C0 C'
HPerp' : Perp A C0 B' C'
C' : Tpoint
H1 : Bet B0 E E'
H2 : Cong B0 E E E'
H0 : Cong A B B B'
H : Bet A B B'
HGE : Bet A B0 B
B,B',E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
HNob : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C' C
+++++
ColR.
-----
Lemma t22_24_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B0 B00 C0 B C E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> B0 = B00 -> GradExp2 A B0 B B00 C0 E -> Perp A C0 B C -> Col A C0 C -> Le B0 E B C.
Proof.
intros HNob A B0 B00 C0 B C E HNCol HPerp0 Heq HGE.
revert C.
induction HGE; rename B into B0; rename D into B00; rename E into C0; subst B00.
intros C HPerp HCol; assert (C = C0) by (apply (l8_18_uniqueness A C0 B0); Col); subst C; Le.
rename C into B; rename C' into B'; rename F into E; rename F' into E'.
intros C' HPerp' HCol'.
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE.
destruct (l8_18_existence A C0 B) as [C [HCol HPerp]].
intro; assert_diffs; apply HNCol; ColR.
assert (HLe : Le B0 E B C) by (apply IHHGE; trivial).
clear IHHGE.
destruct (symmetric_point_construction C B) as [D HD].
apply le_transitivity with D C.
apply bet2_le2__le1346 with E B; Between; apply (l5_6 B0 E B C); auto with cong.
assert (HAC : A <> C).
assert (HAC' : A <> C').
assert (HPer : Per A C B) by (apply perp_per_1; auto; apply perp_left_comm, perp_col with C0; trivial).
destruct (t22_23 HNob A B' C' B C D) as [_ []]; Perp; assert_diffs.
-
apply per_not_col in HPer; Col.
-
apply perp_per_1; auto; apply perp_col1 with C0; Perp.
-
split; auto.
-
ColR.

*****

*****

+++++
Qed.
-----
Lemma t22_24_aux1 : forall A B0 C0 E,\n  ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E ->\n  exists B C, GradExp2 A B0 B B0 C0 E /\ Perp A C0 B C /\ Col A C0 C.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B0 C0 E : Tpoint) (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) (_ : GradExp B0 C0 E), ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E) (and (Perp A C0 B C) (Col A C0 C))))
+++++
Proof.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B0 C0 E : Tpoint) (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0) (_ : GradExp B0 C0 E), ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E) (and (Perp A C0 B C) (Col A C0 C))))
+++++
intros A B0 C0 E HNCol HPerp0 HGE.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.

*****
HGE : GradExp B0 C0 E
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E) (and (Perp A C0 B C) (Col A C0 C))))
+++++
induction HGE.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.

*****
HPerp0 : Perp A B A0 B
HNCol : not (Col A A0 B)
A,A0,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B0 : Tpoint => ex (fun C : Tpoint => and (GradExp2 A A0 B0 A0 B B) (and (Perp A B B0 C) (Col A B C))))
+++++
rename A0 into B0.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.

*****
HPerp0 : Perp A B B0 B
HNCol : not (Col A B0 B)
A,B0,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B1 : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B1 B0 B B) (and (Perp A B B1 C) (Col A B C))))
+++++
rename B into C0.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.

*****
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 C0) (and (Perp A C0 B C) (Col A C0 C))))
+++++
exists B0.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
exists B0.

*****
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp2 A B0 B0 B0 C0 C0) (and (Perp A C0 B0 C) (Col A C0 C)))
+++++
exists C0.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
exists B0.
exists C0.

*****
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp2 A B0 B0 B0 C0 C0) (and (Perp A C0 B0 C0) (Col A C0 C0))
+++++
repeat (split; Col).
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
exists B0.
exists C0.
repeat (split; Col).

*****
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp2 A B0 B0 B0 C0 C0
+++++
apply gradexp2_init.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.

*****
IHHGE : forall (_ : not (Col A A0 B)) (_ : Perp A B A0 B),\nex\n (fun B0 : Tpoint =>\n ex\n (fun C0 : Tpoint =>\n and (GradExp2 A A0 B0 A0 B C) (and (Perp A B B0 C0) (Col A B C0))))
H0 : Cong A0 C C C'
H : Bet A0 C C'
HGE : GradExp A0 B C
C,C' : Tpoint
HPerp0 : Perp A B A0 B
HNCol : not (Col A A0 B)
A,A0,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B0 : Tpoint => ex (fun C : Tpoint => and (GradExp2 A A0 B0 A0 B C') (and (Perp A B B0 C) (Col A B C))))
+++++
rename A0 into B0.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.

*****
IHHGE : forall (_ : not (Col A B0 B)) (_ : Perp A B B0 B),\nex\n (fun B1 : Tpoint =>\n ex\n (fun C0 : Tpoint =>\n and (GradExp2 A B0 B1 B0 B C) (and (Perp A B B1 C0) (Col A B C0))))
H0 : Cong B0 C C C'
H : Bet B0 C C'
HGE : GradExp B0 B C
C,C' : Tpoint
HPerp0 : Perp A B B0 B
HNCol : not (Col A B0 B)
A,B0,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B1 : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B1 B0 B C') (and (Perp A B B1 C) (Col A B C))))
+++++
rename B into C0.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.

*****
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0),\nex\n (fun B : Tpoint =>\n ex\n (fun C1 : Tpoint =>\n and (GradExp2 A B0 B B0 C0 C)\n (and (Perp A C0 B C1) (Col A C0 C1))))
H0 : Cong B0 C C C'
H : Bet B0 C C'
HGE : GradExp B0 C0 C
C,C' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 C') (and (Perp A C0 B C) (Col A C0 C))))
+++++
rename C into E.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.

*****
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0),\nex\n (fun B : Tpoint =>\n ex\n (fun C : Tpoint =>\n and (GradExp2 A B0 B B0 C0 E) (and (Perp A C0 B C) (Col A C0 C))))
H0 : Cong B0 E E C'
H : Bet B0 E C'
HGE : GradExp B0 C0 E
E,C' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 C') (and (Perp A C0 B C) (Col A C0 C))))
+++++
rename C' into E'.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.

*****
IHHGE : forall (_ : not (Col A B0 C0)) (_ : Perp A C0 B0 C0),\nex\n (fun B : Tpoint =>\n ex\n (fun C : Tpoint =>\n and (GradExp2 A B0 B B0 C0 E) (and (Perp A C0 B C) (Col A C0 C))))
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E') (and (Perp A C0 B C) (Col A C0 C))))
+++++
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].

*****
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B0 C0)
+++++
trivial.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].

*****
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B0 C0
+++++
trivial.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].

*****
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E') (and (Perp A C0 B C) (Col A C0 C))))
+++++
trivial.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.

*****
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E') (and (Perp A C0 B C) (Col A C0 C))))
+++++
destruct (segment_construction A B A B) as [B' [HBet HCong]].
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].

*****
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B : Tpoint => ex (fun C : Tpoint => and (GradExp2 A B0 B B0 C0 E') (and (Perp A C0 B C) (Col A C0 C))))
+++++
exists B'.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.

*****
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp2 A B0 B' B0 C0 E') (and (Perp A C0 B' C) (Col A C0 C)))
+++++
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].

*****
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C0 B')
+++++
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.

*****
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C0 B')
+++++
intro.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
intro.

*****
H1 : Col A C0 B'
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
intro.
assert_diffs.

*****
H10 : not (eq B C)
H6 : not (eq B B')
H3 : not (eq A B')
H2 : not (eq A B)
H7 : not (eq A C0)
H4 : not (eq B0 C0)
H5 : not (eq A B0)
H1 : Col A C0 B'
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
intro.
assert_diffs.
apply HNCol.

*****
H10 : not (eq B C)
H6 : not (eq B B')
H3 : not (eq A B')
H2 : not (eq A B)
H7 : not (eq A C0)
H4 : not (eq B0 C0)
H5 : not (eq A B0)
H1 : Col A C0 B'
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B0 C0
+++++
ColR.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C : Tpoint => and (GradExp2 A B0 B' B0 C0 E') (and (Perp A C0 B' C) (Col A C0 C)))
+++++
exists C'.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradExp2 A B0 B' B0 C0 E') (and (Perp A C0 B' C') (Col A C0 C'))
+++++
repeat (split; trivial).
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.
repeat (split; trivial).

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp2 A B0 B' B0 C0 E'
+++++
apply gradexp2_stab with B E.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.
repeat (split; trivial).
apply gradexp2_stab with B E.

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp2 A B0 B B0 C0 E
+++++
Cong.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.
repeat (split; trivial).
apply gradexp2_stab with B E.

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B B'
+++++
Cong.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.
repeat (split; trivial).
apply gradexp2_stab with B E.

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B B B'
+++++
Cong.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.
repeat (split; trivial).
apply gradexp2_stab with B E.

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B0 E E'
+++++
Cong.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.
rename A0 into B0.
rename B into C0.
rename C into E.
rename C' into E'.
destruct IHHGE as [B [C [HGE2 [HPerp HCol]]]].
trivial.
destruct (segment_construction A B A B) as [B' [HBet HCong]].
exists B'.
destruct (l8_18_existence A C0 B') as [C' [HCol' HPerp']].
exists C'.
repeat (split; trivial).
apply gradexp2_stab with B E.

*****
HPerp' : Perp A C0 B' C'
HCol' : Col A C0 C'
C' : Tpoint
HCong : Cong B B' A B
HBet : Bet A B B'
B' : Tpoint
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
H0 : Cong B0 E E E'
H : Bet B0 E E'
HGE : GradExp B0 C0 E
E,E' : Tpoint
HPerp0 : Perp A C0 B0 C0
HNCol : not (Col A B0 C0)
A,B0,C0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B0 E E E'
+++++
Cong.
-----
Lemma t22_24_aux1 : forall A B0 C0 E, ~ Col A B0 C0 -> Perp A C0 B0 C0 -> GradExp B0 C0 E -> exists B C, GradExp2 A B0 B B0 C0 E /\\ Perp A C0 B C /\\ Col A C0 C.
Proof.
intros A B0 C0 E HNCol HPerp0 HGE.
induction HGE.

*****

*****

+++++
Qed.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : archimedes_axiom, aristotle_s_axiom
+++++
Proof.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : archimedes_axiom, aristotle_s_axiom
+++++
intros Harchi P Q D A B0 HNCol HACute0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.

*****
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].

*****
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A D B0)
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].

*****
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.

*****
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
assert (HAC0 : A <> C0).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).

*****
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C0)
+++++
intro.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
intro.

*****
H : eq A C0
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst C0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
intro.
subst C0.

*****
HColD : Col A D A
HPerpD : Perp A D B0 A
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (acute_not_per D A B0).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
intro.
subst C0.
apply (acute_not_per D A B0).

*****
HColD : Col A D A
HPerpD : Perp A D B0 A
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D A B0
+++++
Perp.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
intro.
subst C0.
apply (acute_not_per D A B0).

*****
HColD : Col A D A
HPerpD : Perp A D B0 A
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per D A B0
+++++
Perp.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).

*****
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
idtac.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.

*****
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
assert (HNCol0 : ~ Col A B0 C0).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).

*****
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B0 C0)
+++++
intro.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
intro.

*****
H : Col A B0 C0
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
intro.
apply HNCol.

*****
H : Col A B0 C0
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D A B0
+++++
ColR.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).

*****
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
idtac.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.

*****
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
elim (eq_dec_points P Q).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq P Q, ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
intro HPQ.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.

*****
HPQ : eq P Q
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
subst Q.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P P X Y)))))
+++++
exists C0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out A D C0) (and (Out A B0 Y) (and (Per A C0 Y) (Lt P P C0 Y))))
+++++
exists B0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A D C0) (and (Out A B0 B0) (and (Per A C0 B0) (Lt P P C0 B0)))
+++++
split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D C0
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D C0
+++++
apply l6_6, acute_col_perp__out with B0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B0.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute B0 A D
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B0.
trivial.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute B0 A D
+++++
apply acute_sym.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B0.
trivial.
apply acute_sym.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D A B0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B0.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A D C0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B0.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A D B0 C0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A B0 B0) (and (Per A C0 B0) (Lt P P C0 B0))
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A B0 B0) (and (Per A C0 B0) (Lt P P C0 B0))
+++++
split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B0
+++++
apply out_trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
apply out_trivial.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B0 A)
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Per A C0 B0) (Lt P P C0 B0)
+++++
repeat split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A C0 B0
+++++
Perp.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le P P C0 B0
+++++
Perp.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.
Perp.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le P P C0 B0
+++++
Le.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong P P C0 B0)
+++++
Perp.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.
Perp.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong P P C0 B0)
+++++
Le.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.
Perp.
Le.

*****
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong P P C0 B0)
+++++
intro.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.
Perp.
Le.
intro.

*****
H : Cong P P C0 B0
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
subst Q.
exists C0.
exists B0.
split.
assert_diffs.
split.
repeat split.
Perp.
Le.
intro.
treat_equalities.

*****
H6 : not (eq D C0)
H4 : not (eq D A)
HNCol0 : not (Col A C0 C0)
HPerp0 : Perp A C0 C0 C0
H1 : not (eq C0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D C0 C0
HColD : Col A D C0
HNCol : not (Col D A C0)
HACute0 : Acute D A C0
D,A,C0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).

*****
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq P Q), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
intro HPQ.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.

*****
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].

*****
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].

*****
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reach B0 C0 P Q'
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
assert_diffs.

*****
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reach B0 C0 P Q'
+++++
apply Harchi.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
assert_diffs.
apply Harchi.

*****
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B0 C0)
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].

*****
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].

*****
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B0 C0)
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].

*****
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B0 C0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].

*****
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp B0 C0 E
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].

*****
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.

*****
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
assert(HOut : Out A B0 B).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).

*****
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B
+++++
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.

*****
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
assert_diffs.

*****
H9 : not (eq B C)
H5 : not (eq B0 E)
H3 : not (eq Q Q')
H0 : not (eq P Q')
H : not (eq A B)
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B
+++++
apply bet_out.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
assert_diffs.
apply bet_out.

*****
H9 : not (eq B C)
H5 : not (eq B0 E)
H3 : not (eq Q Q')
H0 : not (eq P Q')
H : not (eq A B)
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B0 A)
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
apply gradexp2__gradexp123, gradexp__grad, grad__bet in HGE2.
assert_diffs.
apply bet_out.

*****
H9 : not (eq B C)
H5 : not (eq B0 E)
H3 : not (eq Q Q')
H0 : not (eq P Q')
H : not (eq A B)
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : Bet A B0 B
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B0 B
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).

*****
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
assert(HAcute : Acute D A B).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).

*****
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D A B
+++++
apply (acute_conga__acute D A B0).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).

*****
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D A B0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).

*****
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D A B0 D A B
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.

*****
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D A B0 D A B
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D A B0 D A B
+++++
apply (out_conga D A B0 D A B0).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D A B0 D A B0
+++++
CongA.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D D
+++++
CongA.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).
CongA.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D D
+++++
apply out_trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).
CongA.
apply out_trivial.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D A)
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B0
+++++
CongA.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).
CongA.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B0
+++++
apply out_trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).
CongA.
apply out_trivial.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B0 A)
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D D
+++++
CongA.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).
CongA.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D D
+++++
apply out_trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).
CongA.
apply out_trivial.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D A)
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
apply (acute_conga__acute D A B0).
trivial.
assert_diffs.
apply (out_conga D A B0 D A B0).

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B
+++++
CongA.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).

*****
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
assert (HAC : A <> C).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).

*****
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.

*****
H : eq A C
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst C.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.

*****
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (acute_not_per D A B).
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D A B
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per D A B
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).
trivial.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per D A B
+++++
apply perp_per_1.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).
trivial.
apply perp_per_1.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A D B A
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).
trivial.
apply perp_per_1.
auto.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A D B A
+++++
apply perp_col with C0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).
trivial.
apply perp_per_1.
auto.
apply perp_col with C0.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).
trivial.
apply perp_per_1.
auto.
apply perp_col with C0.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B A
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
intro.
subst C.
assert_diffs.
apply (acute_not_per D A B).
trivial.
apply perp_per_1.
auto.
apply perp_col with C0.

*****
H8 : not (eq B A)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAcute : Acute D A B
HOut : Out A B0 B
HPerp : Perp A C0 B A
HCol : Col A C0 A
HGE2 : GradExp2 A B0 B B0 C0 E
B : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C0 D
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A D X) (and (Out A B0 Y) (and (Per A X Y) (Lt P Q X Y)))))
+++++
exists C.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Out A D C) (and (Out A B0 Y) (and (Per A C Y) (Lt P Q C Y))))
+++++
exists B.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A D C) (and (Out A B0 B) (and (Per A C B) (Lt P Q C B)))
+++++
split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D C
+++++
assert_diffs.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D C
+++++
apply l6_6, acute_col_perp__out with B.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute B A D
+++++
apply acute_sym.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.
apply acute_sym.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D A B
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A D C
+++++
ColR.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A D B C
+++++
apply perp_col with C0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.
apply perp_col with C0.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.
apply perp_col with C0.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B C
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
assert_diffs.
apply l6_6, acute_col_perp__out with B.
apply perp_col with C0.

*****
H9 : not (eq B A)
H8 : not (eq B C)
H3 : not (eq B0 E)
H0 : not (eq Q Q')
H : not (eq P Q')
H6 : not (eq D B0)
H4 : not (eq D A)
H1 : not (eq B0 C0)
H2 : not (eq A B0)
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C0 D
+++++
Col.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A B0 B) (and (Per A C B) (Lt P Q C B))
+++++
split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B0 B
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Per A C B) (Lt P Q C B)
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Per A C B) (Lt P Q C B)
+++++
split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A C B
+++++
apply perp_per_1.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply perp_per_1.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp C A B C
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply perp_per_1.
auto.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp C A B C
+++++
apply perp_left_comm, perp_col with C0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B C
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C0 C
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt P Q C B
+++++
apply le3456_lt__lt with P Q'.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt P Q P Q'
+++++
split.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le P Q P Q'
+++++
apply bet__le1213.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
apply bet__le1213.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q Q'
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong P Q P Q')
+++++
intro.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.

*****
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Q = Q').
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').

*****
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq Q Q'
+++++
treat_equalities.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').
treat_equalities.

*****
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq Q Q'
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').
treat_equalities.
auto.

*****
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq Q Q'
+++++
apply between_cong with P.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').
treat_equalities.
auto.
apply between_cong with P.

*****
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q Q'
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').
treat_equalities.
auto.
apply between_cong with P.

*****
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P Q P Q'
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').

*****
H0 : eq Q Q'
H : Cong P Q P Q'
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
split.
intro.
assert (Q = Q').
treat_equalities.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P P B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HPQ : not (eq P P)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le P Q' C B
+++++
apply le_transitivity with B0 E.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le P Q' B0 E
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E C B
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E C B
+++++
apply le_right_comm.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B0 E B C
+++++
apply t22_24_aux with A B0 C0.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not hypothesis_of_obtuse_saccheri_quadrilaterals
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.
trivial.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not hypothesis_of_obtuse_saccheri_quadrilaterals
+++++
apply archi__obtuse_case_elimination.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.
trivial.
apply archi__obtuse_case_elimination.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
archimedes_axiom
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B0 C0)
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B0 C0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq B0 B0
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradExp2 A B0 B B0 C0 E
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C0 B C
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].
Col.
assert (HAC0 : A <> C0).
idtac.
assert (HNCol0 : ~ Col A B0 C0).
idtac.
assert (HPerp0 := perp_col A D B0 C0 C0 HAC0 HPerpD HColD).
elim (eq_dec_points P Q).
intro HPQ.
destruct (segment_construction P Q P Q) as [Q' [HBetQ HCongQ]].
destruct (reach__ex_gradexp_le B0 C0 P Q') as [E [HGE HLe]].
destruct (t22_24_aux1 A B0 C0 E) as [B [C [HGE2 [HPerp HCol]]]].
trivial.
assert(HOut : Out A B0 B).
assert(HAcute : Acute D A B).
assert (HAC : A <> C).
exists C.
exists B.
split.
split.
trivial.
split.
apply le3456_lt__lt with P Q'.
apply le_transitivity with B0 E.
trivial.
apply le_right_comm.
apply t22_24_aux with A B0 C0.

*****
HAC : not (eq A C)
HAcute : Acute D A B
HOut : Out A B0 B
HCol : Col A C0 C
HPerp : Perp A C0 B C
HGE2 : GradExp2 A B0 B B0 C0 E
B,C : Tpoint
HLe : Le P Q' B0 E
HGE : GradExp B0 C0 E
E : Tpoint
HCongQ : Cong Q Q' P Q
HBetQ : Bet P Q Q'
Q' : Tpoint
HPQ : not (eq P Q)
HPerp0 : Perp A C0 B0 C0
HNCol0 : not (Col A B0 C0)
HAC0 : not (eq A C0)
HPerpD : Perp A D B0 C0
HColD : Col A D C0
C0 : Tpoint
HACute0 : Acute D A B0
HNCol : not (Col D A B0)
P,Q,D,A,B0 : Tpoint
Harchi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C0 C
+++++
trivial.
-----
Lemma t22_24 : archimedes_axiom -> aristotle_s_axiom.
Proof.
intros Harchi P Q D A B0 HNCol HACute0.
destruct (l8_18_existence A D B0) as [C0 [HColD HPerpD]].

*****

*****

+++++
Qed.
-----
End Archimedes.
-----
