Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Require Import GeoCoq.Axioms.euclidean_axioms.
-----
Require Export GeoCoq.Axioms.continuity_axioms.
-----
Require Export GeoCoq.Meta_theory.Continuity.elementary_continuity_props.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates.
-----
Section Tarski_neutral_to_Euclid_neutral.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Definition Tcircle : Type := Tpoint*Tpoint*Tpoint %type.
-----
Definition OnCirc P (C:Tcircle) := \n  match C with \n  (X,A,B) => tarski_axioms.Cong X P A B\n  end.
-----
Definition CI (J:Tcircle) A C D := J=(A,C,D) /\ C<>D.
-----
Definition InCirc P (J:Tcircle) :=\n   match J with\n  (C,A,B) => \n   exists X Y, Definitions.BetS X C Y /\ tarski_axioms.Cong C Y A B /\\n               tarski_axioms.Cong C X A B /\ Definitions.BetS X P Y\n  end.
-----
Definition OutCirc P (J:Tcircle) :=\n   match J with\n  (C,A,B) => \n      exists X, Definitions.BetS C X P /\ tarski_axioms.Cong C X A B\n end.
-----
Lemma on : \n forall A B C D J, CI J A C D /\ OnCirc B J ->\n                   tarski_axioms.Cong A B C D.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (J : Tcircle) (_ : and (CI J A C D) (OnCirc B J)), tarski_axioms.Cong A B C D
+++++
Proof.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (J : Tcircle) (_ : and (CI J A C D) (OnCirc B J)), tarski_axioms.Cong A B C D
+++++
intros.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.

*****
H : and (CI J A C D) (OnCirc B J)
J : Tcircle
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A B C D
+++++
unfold CI in *.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.
unfold CI in *.

*****
H : and (and (Logic.eq J (pair (pair A C) D)) (not (Logic.eq C D)))\n (OnCirc B J)
J : Tcircle
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A B C D
+++++
unfold OnCirc in *.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.
unfold CI in *.
unfold OnCirc in *.

*****
H : and (and (Logic.eq J (pair (pair A C) D)) (not (Logic.eq C D)))\n (let (p, B0) := J in let (X, A) := p in tarski_axioms.Cong X B A B0)
J : Tcircle
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A B C D
+++++
destruct J.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.
unfold CI in *.
unfold OnCirc in *.
destruct J.

*****
H : and\n (and (Logic.eq (pair p t) (pair (pair A C) D)) (not (Logic.eq C D)))\n (let (X, A) := p in tarski_axioms.Cong X B A t)
t : Tpoint
p : prod Tpoint Tpoint
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A B C D
+++++
destruct p.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.
unfold CI in *.
unfold OnCirc in *.
destruct J.
destruct p.

*****
H : and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair A C) D))\n (not (Logic.eq C D))) (tarski_axioms.Cong t0 B t1 t)
A,B,C,D,t0,t1,t : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A B C D
+++++
spliter.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.
unfold CI in *.
unfold OnCirc in *.
destruct J.
destruct p.
spliter.

*****
H0 : tarski_axioms.Cong t0 B t1 t
H1 : not (Logic.eq C D)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair A C) D)
A,B,C,D,t0,t1,t : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A B C D
+++++
congruence.
-----
Lemma on : forall A B C D J, CI J A C D /\\ OnCirc B J -> tarski_axioms.Cong A B C D.
Proof.
intros.
unfold CI in *.
unfold OnCirc in *.
destruct J.
destruct p.
spliter.
congruence.

*****

*****

+++++
Qed.
-----
Lemma inside : forall A B C J P,\n  CI J C A B /\ InCirc P J <-> \n  exists X Y, CI J C A B /\ \n   Definitions.BetS X C Y /\ \n   tarski_axioms.Cong C Y A B /\ \n   tarski_axioms.Cong C X A B /\ \n   Definitions.BetS X P Y.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (J : Tcircle) (P : Tpoint), iff (and (CI J C A B) (InCirc P J)) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (CI J C A B) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
Proof.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (J : Tcircle) (P : Tpoint), iff (and (CI J C A B) (InCirc P J)) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (CI J C A B) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
intros.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.

*****
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (CI J C A B) (InCirc P J)) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (CI J C A B) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
unfold InCirc.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.

*****
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (CI J C A B) (let (p, B) := J in let (C, A) := p in ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (CI J C A B) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
unfold CI.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.

*****
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (and (Logic.eq J (pair (pair C A) B)) (not (Logic.eq A B))) (let (p, B) := J in let (C, A) := p in ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq J (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
destruct J.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.

*****
t,P : Tpoint
p : prod Tpoint Tpoint
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (and (Logic.eq (pair p t) (pair (pair C A) B)) (not (Logic.eq A B))) (let (C, A) := p in ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A t) (and (tarski_axioms.Cong C X A t) (Definitions.BetS X P Y))))))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair p t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
destruct p.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.

*****
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X t0 Y) (and (tarski_axioms.Cong t0 Y t1 t) (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y))))))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))))
+++++
split.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.

*****
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X t0 Y) (and (tarski_axioms.Cong t0 Y t1 t) (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y)))))), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
intros.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.

*****
H : and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B))\n (not (Logic.eq A B)))\n (ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t0 Y)\n (and (tarski_axioms.Cong t0 Y t1 t)\n (and (tarski_axioms.Cong t0 X t1 t)\n (Definitions.BetS X P Y))))))
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
spliter.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.

*****
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t0 Y)\n (and (tarski_axioms.Cong t0 Y t1 t)\n (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y)))))
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
decompose [ex and] H0.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong t0 x t1 t
H3 : tarski_axioms.Cong t0 x0 t1 t
H2 : Definitions.BetS x t0 x0
x,x0 : Tpoint
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t0 Y)\n (and (tarski_axioms.Cong t0 Y t1 t)\n (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y)))))
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
clear H0.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong t0 x t1 t
H3 : tarski_axioms.Cong t0 x0 t1 t
H2 : Definitions.BetS x t0 x0
x,x0 : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
exists x.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong t0 x t1 t
H3 : tarski_axioms.Cong t0 x0 t1 t
H2 : Definitions.BetS x t0 x0
x,x0 : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS x C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C x A B) (Definitions.BetS x P Y)))))
+++++
exists x0.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.
exists x0.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong t0 x t1 t
H3 : tarski_axioms.Cong t0 x0 t1 t
H2 : Definitions.BetS x t0 x0
x,x0 : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS x C x0) (and (tarski_axioms.Cong C x0 A B) (and (tarski_axioms.Cong C x A B) (Definitions.BetS x P x0))))
+++++
inversion H.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.
exists x0.
inversion H.

*****
H8 : Logic.eq t B
H7 : Logic.eq t1 A
H5 : Logic.eq t0 C
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong t0 x t1 t
H3 : tarski_axioms.Cong t0 x0 t1 t
H2 : Definitions.BetS x t0 x0
x,x0 : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS x C x0) (and (tarski_axioms.Cong C x0 A B) (and (tarski_axioms.Cong C x A B) (Definitions.BetS x P x0))))
+++++
subst.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.
exists x0.
inversion H.
subst.

*****
H6 : Definitions.BetS x P x0
H2 : Definitions.BetS x C x0
H3 : tarski_axioms.Cong C x0 A B
H4 : tarski_axioms.Cong C x A B
x,x0 : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS x C x0) (and (tarski_axioms.Cong C x0 A B) (and (tarski_axioms.Cong C x A B) (Definitions.BetS x P x0))))
+++++
auto.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.

*****
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))), and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X t0 Y) (and (tarski_axioms.Cong t0 Y t1 t) (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y))))))
+++++
intros.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.

*****
H : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B))\n (not (Logic.eq A B)))\n (and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y A B)\n (and (tarski_axioms.Cong C X A B)\n (Definitions.BetS X P Y))))))
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X t0 Y) (and (tarski_axioms.Cong t0 Y t1 t) (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y))))))
+++++
decompose [ex and] H.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
x,x0 : Tpoint
H : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B))\n (not (Logic.eq A B)))\n (and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y A B)\n (and (tarski_axioms.Cong C X A B)\n (Definitions.BetS X P Y))))))
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X t0 Y) (and (tarski_axioms.Cong t0 Y t1 t) (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y))))))
+++++
clear H.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X t0 Y) (and (tarski_axioms.Cong t0 Y t1 t) (and (tarski_axioms.Cong t0 X t1 t) (Definitions.BetS X P Y))))))
+++++
inversion H1.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.

*****
H8 : Logic.eq t B
H7 : Logic.eq t1 A
H5 : Logic.eq t0 C
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
subst.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.
subst.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y))))))
+++++
split.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.
subst.
split.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))
+++++
auto.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.
subst.
split.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))
+++++
auto.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.
subst.
split.
auto.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C X A B) (Definitions.BetS X P Y)))))
+++++
exists x.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.
subst.
split.
auto.
exists x.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS x C Y) (and (tarski_axioms.Cong C Y A B) (and (tarski_axioms.Cong C x A B) (Definitions.BetS x P Y))))
+++++
exists x0.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H1.
subst.
split.
auto.
exists x.
exists x0.

*****
H6 : Definitions.BetS x P x0
H4 : tarski_axioms.Cong C x A B
H2 : tarski_axioms.Cong C x0 A B
H0 : Definitions.BetS x C x0
H3 : not (Logic.eq A B)
H1 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x,x0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS x C x0) (and (tarski_axioms.Cong C x0 A B) (and (tarski_axioms.Cong C x A B) (Definitions.BetS x P x0)))
+++++
auto.
-----
Lemma inside : forall A B C J P, CI J C A B /\\ InCirc P J <-> exists X Y, CI J C A B /\\ Definitions.BetS X C Y /\\ tarski_axioms.Cong C Y A B /\\ tarski_axioms.Cong C X A B /\\ Definitions.BetS X P Y.
Proof.
intros.
unfold InCirc.
unfold CI.
destruct J.
destruct p.
split.

*****

*****

+++++
Qed.
-----
Lemma outside : forall A B C J P,\n  CI J C A B /\ OutCirc P J <->\n  exists X, CI J C A B /\ Definitions.BetS C X P /\\n   tarski_axioms.Cong C X A B.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (J : Tcircle) (P : Tpoint), iff (and (CI J C A B) (OutCirc P J)) (ex (fun X : Tpoint => and (CI J C A B) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
Proof.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (J : Tcircle) (P : Tpoint), iff (and (CI J C A B) (OutCirc P J)) (ex (fun X : Tpoint => and (CI J C A B) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
intros.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.

*****
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (CI J C A B) (OutCirc P J)) (ex (fun X : Tpoint => and (CI J C A B) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
unfold OutCirc.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.

*****
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (CI J C A B) (let (p, B) := J in let (C, A) := p in ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))) (ex (fun X : Tpoint => and (CI J C A B) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
unfold CI.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.

*****
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (and (Logic.eq J (pair (pair C A) B)) (not (Logic.eq A B))) (let (p, B) := J in let (C, A) := p in ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))) (ex (fun X : Tpoint => and (and (Logic.eq J (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
destruct J.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.

*****
t,P : Tpoint
p : prod Tpoint Tpoint
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (and (Logic.eq (pair p t) (pair (pair C A) B)) (not (Logic.eq A B))) (let (C, A) := p in ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A t)))) (ex (fun X : Tpoint => and (and (Logic.eq (pair p t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
destruct p.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.

*****
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t)))) (ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))))
+++++
split.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.

*****
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t))), ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
intros.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.

*****
H : and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B))\n (not (Logic.eq A B)))\n (ex\n (fun X : Tpoint =>\n and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t)))
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
spliter.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.

*****
H0 : ex\n (fun X : Tpoint =>\n and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t))
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
decompose [ex and] H0.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.

*****
H4 : tarski_axioms.Cong t0 x t1 t
H3 : Definitions.BetS t0 x P
x : Tpoint
H0 : ex\n (fun X : Tpoint =>\n and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t))
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
clear H0.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.

*****
H4 : tarski_axioms.Cong t0 x t1 t
H3 : Definitions.BetS t0 x P
x : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
exists x.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.

*****
H4 : tarski_axioms.Cong t0 x t1 t
H3 : Definitions.BetS t0 x P
x : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C x P) (tarski_axioms.Cong C x A B))
+++++
inversion H.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.
inversion H.

*****
H6 : Logic.eq t B
H5 : Logic.eq t1 A
H2 : Logic.eq t0 C
H4 : tarski_axioms.Cong t0 x t1 t
H3 : Definitions.BetS t0 x P
x : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C x P) (tarski_axioms.Cong C x A B))
+++++
subst.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
spliter.
decompose [ex and] H0.
clear H0.
exists x.
inversion H.
subst.

*****
H3 : Definitions.BetS C x P
H4 : tarski_axioms.Cong C x A B
x : Tpoint
H1 : not (Logic.eq A B)
H : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C x P) (tarski_axioms.Cong C x A B))
+++++
auto.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.

*****
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : ex (fun X : Tpoint => and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))), and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t)))
+++++
intros.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.

*****
H : ex\n (fun X : Tpoint =>\n and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B))\n (not (Logic.eq A B)))\n (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t)))
+++++
decompose [ex and] H.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
x : Tpoint
H : ex\n (fun X : Tpoint =>\n and\n (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B))\n (not (Logic.eq A B)))\n (and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
A,B,C,t0,t1,t,P : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t)))
+++++
clear H.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS t0 X P) (tarski_axioms.Cong t0 X t1 t)))
+++++
inversion H0.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H0.

*****
H6 : Logic.eq t B
H5 : Logic.eq t1 A
H2 : Logic.eq t0 C
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C A) B)
A,B,C,t0,t1,t,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
subst.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H0.
subst.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))) (ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B)))
+++++
split.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H0.
subst.
split.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Logic.eq (pair (pair C A) B) (pair (pair C A) B)) (not (Logic.eq A B))
+++++
auto.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H0.
subst.
split.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))
+++++
auto.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H0.
subst.
split.
auto.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS C X P) (tarski_axioms.Cong C X A B))
+++++
exists x.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.
intros.
decompose [ex and] H.
clear H.
inversion H0.
subst.
split.
auto.
exists x.

*****
H4 : tarski_axioms.Cong C x A B
H1 : Definitions.BetS C x P
H3 : not (Logic.eq A B)
H0 : Logic.eq (pair (pair C A) B) (pair (pair C A) B)
A,B,C,P,x : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS C x P) (tarski_axioms.Cong C x A B)
+++++
auto.
-----
Lemma outside : forall A B C J P, CI J C A B /\\ OutCirc P J <-> exists X, CI J C A B /\\ Definitions.BetS C X P /\\ tarski_axioms.Cong C X A B.
Proof.
intros.
unfold OutCirc.
unfold CI.
destruct J.
destruct p.
split.

*****

*****

+++++
Qed.
-----
End Tarski_neutral_to_Euclid_neutral.
-----
Section circle_continuity.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma bet_cases : forall B C D1 D2,\n C<>B ->\n Definitions.BetS D1 B D2 ->\n Definitions.BetS D1 C D2 ->\n Definitions.BetS D1 B C \/ Definitions.BetS C B D2.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B C D1 D2 : Tpoint) (_ : not (Logic.eq C B)) (_ : Definitions.BetS D1 B D2) (_ : Definitions.BetS D1 C D2), or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
Proof.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B C D1 D2 : Tpoint) (_ : not (Logic.eq C B)) (_ : Definitions.BetS D1 B D2) (_ : Definitions.BetS D1 C D2), or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
intros.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.

*****
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
assert (T:Bet D1 C B \/ Bet D1 B C).
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).

*****
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet D1 C B) (Bet D1 B C)
+++++
apply (l5_3 D1 C B D2).
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
apply (l5_3 D1 C B D2).

*****
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 C D2
+++++
unfold Definitions.BetS in *.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
apply (l5_3 D1 C B D2).
unfold Definitions.BetS in *.

*****
H1 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
H0 : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 C D2
+++++
spliter.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
apply (l5_3 D1 C B D2).
unfold Definitions.BetS in *.
spliter.

*****
H3 : not (Logic.eq C D2)
H2 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H5 : not (Logic.eq B D2)
H4 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 C D2
+++++
finish.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
apply (l5_3 D1 C B D2).

*****
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 B D2
+++++
unfold Definitions.BetS in *.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
apply (l5_3 D1 C B D2).
unfold Definitions.BetS in *.

*****
H1 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
H0 : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 B D2
+++++
spliter.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
apply (l5_3 D1 C B D2).
unfold Definitions.BetS in *.
spliter.

*****
H3 : not (Logic.eq C D2)
H2 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H5 : not (Logic.eq B D2)
H4 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 B D2
+++++
finish.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).

*****
T : or (Bet D1 C B) (Bet D1 B C)
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
destruct T.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.

*****
H2 : Bet D1 C B
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
right.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.

*****
H2 : Bet D1 C B
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS C B D2
+++++
unfold Definitions.BetS in *.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.

*****
H2 : Bet D1 C B
H1 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
H0 : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
+++++
spliter.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.

*****
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
+++++
assert (Bet C B D2).
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).

*****
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D2
+++++
eBetween.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).

*****
H7 : Bet C B D2
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
+++++
idtac.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).
idtac.

*****
H7 : Bet C B D2
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
+++++
unfold Definitions.BetS.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).
idtac.
unfold Definitions.BetS.

*****
H7 : Bet C B D2
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
+++++
repeat split.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).
idtac.
unfold Definitions.BetS.
repeat split.

*****
H7 : Bet C B D2
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D2
+++++
auto.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).
idtac.
unfold Definitions.BetS.
repeat split.

*****
H7 : Bet C B D2
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C B)
+++++
auto.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
right.
unfold Definitions.BetS in *.
spliter.
assert (Bet C B D2).
idtac.
unfold Definitions.BetS.
repeat split.

*****
H7 : Bet C B D2
H2 : Bet D1 C B
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D2)
+++++
auto.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.

*****
H2 : Bet D1 B C
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
left.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.

*****
H2 : Bet D1 B C
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS D1 B C
+++++
unfold Definitions.BetS.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.
unfold Definitions.BetS.

*****
H2 : Bet D1 B C
H1 : Definitions.BetS D1 C D2
H0 : Definitions.BetS D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet D1 B C) (and (not (Logic.eq D1 B)) (not (Logic.eq B C)))
+++++
unfold Definitions.BetS in *.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.
unfold Definitions.BetS.
unfold Definitions.BetS in *.

*****
H2 : Bet D1 B C
H1 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
H0 : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet D1 B C) (and (not (Logic.eq D1 B)) (not (Logic.eq B C)))
+++++
spliter.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.
unfold Definitions.BetS.
unfold Definitions.BetS in *.
spliter.

*****
H2 : Bet D1 B C
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet D1 B C) (and (not (Logic.eq D1 B)) (not (Logic.eq B C)))
+++++
repeat split.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.
unfold Definitions.BetS.
unfold Definitions.BetS in *.
spliter.
repeat split.

*****
H2 : Bet D1 B C
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D1 B C
+++++
auto.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.
unfold Definitions.BetS.
unfold Definitions.BetS in *.
spliter.
repeat split.

*****
H2 : Bet D1 B C
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq D1 B)
+++++
auto.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).
destruct T.
left.
unfold Definitions.BetS.
unfold Definitions.BetS in *.
spliter.
repeat split.

*****
H2 : Bet D1 B C
H4 : not (Logic.eq C D2)
H3 : not (Logic.eq D1 C)
H1 : Bet D1 C D2
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq D1 B)
H0 : Bet D1 B D2
H : not (Logic.eq C B)
B,C,D1,D2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B C)
+++++
auto.
-----
Lemma bet_cases : forall B C D1 D2, C<>B -> Definitions.BetS D1 B D2 -> Definitions.BetS D1 C D2 -> Definitions.BetS D1 B C \\/ Definitions.BetS C B D2.
Proof.
intros.
assert (T:Bet D1 C B \\/ Bet D1 B C).

*****

*****

+++++
Qed.
-----
Lemma circle_line :\n circle_circle ->\n forall A B C K P Q,\n    CI K C P Q -> InCirc B K ->  A <> B ->\n    exists X Y, Definitions.Col A B X /\ Definitions.Col A B Y /\\n  OnCirc X K /\ OnCirc Y K /\ Definitions.BetS X B Y.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : circle_circle) (A B C : Tpoint) (K : Tcircle) (P Q : Tpoint) (_ : CI K C P Q) (_ : InCirc B K) (_ : not (Logic.eq A B)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
Proof.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : circle_circle) (A B C : Tpoint) (K : Tcircle) (P Q : Tpoint) (_ : CI K C P Q) (_ : InCirc B K) (_ : not (Logic.eq A B)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
intros.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B K
H0 : CI K C P Q
P,Q : Tpoint
K : Tcircle
A,B,C : Tpoint
H : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
apply circle_circle__circle_circle_bis in H.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B K
H0 : CI K C P Q
P,Q : Tpoint
K : Tcircle
A,B,C : Tpoint
H : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
apply circle_circle_bis__one_point_line_circle in H.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B K
H0 : CI K C P Q
P,Q : Tpoint
K : Tcircle
A,B,C : Tpoint
H : one_point_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
apply one_point_line_circle__two_points_line_circle in H.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B K
H0 : CI K C P Q
P,Q : Tpoint
K : Tcircle
A,B,C : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
unfold CI in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B K
H0 : and (Logic.eq K (pair (pair C P) Q)) (not (Logic.eq P Q))
P,Q : Tpoint
K : Tcircle
A,B,C : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))))
+++++
destruct K.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B (pair p t)
H0 : and (Logic.eq (pair p t) (pair (pair C P) Q)) (not (Logic.eq P Q))
t,P,Q : Tpoint
p : prod Tpoint Tpoint
A,B,C : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair p t)) (and (OnCirc Y (pair p t)) (Definitions.BetS X B Y))))))
+++++
destruct p.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B (pair (pair t0 t1) t)
H0 : and (Logic.eq (pair (pair t0 t1) t) (pair (pair C P) Q))\n (not (Logic.eq P Q))
A,B,C,t0,t1,t,P,Q : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair t0 t1) t)) (and (OnCirc Y (pair (pair t0 t1) t)) (Definitions.BetS X B Y))))))
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B (pair (pair t0 t1) t)
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C P) Q)
A,B,C,t0,t1,t,P,Q : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair t0 t1) t)) (and (OnCirc Y (pair (pair t0 t1) t)) (Definitions.BetS X B Y))))))
+++++
injection H0.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B (pair (pair t0 t1) t)
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C P) Q)
A,B,C,t0,t1,t,P,Q : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Logic.eq t Q) (_ : Logic.eq t1 P) (_ : Logic.eq t0 C), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair t0 t1) t)) (and (OnCirc Y (pair (pair t0 t1) t)) (Definitions.BetS X B Y))))))
+++++
intros.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.

*****
H6 : Logic.eq t0 C
H5 : Logic.eq t1 P
H4 : Logic.eq t Q
H2 : not (Logic.eq A B)
H1 : InCirc B (pair (pair t0 t1) t)
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C P) Q)
A,B,C,t0,t1,t,P,Q : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair t0 t1) t)) (and (OnCirc Y (pair (pair t0 t1) t)) (Definitions.BetS X B Y))))))
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.

*****
H2 : not (Logic.eq A B)
H1 : InCirc B (pair (pair C P) Q)
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
unfold InCirc in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.

*****
H2 : not (Logic.eq A B)
H1 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y P Q)\n (and (tarski_axioms.Cong C X P Q) (Definitions.BetS X B Y)))))
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : two_points_line_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
unfold two_points_line_circle in H.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.

*****
H2 : not (Logic.eq A B)
H1 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y P Q)\n (and (tarski_axioms.Cong C X P Q) (Definitions.BetS X B Y)))))
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].

*****
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
destruct (eq_dec_points B C).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).

*****
H1 : Logic.eq B C
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.

*****
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
assert (HColD: Definitions.Col A C C).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).

*****
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A C C
+++++
unfold Definitions.Col.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
unfold Definitions.Col.

*****
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A C C) (or (Bet C C A) (Bet C A C))
+++++
Between.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).

*****
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.

*****
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
assert (HBet: Bet C C D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).

*****
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C C D2
+++++
Between.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).

*****
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.

*****
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].

*****
HZ : and (Definitions.Col A C Z1)\n (and (OnCircle Z1 C D2)\n (and (Definitions.Col A C Z2)\n (and (OnCircle Z2 C D2)\n (and (Bet Z1 C Z2)\n (forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A C X) (and (Definitions.Col A C Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X C Y))))))
+++++
exists Z1.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.Col A C Z1) (and (Definitions.Col A C Y) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS Z1 C Y)))))
+++++
exists Z2.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A C Z1) (and (Definitions.Col A C Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 C Z2))))
+++++
repeat split.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A C Z1
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A C Z2
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Z1 (pair (pair C P) Q)
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Z1 (pair (pair C P) Q)
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Z1 (pair (pair C P) Q)
+++++
unfold OnCirc in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.
unfold OnCirc in *.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z1 P Q
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Z2 (pair (pair C P) Q)
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Z2 (pair (pair C P) Q)
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Z2 (pair (pair C P) Q)
+++++
unfold OnCirc in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.
unfold OnCirc in *.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z2 P Q
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Z1 C Z2
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
assert (C<>D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C D2)
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
unfold Definitions.BetS in *.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C D2)
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
unfold Definitions.BetS in *.
spliter.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
H11 : not (Logic.eq C D2)
H10 : not (Logic.eq D1 C)
H9 : Bet D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq D1 C)
H12 : Bet D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C D2)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).

*****
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.

*****
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
assert (Z1<>Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.
assert (Z1<>Z2).

*****
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 Z2)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.
assert (Z1<>Z2).

*****
H10 : not (Logic.eq Z1 Z2)
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.
assert (Z1<>Z2).
idtac.

*****
H10 : not (Logic.eq Z1 Z2)
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.
assert (Z1<>Z2).
idtac.
unfold OnCircle in *.

*****
H10 : not (Logic.eq Z1 Z2)
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 C)
+++++
intro.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.
assert (Z1<>Z2).
idtac.
unfold OnCircle in *.
intro.

*****
H11 : Logic.eq Z1 C
H10 : not (Logic.eq Z1 Z2)
H9 : not (Logic.eq C D2)
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
assert (C<>D2).
idtac.
assert (Z1<>Z2).
idtac.
unfold OnCircle in *.
intro.
treat_equalities.

*****
H9 : not (Logic.eq Z1 Z1)
H8 : forall _ : not (Logic.eq Z1 Z1), not (Logic.eq Z1 Z1)
H2 : not (Logic.eq A Z1)
HBetSB : Definitions.BetS Z1 Z1 Z1
H0 : Logic.eq (pair (pair Z1 P) P) (pair (pair Z1 P) P)
H3 : not (Logic.eq P P)
A,P,Z1 : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C Z2)
+++++
try assumption.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : OnCircle Z2 C D2
H5 : Definitions.Col A C Z2
H4 : OnCircle Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C Z2)
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.

*****
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C Z2)
+++++
intro.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.
intro.

*****
H9 : Logic.eq C Z2
H8 : forall _ : not (Logic.eq C D2), not (Logic.eq Z1 Z2)
H7 : Bet Z1 C Z2
H6 : tarski_axioms.Cong C Z2 C D2
H5 : Definitions.Col A C Z2
H4 : tarski_axioms.Cong C Z1 C D2
H1 : Definitions.Col A C Z1
Z1,Z2 : Tpoint
HBet : Bet C C D2
HColD : Definitions.Col A C C
HBetSB : Definitions.BetS D1 C D2
H2 : not (Logic.eq A C)
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.
intro.
treat_equalities.

*****
H8 : forall _ : not (Logic.eq C C), not (Logic.eq C C)
H2 : not (Logic.eq A C)
HBetS : Definitions.BetS C C C
H0 : Logic.eq (pair (pair C P) P) (pair (pair C P) P)
H3 : not (Logic.eq P P)
A,C,P : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
subst.
assert (HColD: Definitions.Col A C C).
idtac.
assert (HBet: Bet C C D2).
idtac.
destruct (H C D2 A C C HColD H2 HBet) as [Z1 [Z2 HZ]].
spliter.
exists Z1.
exists Z2.
repeat split.
try assumption.
unfold OnCircle in *.
intro.
treat_equalities.
unfold Definitions.BetS in *.

*****
H8 : forall _ : not (Logic.eq C C), not (Logic.eq C C)
H2 : not (Logic.eq A C)
HBetS : and (Bet C C C) (and (not (Logic.eq C C)) (not (Logic.eq C C)))
H0 : Logic.eq (pair (pair C P) P) (pair (pair C P) P)
H3 : not (Logic.eq P P)
A,C,P : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).

*****
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
assert (TwoCases:Definitions.BetS D1 B C \/ Definitions.BetS C B D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).

*****
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
+++++
apply bet_cases.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
apply bet_cases.

*****
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C B)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
apply bet_cases.

*****
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS D1 B D2
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
apply bet_cases.

*****
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS D1 C D2
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).

*****
TwoCases : or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.

*****
TwoCases : or (Definitions.BetS D1 B C) (Definitions.BetS C B D2)
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
destruct TwoCases.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.

*****
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
assert (HColD: Definitions.Col A B B).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).

*****
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B B
+++++
unfold Definitions.Col.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
unfold Definitions.Col.

*****
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B B) (or (Bet B B A) (Bet B A B))
+++++
Between.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).

*****
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.

*****
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
assert (HBet:Bet C B D1).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).

*****
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D1
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
unfold Definitions.BetS in *.

*****
HColD : Definitions.Col A B B
H4 : and (Bet D1 B C) (and (not (Logic.eq D1 B)) (not (Logic.eq B C)))
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D1
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
unfold Definitions.BetS in *.
spliter.

*****
HColD : Definitions.Col A B B
H6 : not (Logic.eq B C)
H5 : not (Logic.eq D1 B)
H4 : Bet D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
H9 : not (Logic.eq B D2)
H8 : not (Logic.eq D1 B)
H7 : Bet D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
H12 : not (Logic.eq C D2)
H11 : not (Logic.eq D1 C)
H10 : Bet D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D1
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).

*****
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.

*****
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].

*****
HZ : and (Definitions.Col A B Z1)\n (and (OnCircle Z1 C D1)\n (and (Definitions.Col A B Z2)\n (and (OnCircle Z2 C D1)\n (and (Bet Z1 B Z2)\n (forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
exists Z1.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.

*****
HZ : and (Definitions.Col A B Z1)\n (and (OnCircle Z1 C D1)\n (and (Definitions.Col A B Z2)\n (and (OnCircle Z2 C D1)\n (and (Bet Z1 B Z2)\n (forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.Col A B Z1) (and (Definitions.Col A B Y) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS Z1 B Y)))))
+++++
exists Z2.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.

*****
HZ : and (Definitions.Col A B Z1)\n (and (OnCircle Z1 C D1)\n (and (Definitions.Col A B Z2)\n (and (OnCircle Z2 C D1)\n (and (Bet Z1 B Z2)\n (forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.

*****
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (B<>D1).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).

*****
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D1)
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
unfold Definitions.BetS in *.

*****
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : and (Bet D1 B C) (and (not (Logic.eq D1 B)) (not (Logic.eq B C)))
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D1)
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
unfold Definitions.BetS in *.
spliter.

*****
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H12 : not (Logic.eq B C)
H11 : not (Logic.eq D1 B)
H4 : Bet D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
H15 : not (Logic.eq B D2)
H14 : not (Logic.eq D1 B)
H13 : Bet D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
H18 : not (Logic.eq C D2)
H17 : not (Logic.eq D1 C)
H16 : Bet D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D1)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).

*****
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.

*****
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (Z1<>Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).

*****
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 Z2)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).

*****
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.

*****
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (Z1<>B).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).

*****
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 B)
+++++
intro.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.

*****
H13 : Logic.eq Z1 B
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : OnCircle B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (B=D1).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D1).

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B D1
+++++
apply between_cong with C.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D1).
apply between_cong with C.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D1
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D1).
apply between_cong with C.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C B C D1
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D1).

*****
H13 : Logic.eq B D1
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D1).
idtac.

*****
H13 : Logic.eq B D1
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D1)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D1
Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D1).
idtac.
subst.

*****
H10 : forall _ : not (Logic.eq D1 D1), not (Logic.eq D1 Z2)
H9 : Bet D1 D1 Z2
H11 : not (Logic.eq D1 D1)
H12 : not (Logic.eq D1 Z2)
H8 : tarski_axioms.Cong C Z2 C D1
H6 : tarski_axioms.Cong C D1 C D1
H5 : Definitions.Col A D1 D1
H7 : Definitions.Col A D1 Z2
Z2 : Tpoint
HBetSB : Definitions.BetS D1 D1 D2
H2 : not (Logic.eq A D1)
H1 : not (Logic.eq D1 C)
H4 : Definitions.BetS D1 D1 C
HColD : Definitions.Col A D1 D1
HBet : Bet C D1 D1
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).

*****
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert_diffs.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.

*****
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (B<>Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).

*****
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Z2)
+++++
intro.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.

*****
H16 : Logic.eq B Z2
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.

*****
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet C Z2 D1).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).

*****
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D1
+++++
unfold BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
unfold BetS in *.

*****
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D1
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
unfold BetS in *.
spliter.

*****
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D1
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).

*****
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.

*****
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.
unfold OnCircle in *.

*****
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Z2=D1).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.
unfold OnCircle in *.
assert (Z2=D1).

*****
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq Z2 D1
+++++
apply between_cong with C.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.
unfold OnCircle in *.
assert (Z2=D1).
apply between_cong with C.

*****
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D1
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.
unfold OnCircle in *.
assert (Z2=D1).
apply between_cong with C.

*****
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z2 C D1
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.
unfold OnCircle in *.
assert (Z2=D1).

*****
H17 : Logic.eq Z2 D1
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D1).
idtac.
unfold OnCircle in *.
assert (Z2=D1).
idtac.

*****
H17 : Logic.eq Z2 D1
H16 : Bet C Z2 D1
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D1), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D1)
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D1
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS D1 Z2 C
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D1
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).

*****
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (Definitions.BetS Z1 B Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).

*****
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS Z1 B Z2
+++++
unfold Definitions.BetS.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
unfold Definitions.BetS.

*****
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet Z1 B Z2) (and (not (Logic.eq Z1 B)) (not (Logic.eq B Z2)))
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
unfold OnCirc.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (tarski_axioms.Cong C Z1 P Q) (and (tarski_axioms.Cong C Z2 P Q) (Definitions.BetS Z1 B Z2))))
+++++
simpl.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D1
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (tarski_axioms.Cong C Z1 P Q) (and (tarski_axioms.Cong C Z2 P Q) (Definitions.BetS Z1 B Z2))))
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (tarski_axioms.Cong C Z1 P Q) (and (tarski_axioms.Cong C Z2 P Q) (Definitions.BetS Z1 B Z2))))
+++++
repeat split.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B Z1
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B Z2
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z1 P Q
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z2 P Q
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Z1 B Z2
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 B)
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D1).
idtac.
destruct (H C D1 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D1).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D2)
H14 : not (Logic.eq C D1)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D1)
H10 : forall _ : not (Logic.eq B D1), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D1
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D1
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D1
HColD : Definitions.Col A B B
H4 : Definitions.BetS D1 B C
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Z2)
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.

*****
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
assert (HColD: Definitions.Col A B B).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).

*****
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B B
+++++
unfold Definitions.Col.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
unfold Definitions.Col.

*****
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B B) (or (Bet B B A) (Bet B A B))
+++++
Between.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).

*****
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.

*****
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
assert (HBet:Bet C B D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).

*****
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D2
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
unfold Definitions.BetS in *.

*****
HColD : Definitions.Col A B B
H4 : and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D2
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
unfold Definitions.BetS in *.
spliter.

*****
HColD : Definitions.Col A B B
H6 : not (Logic.eq B D2)
H5 : not (Logic.eq C B)
H4 : Bet C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
H9 : not (Logic.eq B D2)
H8 : not (Logic.eq D1 B)
H7 : Bet D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
H12 : not (Logic.eq C D2)
H11 : not (Logic.eq D1 C)
H10 : Bet D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D2
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).

*****
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.

*****
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].

*****
HZ : and (Definitions.Col A B Z1)\n (and (OnCircle Z1 C D2)\n (and (Definitions.Col A B Z2)\n (and (OnCircle Z2 C D2)\n (and (Bet Z1 B Z2)\n (forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.Col A B X) (and (Definitions.Col A B Y) (and (OnCirc X (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS X B Y))))))
+++++
exists Z1.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.

*****
HZ : and (Definitions.Col A B Z1)\n (and (OnCircle Z1 C D2)\n (and (Definitions.Col A B Z2)\n (and (OnCircle Z2 C D2)\n (and (Bet Z1 B Z2)\n (forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.Col A B Z1) (and (Definitions.Col A B Y) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Y (pair (pair C P) Q)) (Definitions.BetS Z1 B Y)))))
+++++
exists Z2.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.

*****
HZ : and (Definitions.Col A B Z1)\n (and (OnCircle Z1 C D2)\n (and (Definitions.Col A B Z2)\n (and (OnCircle Z2 C D2)\n (and (Bet Z1 B Z2)\n (forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2))))))
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.

*****
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (B<>D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).

*****
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D2)
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
unfold Definitions.BetS in *.

*****
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : and (Bet C B D2) (and (not (Logic.eq C B)) (not (Logic.eq B D2)))
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : and (Bet D1 B D2) (and (not (Logic.eq D1 B)) (not (Logic.eq B D2)))
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D2)
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
unfold Definitions.BetS in *.
spliter.

*****
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H12 : not (Logic.eq B D2)
H11 : not (Logic.eq C B)
H4 : Bet C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
H15 : not (Logic.eq B D2)
H14 : not (Logic.eq D1 B)
H13 : Bet D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
H18 : not (Logic.eq C D2)
H17 : not (Logic.eq D1 C)
H16 : Bet D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B D2)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).

*****
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.

*****
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (Z1<>Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).

*****
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 Z2)
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).

*****
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.

*****
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (Z1<>B).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).

*****
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 B)
+++++
intro.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.

*****
H13 : Logic.eq Z1 B
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : OnCircle B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (B=D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D2).

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B D2
+++++
apply between_cong with C.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D2).
apply between_cong with C.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B D2
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D2).
apply between_cong with C.

*****
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C B C D2
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D2).

*****
H13 : Logic.eq B D2
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D2).
idtac.

*****
H13 : Logic.eq B D2
H12 : not (Logic.eq B Z2)
H11 : not (Logic.eq B D2)
H9 : Bet B B Z2
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq B Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H5 : Definitions.Col A B B
H6 : tarski_axioms.Cong C B C D2
Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
intro.
subst.
unfold OnCircle in *.
assert (B=D2).
idtac.
subst.

*****
H10 : forall _ : not (Logic.eq D2 D2), not (Logic.eq D2 Z2)
H9 : Bet D2 D2 Z2
H11 : not (Logic.eq D2 D2)
H12 : not (Logic.eq D2 Z2)
H8 : tarski_axioms.Cong C Z2 C D2
H6 : tarski_axioms.Cong C D2 C D2
H5 : Definitions.Col A D2 D2
H7 : Definitions.Col A D2 Z2
Z2 : Tpoint
HBetSB : Definitions.BetS D1 D2 D2
H2 : not (Logic.eq A D2)
H1 : not (Logic.eq D2 C)
H4 : Definitions.BetS C D2 D2
HColD : Definitions.Col A D2 D2
HBet : Bet C D2 D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).

*****
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert_diffs.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.

*****
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (B<>Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).

*****
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Z2)
+++++
intro.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.

*****
H16 : Logic.eq B Z2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.

*****
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet C Z2 D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).

*****
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D2
+++++
unfold BetS in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
unfold BetS in *.

*****
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D2
+++++
spliter.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
unfold BetS in *.
spliter.

*****
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D2
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).

*****
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.

*****
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : OnCircle Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.
unfold OnCircle in *.

*****
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Z2=D2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.
unfold OnCircle in *.
assert (Z2=D2).

*****
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq Z2 D2
+++++
apply between_cong with C.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.
unfold OnCircle in *.
assert (Z2=D2).
apply between_cong with C.

*****
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Z2 D2
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.
unfold OnCircle in *.
assert (Z2=D2).
apply between_cong with C.

*****
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z2 C D2
+++++
finish.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.
unfold OnCircle in *.
assert (Z2=D2).

*****
H17 : Logic.eq Z2 D2
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
intro.
subst.
assert (Bet C Z2 D2).
idtac.
unfold OnCircle in *.
assert (Z2=D2).
idtac.

*****
H17 : Logic.eq Z2 D2
H16 : Bet C Z2 D2
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H12,H13 : not (Logic.eq Z1 Z2)
H9 : Bet Z1 Z2 Z2
H10 : forall _ : not (Logic.eq Z2 D2), not (Logic.eq Z1 Z2)
H11 : not (Logic.eq Z2 D2)
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A Z2 Z2
H6 : tarski_axioms.Cong C Z1 C D2
HBetSB : Definitions.BetS D1 Z2 D2
H2 : not (Logic.eq A Z2)
H1 : not (Logic.eq Z2 C)
H4 : Definitions.BetS C Z2 D2
HColD : Definitions.Col A Z2 Z2
HBet : Bet C Z2 D2
H5 : Definitions.Col A Z2 Z1
Z2,Z1 : Tpoint
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).

*****
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
assert (Definitions.BetS Z1 B Z2).
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).

*****
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS Z1 B Z2
+++++
unfold Definitions.BetS.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
unfold Definitions.BetS.

*****
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet Z1 B Z2) (and (not (Logic.eq Z1 B)) (not (Logic.eq B Z2)))
+++++
auto.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
idtac.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (OnCirc Z1 (pair (pair C P) Q)) (and (OnCirc Z2 (pair (pair C P) Q)) (Definitions.BetS Z1 B Z2))))
+++++
unfold OnCirc.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (tarski_axioms.Cong C Z1 P Q) (and (tarski_axioms.Cong C Z2 P Q) (Definitions.BetS Z1 B Z2))))
+++++
simpl.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : OnCircle Z2 C D2
H7 : Definitions.Col A B Z2
H6 : OnCircle Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (tarski_axioms.Cong C Z1 P Q) (and (tarski_axioms.Cong C Z2 P Q) (Definitions.BetS Z1 B Z2))))
+++++
unfold OnCircle in *.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.Col A B Z1) (and (Definitions.Col A B Z2) (and (tarski_axioms.Cong C Z1 P Q) (and (tarski_axioms.Cong C Z2 P Q) (Definitions.BetS Z1 B Z2))))
+++++
repeat split.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B Z1
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B Z2
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z1 P Q
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z2 P Q
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Z1 B Z2
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Z1 B)
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).
assert (TwoCases:Definitions.BetS D1 B C \\/ Definitions.BetS C B D2).
idtac.
destruct TwoCases.
assert (HColD: Definitions.Col A B B).
idtac.
assert (HBet:Bet C B D2).
idtac.
destruct (H C D2 A B B HColD H2 HBet) as [Z1 [Z2 HZ]].
exists Z1.
exists Z2.
spliter.
assert (B<>D2).
idtac.
assert (Z1<>Z2).
idtac.
assert (Z1<>B).
assert_diffs.
assert (B<>Z2).
assert (Definitions.BetS Z1 B Z2).
idtac.
unfold OnCirc.
simpl.
unfold OnCircle in *.
repeat split.

*****
H17 : Definitions.BetS Z1 B Z2
H16 : not (Logic.eq B Z2)
H15 : not (Logic.eq C D1)
H14 : not (Logic.eq C D2)
H13 : not (Logic.eq Z1 B)
H12 : not (Logic.eq Z1 Z2)
H11 : not (Logic.eq B D2)
H10 : forall _ : not (Logic.eq B D2), not (Logic.eq Z1 Z2)
H9 : Bet Z1 B Z2
H8 : tarski_axioms.Cong C Z2 C D2
H7 : Definitions.Col A B Z2
H6 : tarski_axioms.Cong C Z1 C D2
H5 : Definitions.Col A B Z1
Z1,Z2 : Tpoint
HBet : Bet C B D2
HColD : Definitions.Col A B B
H4 : Definitions.BetS C B D2
H1 : not (Logic.eq B C)
H2 : not (Logic.eq A B)
HBetSB : Definitions.BetS D1 B D2
HCongB : tarski_axioms.Cong C D1 P Q
HCongA : tarski_axioms.Cong C D2 P Q
HBetS : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H3 : not (Logic.eq P Q)
H0 : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
H : forall (A B U V P : Tpoint) (_ : Definitions.Col U V P)\n (_ : not (Logic.eq U V)) (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Definitions.Col U V Z1)\n (and (tarski_axioms.Cong A Z1 A B)\n (and (Definitions.Col U V Z2)\n (and (tarski_axioms.Cong A Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (Logic.eq P B),\n not (Logic.eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Z2)
+++++
eCong.
-----
Lemma circle_line : circle_circle -> forall A B C K P Q, CI K C P Q -> InCirc B K -> A <> B -> exists X Y, Definitions.Col A B X /\\ Definitions.Col A B Y /\\ OnCirc X K /\\ OnCirc Y K /\\ Definitions.BetS X B Y.
Proof.
intros.
apply circle_circle__circle_circle_bis in H.
apply circle_circle_bis__one_point_line_circle in H.
apply one_point_line_circle__two_points_line_circle in H.
unfold CI in *.
destruct K.
destruct p.
spliter.
injection H0.
intros.
subst.
unfold InCirc in *.
unfold two_points_line_circle in H.
destruct H1 as [D1 [D2 [HBetS [HCongA [HCongB HBetSB]]]]].
destruct (eq_dec_points B C).

*****

*****

+++++
Qed.
-----
Lemma circle_circle' :\n circle_circle ->\n forall C D F G J K P Q R S,\n    CI J C R S -> InCirc P J ->\n    OutCirc Q J -> CI K D F G ->\n    OnCirc P K -> OnCirc Q K ->\n    exists X, OnCirc X J /\ OnCirc X K.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : circle_circle) (C D F G : Tpoint) (J K : Tcircle) (P Q R S : Tpoint) (_ : CI J C R S) (_ : InCirc P J) (_ : OutCirc Q J) (_ : CI K D F G) (_ : OnCirc P K) (_ : OnCirc Q K), ex (fun X : Tpoint => and (OnCirc X J) (OnCirc X K))
+++++
Proof.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : circle_circle) (C D F G : Tpoint) (J K : Tcircle) (P Q R S : Tpoint) (_ : CI J C R S) (_ : InCirc P J) (_ : OutCirc Q J) (_ : CI K D F G) (_ : OnCirc P K) (_ : OnCirc Q K), ex (fun X : Tpoint => and (OnCirc X J) (OnCirc X K))
+++++
intros.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.

*****
H5 : OnCirc Q K
H4 : OnCirc P K
H3 : CI K D F G
H2 : OutCirc Q J
H1 : InCirc P J
H0 : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
H : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X J) (OnCirc X K))
+++++
unfold circle_circle in H.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.

*****
H5 : OnCirc Q K
H4 : OnCirc P K
H3 : CI K D F G
H2 : OutCirc Q J
H1 : InCirc P J
H0 : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X J) (OnCirc X K))
+++++
destruct J.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.

*****
H5 : OnCirc Q K
H4 : OnCirc P K
H3 : CI K D F G
H2 : OutCirc Q (pair p t)
H1 : InCirc P (pair p t)
H0 : CI (pair p t) C R S
P,Q,R,S : Tpoint
K : Tcircle
t : Tpoint
p : prod Tpoint Tpoint
C,D,F,G : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair p t)) (OnCirc X K))
+++++
destruct p.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.

*****
H5 : OnCirc Q K
H4 : OnCirc P K
H3 : CI K D F G
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H0 : CI (pair (pair t0 t1) t) C R S
P,Q,R,S : Tpoint
K : Tcircle
C,D,F,G,t0,t1,t : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X K))
+++++
destruct K.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.

*****
H5 : OnCirc Q (pair p t2)
H4 : OnCirc P (pair p t2)
H3 : CI (pair p t2) D F G
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H0 : CI (pair (pair t0 t1) t) C R S
t2,P,Q,R,S : Tpoint
p : prod Tpoint Tpoint
C,D,F,G,t0,t1,t : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X (pair p t2)))
+++++
destruct p.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.

*****
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H3 : CI (pair (pair t3 t4) t2) D F G
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H0 : CI (pair (pair t0 t1) t) C R S
C,D,F,G,t0,t1,t,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
unfold CI in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.

*****
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H3 : and (Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G))\n (not (Logic.eq F G))
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H0 : and (Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S))\n (not (Logic.eq R S))
C,D,F,G,t0,t1,t,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.

*****
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G)
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S)
C,D,F,G,t0,t1,t,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
injection H0.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.

*****
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G)
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S)
C,D,F,G,t0,t1,t,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Logic.eq t S) (_ : Logic.eq t1 R) (_ : Logic.eq t0 C), ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
intros.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.

*****
H10 : Logic.eq t0 C
H9 : Logic.eq t1 R
H8 : Logic.eq t S
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G)
H2 : OutCirc Q (pair (pair t0 t1) t)
H1 : InCirc P (pair (pair t0 t1) t)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S)
C,D,F,G,t0,t1,t,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair t0 t1) t)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
subst.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.

*****
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G)
H1 : InCirc P (pair (pair C R) S)
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair C R) S)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
injection H3.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.

*****
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G)
H1 : InCirc P (pair (pair C R) S)
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Logic.eq t2 G) (_ : Logic.eq t4 F) (_ : Logic.eq t3 D), ex (fun X : Tpoint => and (OnCirc X (pair (pair C R) S)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
intros.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.

*****
H10 : Logic.eq t3 D
H9 : Logic.eq t4 F
H8 : Logic.eq t2 G
H5 : OnCirc Q (pair (pair t3 t4) t2)
H4 : OnCirc P (pair (pair t3 t4) t2)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair t3 t4) t2) (pair (pair D F) G)
H1 : InCirc P (pair (pair C R) S)
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,t3,t4,t2,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair C R) S)) (OnCirc X (pair (pair t3 t4) t2)))
+++++
subst.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.

*****
H4 : OnCirc P (pair (pair D F) G)
H5 : OnCirc Q (pair (pair D F) G)
H6 : not (Logic.eq F G)
H3 : Logic.eq (pair (pair D F) G) (pair (pair D F) G)
H1 : InCirc P (pair (pair C R) S)
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
H0 : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair C R) S)) (OnCirc X (pair (pair D F) G)))
+++++
clear H0 H3.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.

*****
H4 : OnCirc P (pair (pair D F) G)
H5 : OnCirc Q (pair (pair D F) G)
H6 : not (Logic.eq F G)
H1 : InCirc P (pair (pair C R) S)
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (OnCirc X (pair (pair C R) S)) (OnCirc X (pair (pair D F) G)))
+++++
unfold OnCirc in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H1 : InCirc P (pair (pair C R) S)
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
unfold InCirc in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H1 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y R S)\n (and (tarski_axioms.Cong C X R S) (Definitions.BetS X P Y)))))
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
destruct H1 as [D1 [D2 HD]].
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
HD : and (Definitions.BetS D1 C D2)\n (and (tarski_axioms.Cong C D2 R S)\n (and (tarski_axioms.Cong C D1 R S) (Definitions.BetS D1 P D2)))
D1,D2 : Tpoint
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H2 : OutCirc Q (pair (pair C R) S)
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
unfold OutCirc in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H2 : ex\n (fun X : Tpoint =>\n and (Definitions.BetS C X Q) (tarski_axioms.Cong C X R S))
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
destruct H2 as [X HX].
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
HX : and (Definitions.BetS C X Q) (tarski_axioms.Cong C X R S)
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
assert (OnCircle P D Q).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P D Q
+++++
unfold OnCircle.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
unfold OnCircle.

*****
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong D P D Q
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).

*****
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
idtac.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.

*****
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
assert (OnCircle Q D Q).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).

*****
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q D Q
+++++
unfold OnCircle.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
unfold OnCircle.

*****
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong D Q D Q
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).

*****
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
idtac.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.

*****
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
assert (InCircle P C D1).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).

*****
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P C D1
+++++
unfold InCircle.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.

*****
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
destruct (eq_dec_points C P).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).

*****
H12 : Logic.eq C P
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
subst.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
subst.

*****
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H0,H8 : Definitions.BetS D1 P D2
H1 : tarski_axioms.Cong P D2 R S
H3 : tarski_axioms.Cong P D1 R S
D1,D2 : Tpoint
H2 : Definitions.BetS P X Q
H9 : tarski_axioms.Cong P X R S
X : Tpoint
H7 : not (Logic.eq R S)
D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le P P P D1
+++++
apply le_trivial.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).

*****
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
assert (TwoCases:Definitions.BetS D1 P C \/ Definitions.BetS C P D2).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).

*****
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Definitions.BetS D1 P C) (Definitions.BetS C P D2)
+++++
apply bet_cases.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
apply bet_cases.

*****
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C P)
+++++
auto.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
apply bet_cases.

*****
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS D1 P D2
+++++
auto.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
apply bet_cases.

*****
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS D1 C D2
+++++
auto.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).

*****
TwoCases : or (Definitions.BetS D1 P C) (Definitions.BetS C P D2)
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
idtac.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.

*****
TwoCases : or (Definitions.BetS D1 P C) (Definitions.BetS C P D2)
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
destruct TwoCases.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.

*****
H13 : Definitions.BetS D1 P C
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
exists P.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.

*****
H13 : Definitions.BetS D1 P C
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C P D1) (tarski_axioms.Cong C P C P)
+++++
split.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.
split.

*****
H13 : Definitions.BetS D1 P C
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D1
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.
split.
unfold Definitions.BetS in *.

*****
H13 : and (Bet D1 P C) (and (not (Logic.eq D1 P)) (not (Logic.eq P C)))
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : and (Bet D1 P D2) (and (not (Logic.eq D1 P)) (not (Logic.eq P D2)))
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : and (Bet C X Q) (and (not (Logic.eq C X)) (not (Logic.eq X Q)))
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D1
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.
split.
unfold Definitions.BetS in *.
spliter.

*****
H15 : not (Logic.eq P C)
H14 : not (Logic.eq D1 P)
H13 : Bet D1 P C
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H17 : not (Logic.eq P D2)
H16 : not (Logic.eq D1 P)
H8 : Bet D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H19 : not (Logic.eq C D2)
H18 : not (Logic.eq D1 C)
H0 : Bet D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H21 : not (Logic.eq X Q)
H20 : not (Logic.eq C X)
H2 : Bet C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D1
+++++
finish.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.
split.

*****
H13 : Definitions.BetS D1 P C
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.
split.
unfold Definitions.BetS in *.

*****
H13 : and (Bet D1 P C) (and (not (Logic.eq D1 P)) (not (Logic.eq P C)))
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : and (Bet D1 P D2) (and (not (Logic.eq D1 P)) (not (Logic.eq P D2)))
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : and (Bet C X Q) (and (not (Logic.eq C X)) (not (Logic.eq X Q)))
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
exists P.
split.
unfold Definitions.BetS in *.
spliter.

*****
H15 : not (Logic.eq P C)
H14 : not (Logic.eq D1 P)
H13 : Bet D1 P C
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H17 : not (Logic.eq P D2)
H16 : not (Logic.eq D1 P)
H8 : Bet D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H19 : not (Logic.eq C D2)
H18 : not (Logic.eq D1 C)
H0 : Bet D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H21 : not (Logic.eq X Q)
H20 : not (Logic.eq C X)
H2 : Bet C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
finish.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D1
+++++
apply l5_6 with C P C D2.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C P C D2
+++++
exists P.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C P D2) (tarski_axioms.Cong C P C P)
+++++
split.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.
split.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D2
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.
split.
unfold Definitions.BetS in *.

*****
H13 : and (Bet C P D2) (and (not (Logic.eq C P)) (not (Logic.eq P D2)))
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : and (Bet D1 P D2) (and (not (Logic.eq D1 P)) (not (Logic.eq P D2)))
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : and (Bet C X Q) (and (not (Logic.eq C X)) (not (Logic.eq X Q)))
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D2
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.
split.
unfold Definitions.BetS in *.
spliter.

*****
H15 : not (Logic.eq P D2)
H14 : not (Logic.eq C P)
H13 : Bet C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H17 : not (Logic.eq P D2)
H16 : not (Logic.eq D1 P)
H8 : Bet D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H19 : not (Logic.eq C D2)
H18 : not (Logic.eq D1 C)
H0 : Bet D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H21 : not (Logic.eq X Q)
H20 : not (Logic.eq C X)
H2 : Bet C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D2
+++++
finish.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.
split.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.
split.
unfold Definitions.BetS in *.

*****
H13 : and (Bet C P D2) (and (not (Logic.eq C P)) (not (Logic.eq P D2)))
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : and (Bet D1 P D2) (and (not (Logic.eq D1 P)) (not (Logic.eq P D2)))
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : and (Bet C X Q) (and (not (Logic.eq C X)) (not (Logic.eq X Q)))
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.
exists P.
split.
unfold Definitions.BetS in *.
spliter.

*****
H15 : not (Logic.eq P D2)
H14 : not (Logic.eq C P)
H13 : Bet C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H17 : not (Logic.eq P D2)
H16 : not (Logic.eq D1 P)
H8 : Bet D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H19 : not (Logic.eq C D2)
H18 : not (Logic.eq D1 C)
H0 : Bet D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H21 : not (Logic.eq X Q)
H20 : not (Logic.eq C X)
H2 : Bet C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
finish.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C P C P
+++++
finish.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
unfold InCircle.
destruct (eq_dec_points C P).
assert (TwoCases:Definitions.BetS D1 P C \\/ Definitions.BetS C P D2).
idtac.
destruct TwoCases.
apply l5_6 with C P C D2.

*****
H13 : Definitions.BetS C P D2
H12 : not (Logic.eq C P)
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C D2 C D1
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
assert (OutCircle Q C D1).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q C D1
+++++
unfold OutCircle.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D1 C Q
+++++
exists X.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C X Q) (tarski_axioms.Cong C D1 C X)
+++++
split.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.
split.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C X Q
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.
split.
unfold Definitions.BetS in *.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : and (Bet D1 P D2) (and (not (Logic.eq D1 P)) (not (Logic.eq P D2)))
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : and (Bet C X Q) (and (not (Logic.eq C X)) (not (Logic.eq X Q)))
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C X Q
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.
split.
unfold Definitions.BetS in *.
spliter.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H14 : not (Logic.eq P D2)
H13 : not (Logic.eq D1 P)
H8 : Bet D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H16 : not (Logic.eq C D2)
H15 : not (Logic.eq D1 C)
H0 : Bet D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H18 : not (Logic.eq X Q)
H17 : not (Logic.eq C X)
H2 : Bet C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C X Q
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.
split.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C D1 C X
+++++
unfold Definitions.BetS in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.
split.
unfold Definitions.BetS in *.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : and (Bet D1 P D2) (and (not (Logic.eq D1 P)) (not (Logic.eq P D2)))
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : and (Bet D1 C D2) (and (not (Logic.eq D1 C)) (not (Logic.eq C D2)))
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : and (Bet C X Q) (and (not (Logic.eq C X)) (not (Logic.eq X Q)))
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C D1 C X
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
unfold OutCircle.
exists X.
split.
unfold Definitions.BetS in *.
spliter.

*****
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H14 : not (Logic.eq P D2)
H13 : not (Logic.eq D1 P)
H8 : Bet D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H16 : not (Logic.eq C D2)
H15 : not (Logic.eq D1 C)
H0 : Bet D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H18 : not (Logic.eq X Q)
H17 : not (Logic.eq C X)
H2 : Bet C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C D1 C X
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).

*****
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\ OnCircle Z D Q).
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).

*****
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z C D1) (OnCircle Z D Q))
+++++
eauto.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).

*****
Hex : ex (fun Z : Tpoint => and (OnCircle Z C D1) (OnCircle Z D Q))
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
idtac.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.

*****
Hex : ex (fun Z : Tpoint => and (OnCircle Z C D1) (OnCircle Z D Q))
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
destruct Hex as [Z HZ].
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.
destruct Hex as [Z HZ].

*****
HZ : and (OnCircle Z C D1) (OnCircle Z D Q)
Z : Tpoint
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (tarski_axioms.Cong C X R S) (tarski_axioms.Cong D X F G))
+++++
exists Z.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.
destruct Hex as [Z HZ].
exists Z.

*****
HZ : and (OnCircle Z C D1) (OnCircle Z D Q)
Z : Tpoint
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : OnCircle Q D Q
H10 : OnCircle P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C Z R S) (tarski_axioms.Cong D Z F G)
+++++
unfold OnCircle in *.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.
destruct Hex as [Z HZ].
exists Z.
unfold OnCircle in *.

*****
HZ : and (tarski_axioms.Cong C Z C D1) (tarski_axioms.Cong D Z D Q)
Z : Tpoint
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : tarski_axioms.Cong D Q D Q
H10 : tarski_axioms.Cong D P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : tarski_axioms.Cong C P C D)\n (_ : tarski_axioms.Cong C Q C D) (_ : InCircle P A B)\n (_ : OutCircle Q A B),\nex\n (fun Z : Tpoint =>\n and (tarski_axioms.Cong A Z A B) (tarski_axioms.Cong C Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C Z R S) (tarski_axioms.Cong D Z F G)
+++++
spliter.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.
destruct Hex as [Z HZ].
exists Z.
unfold OnCircle in *.
spliter.

*****
H15 : tarski_axioms.Cong D Z D Q
H14 : tarski_axioms.Cong C Z C D1
Z : Tpoint
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : tarski_axioms.Cong D Q D Q
H10 : tarski_axioms.Cong D P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : tarski_axioms.Cong C P C D)\n (_ : tarski_axioms.Cong C Q C D) (_ : InCircle P A B)\n (_ : OutCircle Q A B),\nex\n (fun Z : Tpoint =>\n and (tarski_axioms.Cong A Z A B) (tarski_axioms.Cong C Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C Z R S) (tarski_axioms.Cong D Z F G)
+++++
split.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.
destruct Hex as [Z HZ].
exists Z.
unfold OnCircle in *.
spliter.
split.

*****
H15 : tarski_axioms.Cong D Z D Q
H14 : tarski_axioms.Cong C Z C D1
Z : Tpoint
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : tarski_axioms.Cong D Q D Q
H10 : tarski_axioms.Cong D P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : tarski_axioms.Cong C P C D)\n (_ : tarski_axioms.Cong C Q C D) (_ : InCircle P A B)\n (_ : OutCircle Q A B),\nex\n (fun Z : Tpoint =>\n and (tarski_axioms.Cong A Z A B) (tarski_axioms.Cong C Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C Z R S
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).
idtac.
assert (OnCircle Q D Q).
idtac.
assert (InCircle P C D1).
assert (OutCircle Q C D1).
assert (Hex: exists Z : Tpoint, OnCircle Z C D1 /\\ OnCircle Z D Q).
idtac.
destruct Hex as [Z HZ].
exists Z.
unfold OnCircle in *.
spliter.
split.

*****
H15 : tarski_axioms.Cong D Z D Q
H14 : tarski_axioms.Cong C Z C D1
Z : Tpoint
H13 : OutCircle Q C D1
H12 : InCircle P C D1
H11 : tarski_axioms.Cong D Q D Q
H10 : tarski_axioms.Cong D P D Q
H4 : tarski_axioms.Cong D P F G
H5 : tarski_axioms.Cong D Q F G
H6 : not (Logic.eq F G)
H8 : Definitions.BetS D1 P D2
H3 : tarski_axioms.Cong C D1 R S
H1 : tarski_axioms.Cong C D2 R S
H0 : Definitions.BetS D1 C D2
D1,D2 : Tpoint
H9 : tarski_axioms.Cong C X R S
H2 : Definitions.BetS C X Q
X : Tpoint
H7 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
H : forall (A B C D P Q : Tpoint) (_ : tarski_axioms.Cong C P C D)\n (_ : tarski_axioms.Cong C Q C D) (_ : InCircle P A B)\n (_ : OutCircle Q A B),\nex\n (fun Z : Tpoint =>\n and (tarski_axioms.Cong A Z A B) (tarski_axioms.Cong C Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong D Z F G
+++++
eCong.
-----
Lemma circle_circle' : circle_circle -> forall C D F G J K P Q R S, CI J C R S -> InCirc P J -> OutCirc Q J -> CI K D F G -> OnCirc P K -> OnCirc Q K -> exists X, OnCirc X J /\\ OnCirc X K.
Proof.
intros.
unfold circle_circle in H.
destruct J.
destruct p.
destruct K.
destruct p.
unfold CI in *.
spliter.
injection H0.
intros.
subst.
injection H3.
intros.
subst.
clear H0 H3.
unfold OnCirc in *.
unfold InCirc in *.
destruct H1 as [D1 [D2 HD]].
spliter.
unfold OutCirc in *.
destruct H2 as [X HX].
spliter.
assert (OnCircle P D Q).

*****

*****

+++++
Qed.
-----
End circle_continuity.
-----
Section Neutral.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_neutral
+++++
Proof.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_neutral
+++++
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B C D E P Q : Tpoint) (_ : tarski_axioms.Cong P Q B C) (_ : tarski_axioms.Cong P Q D E), tarski_axioms.Cong B C D E
+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (B C D E P Q : Tpoint) (_ : tarski_axioms.Cong P Q B C) (_ : tarski_axioms.Cong P Q D E), tarski_axioms.Cong B C D E
+++++
intros;apply cong_transitivity with P Q;finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B : Tpoint, tarski_axioms.Cong A B A B
+++++
intro;finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B : Tpoint, tarski_axioms.Cong A B B A
+++++
intro;finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C a b c : Tpoint) (_ : tarski_axioms.Cong A B a b) (_ : tarski_axioms.Cong B C b c) (_ : Definitions.BetS A B C) (_ : Definitions.BetS a b c), tarski_axioms.Cong A C a c
+++++
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (not (Logic.eq A B))), Logic.eq A B
+++++
intros.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.

*****
H : not (not (Logic.eq A B))
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq A B
+++++
destruct (eq_dec_points A B);intuition.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (J : Tcircle) (P : Tpoint) (_ : CI J A B C) (_ : ex (fun X : Tpoint => ex (fun Y : Tpoint => ex (fun U : Tpoint => and (CI J U X Y) (tarski_axioms.Cong U P X Y))))), tarski_axioms.Cong A P B C
+++++
intros.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.

*****
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun U : Tpoint =>\n and (CI J U X Y) (tarski_axioms.Cong U P X Y))))
H : CI J A B C
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A P B C
+++++
decompose [ex and] H0.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.

*****
H3 : tarski_axioms.Cong x1 P x x0
H2 : CI J x1 x x0
x,x0,x1 : Tpoint
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun U : Tpoint =>\n and (CI J U X Y) (tarski_axioms.Cong U P X Y))))
H : CI J A B C
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A P B C
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.

*****
H3 : tarski_axioms.Cong x1 P x x0
H2 : and (Logic.eq J (pair (pair x1 x) x0)) (not (Logic.eq x x0))
x,x0,x1 : Tpoint
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun U : Tpoint =>\n and\n (and (Logic.eq J (pair (pair U X) Y)) (not (Logic.eq X Y)))\n (tarski_axioms.Cong U P X Y))))
H : and (Logic.eq J (pair (pair A B) C)) (not (Logic.eq B C))
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A P B C
+++++
spliter.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.

*****
H3 : tarski_axioms.Cong x1 P x x0
H2 : not (Logic.eq x x0)
H1 : Logic.eq J (pair (pair x1 x) x0)
x,x0,x1 : Tpoint
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun U : Tpoint =>\n and\n (and (Logic.eq J (pair (pair U X) Y)) (not (Logic.eq X Y)))\n (tarski_axioms.Cong U P X Y))))
H4 : not (Logic.eq B C)
H : Logic.eq J (pair (pair A B) C)
P : Tpoint
J : Tcircle
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A P B C
+++++
congruence.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq tarski_axioms.PA tarski_axioms.PB)) (and (not (Logic.eq tarski_axioms.PA tarski_axioms.PC)) (and (not (Logic.eq tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PC tarski_axioms.PB)) (not (Definitions.BetS tarski_axioms.PB tarski_axioms.PA tarski_axioms.PC))))))
+++++
assert (T:=lower_dim).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq tarski_axioms.PA tarski_axioms.PB)) (and (not (Logic.eq tarski_axioms.PA tarski_axioms.PC)) (and (not (Logic.eq tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PC tarski_axioms.PB)) (not (Definitions.BetS tarski_axioms.PB tarski_axioms.PA tarski_axioms.PC))))))
+++++
split.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq tarski_axioms.PA tarski_axioms.PB)
+++++
intro H;rewrite H in *;apply T;Between.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq tarski_axioms.PA tarski_axioms.PC)) (and (not (Logic.eq tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PC tarski_axioms.PB)) (not (Definitions.BetS tarski_axioms.PB tarski_axioms.PA tarski_axioms.PC)))))
+++++
split.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq tarski_axioms.PA tarski_axioms.PC)
+++++
intro H;rewrite H in *;apply T;Between.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PC tarski_axioms.PB)) (not (Definitions.BetS tarski_axioms.PB tarski_axioms.PA tarski_axioms.PC))))
+++++
split.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq tarski_axioms.PB tarski_axioms.PC)
+++++
intro H;rewrite H in *;apply T;Between.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)) (and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PC tarski_axioms.PB)) (not (Definitions.BetS tarski_axioms.PB tarski_axioms.PA tarski_axioms.PC)))
+++++
split.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)
+++++
unfold Definitions.BetS in *;intuition.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.

*****
T : not\n (or (Bet tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC)\n (or (Bet tarski_axioms.PB tarski_axioms.PC tarski_axioms.PA)\n (Bet tarski_axioms.PC tarski_axioms.PA tarski_axioms.PB)))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Definitions.BetS tarski_axioms.PA tarski_axioms.PC tarski_axioms.PB)) (not (Definitions.BetS tarski_axioms.PB tarski_axioms.PA tarski_axioms.PC))
+++++
unfold Definitions.BetS in *;intuition.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B : Tpoint, not (Definitions.BetS A B A)
+++++
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Tpoint) (_ : Definitions.BetS A B C), Definitions.BetS C B A
+++++
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Definitions.BetS A B D) (_ : Definitions.BetS B C D), Definitions.BetS A B C
+++++
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : Definitions.BetS A B D) (_ : Definitions.BetS A C D) (_ : not (Definitions.BetS A B C)) (_ : not (Definitions.BetS A C B)), Logic.eq B C
+++++
intros;unfold Definitions.BetS in *; intros;spliter.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.

*****
H2 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H1 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (Logic.eq C D)
H3 : not (Logic.eq A C)
H0 : Bet A C D
H6 : not (Logic.eq B D)
H5 : not (Logic.eq A B)
H : Bet A B D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
assert (Bet A B C \/ Bet A C B) by (apply l5_3 with D;auto).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).

*****
H7 : or (Bet A B C) (Bet A C B)
H2 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H1 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (Logic.eq C D)
H3 : not (Logic.eq A C)
H0 : Bet A C D
H6 : not (Logic.eq B D)
H5 : not (Logic.eq A B)
H : Bet A B D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
assert (~ (Bet A C B /\ A <> C /\ B <> C)) by intuition.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.

*****
H8 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq B C))))
H7 : or (Bet A B C) (Bet A C B)
H2 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H1 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (Logic.eq C D)
H3 : not (Logic.eq A C)
H0 : Bet A C D
H6 : not (Logic.eq B D)
H5 : not (Logic.eq A B)
H : Bet A B D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
assert (T3:=eq_dec_points A B).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).

*****
T3 : or (Logic.eq A B) (not (Logic.eq A B))
H8 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq B C))))
H7 : or (Bet A B C) (Bet A C B)
H2 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H1 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (Logic.eq C D)
H3 : not (Logic.eq A C)
H0 : Bet A C D
H6 : not (Logic.eq B D)
H5 : not (Logic.eq A B)
H : Bet A B D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
assert (T4:=eq_dec_points A C).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).

*****
T4 : or (Logic.eq A C) (not (Logic.eq A C))
T3 : or (Logic.eq A B) (not (Logic.eq A B))
H8 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq B C))))
H7 : or (Bet A B C) (Bet A C B)
H2 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H1 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (Logic.eq C D)
H3 : not (Logic.eq A C)
H0 : Bet A C D
H6 : not (Logic.eq B D)
H5 : not (Logic.eq A B)
H : Bet A B D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
assert (T5:=eq_dec_points B C).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).

*****
T5 : or (Logic.eq B C) (not (Logic.eq B C))
T4 : or (Logic.eq A C) (not (Logic.eq A C))
T3 : or (Logic.eq A B) (not (Logic.eq A B))
H8 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq B C))))
H7 : or (Bet A B C) (Bet A C B)
H2 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H1 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (Logic.eq C D)
H3 : not (Logic.eq A C)
H0 : Bet A C D
H6 : not (Logic.eq B D)
H5 : not (Logic.eq A B)
H : Bet A B D
A,B,C,D : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D : Tpoint) (_ : not (Logic.eq A B)) (_ : tarski_axioms.Cong A B C D), not (Logic.eq C D)
+++++
intros;intro;treat_equalities;finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D a b c d : Tpoint) (_ : tarski_axioms.Cong B C b c) (_ : tarski_axioms.Cong A D a d) (_ : tarski_axioms.Cong B D b d) (_ : Definitions.BetS A B C) (_ : Definitions.BetS a b c) (_ : tarski_axioms.Cong A B a b), tarski_axioms.Cong D C d c
+++++
intros.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.

*****
H4 : tarski_axioms.Cong A B a b
H3 : Definitions.BetS a b c
H2 : Definitions.BetS A B C
H1 : tarski_axioms.Cong B D b d
H0 : tarski_axioms.Cong A D a d
H : tarski_axioms.Cong B C b c
A,B,C,D,a,b,c,d : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong D C d c
+++++
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).

*****
H5 : tarski_axioms.Cong C D c d
H4 : tarski_axioms.Cong A B a b
H3 : Definitions.BetS a b c
H2 : Definitions.BetS A B C
H1 : tarski_axioms.Cong B D b d
H0 : tarski_axioms.Cong A D a d
H : tarski_axioms.Cong B C b c
A,B,C,D,a,b,c,d : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong D C d c
+++++
finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C P Q : Tpoint) (_ : Definitions.BetS A P C) (_ : Definitions.BetS B Q C) (_ : and (not (Logic.eq A C)) (and (not (Logic.eq A B)) (and (not (Logic.eq C B)) (and (not (Definitions.BetS A C B)) (and (not (Definitions.BetS A B C)) (not (Definitions.BetS C A B))))))), ex (fun X : Tpoint => and (Definitions.BetS A X Q) (Definitions.BetS B X P))
+++++
intros;unfold Definitions.BetS in *;spliter.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.

*****
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P)))))
+++++
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].

*****
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P)))))
+++++
exists X.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.

*****
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert_diffs.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.

*****
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert (~ Bet A C B) by tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.

*****
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert (B<>C) by auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.

*****
H12 : not (Logic.eq B C)
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert (~ Bet A B C) by tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.

*****
H13 : not (Bet A B C)
H12 : not (Logic.eq B C)
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert (C<>A) by auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.

*****
H14 : not (Logic.eq C A)
H13 : not (Bet A B C)
H12 : not (Logic.eq B C)
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert (~ Bet C A B) by tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.

*****
H15 : not (Bet C A B)
H14 : not (Logic.eq C A)
H13 : not (Bet A B C)
H12 : not (Logic.eq B C)
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
assert (~ Bet B C A) by Between.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.

*****
H16 : not (Bet B C A)
H15 : not (Bet C A B)
H14 : not (Logic.eq C A)
H13 : not (Bet A B C)
H12 : not (Logic.eq B C)
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B X P) (and (not (Logic.eq B X)) (not (Logic.eq X P))))
+++++
repeat split;Between.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.

*****
H16 : not (Bet B C A)
H15 : not (Bet C A B)
H14 : not (Logic.eq C A)
H13 : not (Bet A B C)
H12 : not (Logic.eq B C)
H11 : not (Bet A C B)
HXb : Bet Q X A
HXa : Bet P X B
X : Tpoint
H6 : not (and (Bet C A B) (and (not (Logic.eq C A)) (not (Logic.eq A B))))
H5 : not (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C))))
H4 : not (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
H3 : not (Logic.eq C B)
H2 : not (Logic.eq A B)
H1 : not (Logic.eq A C)
H8 : not (Logic.eq Q C)
H7 : not (Logic.eq B Q)
H0 : Bet B Q C
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq A X)
+++++
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C P Q : Tpoint) (_ : Definitions.BetS A P C) (_ : Definitions.BetS B C Q) (_ : and (not (Logic.eq B Q)) (and (not (Logic.eq B A)) (and (not (Logic.eq Q A)) (and (not (Definitions.BetS B Q A)) (and (not (Definitions.BetS B A Q)) (not (Definitions.BetS Q B A))))))), ex (fun X : Tpoint => and (Definitions.BetS A X Q) (Definitions.BetS B P X))
+++++
intros;unfold Definitions.BetS in *;spliter.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.

*****
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (~ Bet B Q A) by tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.

*****
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (A<>Q) by auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.

*****
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (~ Bet B A Q) by tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.

*****
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (B<>A) by auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.

*****
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (Q<>B) by auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.

*****
H15 : not (Logic.eq Q B)
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (~ Bet Q B A) by tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.

*****
H16 : not (Bet Q B A)
H15 : not (Logic.eq Q B)
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (~ Bet A Q B) by finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.

*****
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H15 : not (Logic.eq Q B)
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
assert (Bet Q C B) by finish.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.

*****
H18 : Bet Q C B
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H15 : not (Logic.eq Q B)
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].

*****
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H18 : Bet Q C B
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H15 : not (Logic.eq Q B)
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X)))))
+++++
exists X.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.

*****
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H18 : Bet Q C B
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H15 : not (Logic.eq Q B)
H14 : not (Logic.eq B A)
H13 : not (Bet B A Q)
H12 : not (Logic.eq A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X))))
+++++
assert_diffs.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.

*****
H19 : not (Logic.eq A C)
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H13 : not (Bet B A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet A X Q) (and (not (Logic.eq A X)) (not (Logic.eq X Q)))) (and (Bet B P X) (and (not (Logic.eq B P)) (not (Logic.eq P X))))
+++++
repeat split;Between.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.

*****
H19 : not (Logic.eq A C)
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H13 : not (Bet B A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq A X)
+++++
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.

*****
H19 : not (Logic.eq A C)
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H13 : not (Bet B A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq X Q)
+++++
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.

*****
H19 : not (Logic.eq A C)
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H13 : not (Bet B A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B P)
+++++
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.

*****
H19 : not (Logic.eq A C)
HXb : Bet B P X
HXa : Bet Q X A
X : Tpoint
H17 : not (Bet A Q B)
H16 : not (Bet Q B A)
H13 : not (Bet B A Q)
H11 : not (Bet B Q A)
H6 : not (and (Bet Q B A) (and (not (Logic.eq Q B)) (not (Logic.eq B A))))
H5 : not (and (Bet B A Q) (and (not (Logic.eq B A)) (not (Logic.eq A Q))))
H4 : not (and (Bet B Q A) (and (not (Logic.eq B Q)) (not (Logic.eq Q A))))
H3 : not (Logic.eq Q A)
H2 : not (Logic.eq B A)
H1 : not (Logic.eq B Q)
H8 : not (Logic.eq C Q)
H7 : not (Logic.eq B C)
H0 : Bet B C Q
H10 : not (Logic.eq P C)
H9 : not (Logic.eq A P)
H : Bet A P C
A,B,C,P,Q : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P X)
+++++
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (Logic.eq A B)), ex (fun X : Tpoint => Definitions.BetS A B X)
+++++
intros.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-
intros.

*****
H : not (Logic.eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => Definitions.BetS A B X)
+++++
destruct (segment_construction A B A B) as [X [HXa HXb]].
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-
intros.
destruct (segment_construction A B A B) as [X [HXa HXb]].

*****
HXb : tarski_axioms.Cong B X A B
HXa : Bet A B X
X : Tpoint
H : not (Logic.eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => Definitions.BetS A B X)
+++++
exists X; unfold Definitions.BetS;assert_diffs;auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-
intros.
destruct (segment_construction A B A B) as [X [HXa HXb]].
exists X; unfold Definitions.BetS;assert_diffs;auto.

*****

*****

+++++
-
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-
intros.
destruct (segment_construction A B A B) as [X [HXa HXb]].
exists X; unfold Definitions.BetS;assert_diffs;auto.
-

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B : Tpoint) (_ : not (Logic.eq A B)), ex (fun X : Tcircle => CI X A A B)
+++++
intros.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-
intros.
destruct (segment_construction A B A B) as [X [HXa HXb]].
exists X; unfold Definitions.BetS;assert_diffs;auto.
-
intros.

*****
H : not (Logic.eq A B)
A,B : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tcircle => CI X A A B)
+++++
unfold CI;exists (A,A,B);auto.
-----
Global Instance Euclid_neutral_follows_from_Tarski_neutral : euclidean_neutral.
Proof.
eapply (Build_euclidean_neutral Tpoint Tcircle tarski_axioms.Cong Tarski_dev.Definitions.BetS tarski_axioms.PA tarski_axioms.PB tarski_axioms.PC CI).
-
intros;apply cong_transitivity with P Q;finish.
-
intro;finish.
-
intro;finish.
-
intros;apply (l2_11 A B C a b c); unfold Definitions.BetS in *;intuition.
-
intros.
destruct (eq_dec_points A B);intuition.
-
intros.
decompose [ex and] H0.
unfold CI in *.
spliter.
congruence.
-
assert (T:=lower_dim).
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
intro H;rewrite H in *;apply T;Between.
split.
unfold Definitions.BetS in *;intuition.
unfold Definitions.BetS in *;intuition.
-
intros; unfold Definitions.BetS; intro;spliter;treat_equalities;intuition.
-
intros;unfold Definitions.BetS in *; intros;spliter;finish.
-
intros;unfold Definitions.BetS in *; intros;spliter;try assumption;eBetween.
-
intros;unfold Definitions.BetS in *; intros;spliter.
assert (Bet A B C \\/ Bet A C B) by (apply l5_3 with D;auto).
assert (~ (Bet A C B /\\ A <> C /\\ B <> C)) by intuition.
assert (T3:=eq_dec_points A B).
assert (T4:=eq_dec_points A C).
assert (T5:=eq_dec_points B C).
tauto.
-
intros;intro;treat_equalities;finish.
-
intros.
assert (tarski_axioms.Cong C D c d) by (apply (five_segment A a B b C c D d); unfold Definitions.BetS in *;spliter;auto).
finish.
-
intros;unfold Definitions.BetS in *;spliter.
destruct (inner_pasch A B C P Q H H0) as [X [HXa HXb]].
exists X.
assert_diffs.
assert (~ Bet A C B) by tauto.
assert (B<>C) by auto.
assert (~ Bet A B C) by tauto.
assert (C<>A) by auto.
assert (~ Bet C A B) by tauto.
assert (~ Bet B C A) by Between.
repeat split;Between.
all:intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A B C) by ColR; unfold Definitions.Col in HCol; tauto.
-
intros;unfold Definitions.BetS in *;spliter.
assert (~ Bet B Q A) by tauto.
assert (A<>Q) by auto.
assert (~ Bet B A Q) by tauto.
assert (B<>A) by auto.
assert (Q<>B) by auto.
assert (~ Bet Q B A) by tauto.
assert (~ Bet A Q B) by finish.
assert (Bet Q C B) by finish.
destruct (outer_pasch Q A C B P H18 H) as [X [HXa HXb]].
exists X.
assert_diffs.
repeat split;Between.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A Q) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col B A X) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
intro;treat_equalities;assert_cols; assert (HCol:Definitions.Col A Q B) by ColR; unfold Definitions.Col in HCol;tauto.
-
intros.
destruct (segment_construction A B A B) as [X [HXa HXb]].
exists X; unfold Definitions.BetS;assert_diffs;auto.
-
intros.
unfold CI;exists (A,A,B);auto.

*****

*****

+++++
Defined.
-----
End Neutral.
-----
Section RulerAndCompass.
-----
Context `{TRC:Tarski_ruler_and_compass}.
-----
Lemma BetS_BetS : forall A B C,\n Definitions.BetS A B C <-> BetS A B C.
-----
Lemma BetS_BetS : forall A B C, Definitions.BetS A B C <-> BetS A B C.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (Definitions.BetS A B C) (BetS A B C)
+++++
Proof.
-----
Lemma BetS_BetS : forall A B C, Definitions.BetS A B C <-> BetS A B C.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (Definitions.BetS A B C) (BetS A B C)
+++++
intros.
-----
Lemma BetS_BetS : forall A B C, Definitions.BetS A B C <-> BetS A B C.
Proof.
intros.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Definitions.BetS A B C) (BetS A B C)
+++++
unfold BetS.
-----
Lemma BetS_BetS : forall A B C, Definitions.BetS A B C <-> BetS A B C.
Proof.
intros.
unfold BetS.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Definitions.BetS A B C) ((let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) A B C)
+++++
simpl.
-----
Lemma BetS_BetS : forall A B C, Definitions.BetS A B C <-> BetS A B C.
Proof.
intros.
unfold BetS.
simpl.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Definitions.BetS A B C) (Definitions.BetS A B C)
+++++
intuition.
-----
Lemma BetS_BetS : forall A B C, Definitions.BetS A B C <-> BetS A B C.
Proof.
intros.
unfold BetS.
simpl.
intuition.

*****

*****

+++++
Qed.
-----
Lemma Col_Col : forall A B C,\n Definitions.Col A B C <-> Col A B C.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (Definitions.Col A B C) (Col A B C)
+++++
Proof.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall A B C : Tpoint, iff (Definitions.Col A B C) (Col A B C)
+++++
intros.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (Definitions.Col A B C) (Col A B C)
+++++
unfold Definitions.Col.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (or (Bet A B C) (or (Bet B C A) (Bet C A B))) (Col A B C)
+++++
unfold Col.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (or (Bet A B C) (or (Bet B C A) (Bet C A B))) (or (eq A B) (or (eq A C) (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
+++++
unfold BetS.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (or (Bet A B C) (or (Bet B C A) (Bet C A B))) (or (eq A B) (or (eq A C) (or (eq B C) (or ((let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) B A C) (or ((let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) A B C) ((let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) A C B))))))
+++++
simpl.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (or (Bet A B C) (or (Bet B C A) (Bet C A B))) (or (eq A B) (or (eq A C) (or (eq B C) (or (Definitions.BetS B A C) (or (Definitions.BetS A B C) (Definitions.BetS A C B))))))
+++++
unfold Definitions.BetS.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (or (Bet A B C) (or (Bet B C A) (Bet C A B))) (or (eq A B) (or (eq A C) (or (eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))))
+++++
unfold eq.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (or (Bet A B C) (or (Bet B C A) (Bet C A B))) (or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))))
+++++
split.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet A B C) (or (Bet B C A) (Bet C A B)), or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
intros.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.

*****
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
destruct (eq_dec_points A B).
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).

*****
H0 : Logic.eq A B
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
left.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
left.

*****
H0 : Logic.eq A B
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq A B
+++++
auto.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).

*****
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
destruct (eq_dec_points A C).
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).

*****
H1 : Logic.eq A C
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
right.

*****
H1 : Logic.eq A C
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))
+++++
left.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
right.
left.

*****
H1 : Logic.eq A C
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq A C
+++++
auto.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).

*****
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
destruct (eq_dec_points B C).
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).

*****
H2 : Logic.eq B C
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
right.

*****
H2 : Logic.eq B C
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
right.
right.

*****
H2 : Logic.eq B C
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))
+++++
left.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
right.
right.
left.

*****
H2 : Logic.eq B C
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Logic.eq B C
+++++
auto.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).

*****
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
decompose [or] H.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.

*****
H3 : Bet A B C
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.

*****
H3 : Bet A B C
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.

*****
H3 : Bet A B C
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.

*****
H3 : Bet A B C
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.
right.

*****
H3 : Bet A B C
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
+++++
left.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.
right.
left.

*****
H3 : Bet A B C
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))
+++++
auto.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.

*****
H4 : Bet B C A
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.

*****
H4 : Bet B C A
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.

*****
H4 : Bet B C A
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.

*****
H4 : Bet B C A
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.
right.

*****
H4 : Bet B C A
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.
right.
right.

*****
H4 : Bet B C A
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.

*****
H4 : Bet C A B
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.

*****
H4 : Bet C A B
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.

*****
H4 : Bet C A B
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B))))))
+++++
right.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.

*****
H4 : Bet C A B
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))
+++++
left.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
destruct (eq_dec_points A B).
destruct (eq_dec_points A C).
destruct (eq_dec_points B C).
decompose [or] H.
right.
right.
right.
left.

*****
H4 : Bet C A B
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A C)
H0 : not (Logic.eq A B)
H : or (Bet A B C) (or (Bet B C A) (Bet C A B))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.

*****
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Logic.eq A B) (or (Logic.eq A C) (or (Logic.eq B C) (or (and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))) (or (and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))) (and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))))))), or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
intros.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.

*****
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
decompose [or] H.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.

*****
H0 : Logic.eq A B
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
subst.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.

*****
H : or (Logic.eq B B)\n (or (Logic.eq B C)\n (or (Logic.eq B C)\n (or\n (and (Bet B B C)\n (and (not (Logic.eq B B)) (not (Logic.eq B C))))\n (or\n (and (Bet B B C)\n (and (not (Logic.eq B B)) (not (Logic.eq B C))))\n (and (Bet B C B)\n (and (not (Logic.eq B C)) (not (Logic.eq C B))))))))
B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet B B C) (or (Bet B C B) (Bet C B B))
+++++
spliter.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.
spliter.

*****
H : or (Logic.eq B B)\n (or (Logic.eq B C)\n (or (Logic.eq B C)\n (or\n (and (Bet B B C)\n (and (not (Logic.eq B B)) (not (Logic.eq B C))))\n (or\n (and (Bet B B C)\n (and (not (Logic.eq B B)) (not (Logic.eq B C))))\n (and (Bet B C B)\n (and (not (Logic.eq B C)) (not (Logic.eq C B))))))))
B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet B B C) (or (Bet B C B) (Bet C B B))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.

*****
H1 : Logic.eq A C
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
subst.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.

*****
H : or (Logic.eq C B)\n (or (Logic.eq C C)\n (or (Logic.eq B C)\n (or\n (and (Bet B C C)\n (and (not (Logic.eq B C)) (not (Logic.eq C C))))\n (or\n (and (Bet C B C)\n (and (not (Logic.eq C B)) (not (Logic.eq B C))))\n (and (Bet C C B)\n (and (not (Logic.eq C C)) (not (Logic.eq C B))))))))
B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet C B C) (or (Bet B C C) (Bet C C B))
+++++
spliter.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.
spliter.

*****
H : or (Logic.eq C B)\n (or (Logic.eq C C)\n (or (Logic.eq B C)\n (or\n (and (Bet B C C)\n (and (not (Logic.eq B C)) (not (Logic.eq C C))))\n (or\n (and (Bet C B C)\n (and (not (Logic.eq C B)) (not (Logic.eq B C))))\n (and (Bet C C B)\n (and (not (Logic.eq C C)) (not (Logic.eq C B))))))))
B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet C B C) (or (Bet B C C) (Bet C C B))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.

*****
H0 : Logic.eq B C
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
subst.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.

*****
H : or (Logic.eq A C)\n (or (Logic.eq A C)\n (or (Logic.eq C C)\n (or\n (and (Bet C A C)\n (and (not (Logic.eq C A)) (not (Logic.eq A C))))\n (or\n (and (Bet A C C)\n (and (not (Logic.eq A C)) (not (Logic.eq C C))))\n (and (Bet A C C)\n (and (not (Logic.eq A C)) (not (Logic.eq C C))))))))
A,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A C C) (or (Bet C C A) (Bet C A C))
+++++
spliter.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.
spliter.

*****
H : or (Logic.eq A C)\n (or (Logic.eq A C)\n (or (Logic.eq C C)\n (or\n (and (Bet C A C)\n (and (not (Logic.eq C A)) (not (Logic.eq A C))))\n (or\n (and (Bet A C C)\n (and (not (Logic.eq A C)) (not (Logic.eq C C))))\n (and (Bet A C C)\n (and (not (Logic.eq A C)) (not (Logic.eq C C))))))))
A,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A C C) (or (Bet C C A) (Bet C A C))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.

*****
H1 : and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
subst.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.

*****
H1 : and (Bet B A C) (and (not (Logic.eq B A)) (not (Logic.eq A C)))
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
spliter.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.
spliter.

*****
H2 : not (Logic.eq A C)
H1 : not (Logic.eq B A)
H0 : Bet B A C
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.

*****
H0 : and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
subst.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.

*****
H0 : and (Bet A B C) (and (not (Logic.eq A B)) (not (Logic.eq B C)))
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
spliter.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.
spliter.

*****
H2 : not (Logic.eq B C)
H1 : not (Logic.eq A B)
H0 : Bet A B C
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.

*****
H0 : and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
subst.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.

*****
H0 : and (Bet A C B) (and (not (Logic.eq A C)) (not (Logic.eq C B)))
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
spliter.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.
intros.
decompose [or] H.
subst.
spliter.

*****
H2 : not (Logic.eq C B)
H1 : not (Logic.eq A C)
H0 : Bet A C B
H : or (Logic.eq A B)\n (or (Logic.eq A C)\n (or (Logic.eq B C)\n (or\n (and (Bet B A C)\n (and (not (Logic.eq B A)) (not (Logic.eq A C))))\n (or\n (and (Bet A B C)\n (and (not (Logic.eq A B)) (not (Logic.eq B C))))\n (and (Bet A C B)\n (and (not (Logic.eq A C)) (not (Logic.eq C B))))))))
A,B,C : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
finish.
-----
Lemma Col_Col : forall A B C, Definitions.Col A B C <-> Col A B C.
Proof.
intros.
unfold Definitions.Col.
unfold Col.
unfold BetS.
simpl.
unfold Definitions.BetS.
unfold eq.
split.

*****

*****

+++++
Qed.
-----
Lemma nCol_not_Col : forall A B C,\n nCol A B C -> ~ Col A B C.
-----
Lemma nCol_not_Col : forall A B C, nCol A B C -> ~ Col A B C.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Point) (_ : nCol A B C), not (Col A B C)
+++++
Proof.
-----
Lemma nCol_not_Col : forall A B C, nCol A B C -> ~ Col A B C.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Point) (_ : nCol A B C), not (Col A B C)
+++++
unfold nCol.
-----
Lemma nCol_not_Col : forall A B C, nCol A B C -> ~ Col A B C.
Proof.
unfold nCol.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Point) (_ : and (neq A B) (and (neq A C) (and (neq B C) (and (not (BetS A B C)) (and (not (BetS A C B)) (not (BetS B A C))))))), not (Col A B C)
+++++
unfold Col.
-----
Lemma nCol_not_Col : forall A B C, nCol A B C -> ~ Col A B C.
Proof.
unfold nCol.
unfold Col.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Point) (_ : and (neq A B) (and (neq A C) (and (neq B C) (and (not (BetS A B C)) (and (not (BetS A C B)) (not (BetS B A C))))))), not (or (eq A B) (or (eq A C) (or (eq B C) (or (BetS B A C) (or (BetS A B C) (BetS A C B))))))
+++++
intuition.
-----
Lemma nCol_not_Col : forall A B C, nCol A B C -> ~ Col A B C.
Proof.
unfold nCol.
unfold Col.
intuition.

*****

*****

+++++
Qed.
-----
Lemma InCirc_not_OnCirc: forall J A,\n InCirc J A -> ~ OnCirc J A.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (J : Tpoint) (A : Tcircle) (_ : InCirc J A), not (OnCirc J A)
+++++
Proof.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (J : Tpoint) (A : Tcircle) (_ : InCirc J A), not (OnCirc J A)
+++++
unfold InCirc in *.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (J : Tpoint) (A : Tcircle) (_ : let (p, B) := A in let (C, A0) := p in ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A0 B) (and (tarski_axioms.Cong C X A0 B) (Definitions.BetS X J Y)))))), not (OnCirc J A)
+++++
unfold OnCirc in *.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (J : Tpoint) (A : Tcircle) (_ : let (p, B) := A in let (C, A0) := p in ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A0 B) (and (tarski_axioms.Cong C X A0 B) (Definitions.BetS X J Y)))))), not (let (p, B) := A in let (X, A0) := p in tarski_axioms.Cong X J A0 B)
+++++
intros A J.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.

*****
J : Tcircle
A : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : let (p, B) := J in let (C, A0) := p in ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y A0 B) (and (tarski_axioms.Cong C X A0 B) (Definitions.BetS X A Y))))), not (let (p, B) := J in let (X, A0) := p in tarski_axioms.Cong X A A0 B)
+++++
destruct J as [[X C] D].
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].

*****
A,X,C,D : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : ex (fun X0 : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X0 X Y) (and (tarski_axioms.Cong X Y C D) (and (tarski_axioms.Cong X X0 C D) (Definitions.BetS X0 A Y))))), not (tarski_axioms.Cong X A C D)
+++++
intros.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.

*****
H : ex\n (fun X0 : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X0 X Y)\n (and (tarski_axioms.Cong X Y C D)\n (and (tarski_axioms.Cong X X0 C D) (Definitions.BetS X0 A Y)))))
A,X,C,D : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (tarski_axioms.Cong X A C D)
+++++
destruct H as [U [V HUV]].
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].

*****
HUV : and (Definitions.BetS U X V)\n (and (tarski_axioms.Cong X V C D)\n (and (tarski_axioms.Cong X U C D) (Definitions.BetS U A V)))
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (tarski_axioms.Cong X A C D)
+++++
spliter.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.

*****
H2 : Definitions.BetS U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H : Definitions.BetS U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (tarski_axioms.Cong X A C D)
+++++
intro.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.

*****
H3 : tarski_axioms.Cong X A C D
H2 : Definitions.BetS U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H : Definitions.BetS U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold Definitions.BetS in *.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.

*****
H3 : tarski_axioms.Cong X A C D
H2 : and (Bet U A V) (and (not (Logic.eq U A)) (not (Logic.eq A V)))
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H : and (Bet U X V) (and (not (Logic.eq U X)) (not (Logic.eq X V)))
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.

*****
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (tarski_axioms.Cong X U X V).
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).

*****
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong X U X V
+++++
eCong.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).

*****
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.

*****
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Midpoint X U V).
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).

*****
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint X U V
+++++
split.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
split.

*****
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet U X V
+++++
finish.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
split.

*****
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong U X X V
+++++
finish.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).

*****
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.

*****
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Midpoint X A V).
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.
assert (Midpoint X A V).

*****
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint X A V
+++++
apply (cong_col_mid A X V).
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.
assert (Midpoint X A V).
apply (cong_col_mid A X V).

*****
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq A V)
+++++
assumption.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.
assert (Midpoint X A V).
apply (cong_col_mid A X V).

*****
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A X V
+++++
ColR.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.
assert (Midpoint X A V).
apply (cong_col_mid A X V).

*****
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong A X X V
+++++
eCong.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.
assert (Midpoint X A V).

*****
H10 : Midpoint X A V
H9 : Midpoint X U V
H8 : tarski_axioms.Cong X U X V
H3 : tarski_axioms.Cong X A C D
H5 : not (Logic.eq A V)
H4 : not (Logic.eq U A)
H2 : Bet U A V
H1 : tarski_axioms.Cong X U C D
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H6 : not (Logic.eq U X)
H : Bet U X V
A,X,C,D,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).
idtac.
assert (Midpoint X U V).
idtac.
assert (Midpoint X A V).
treat_equalities.

*****
H8 : tarski_axioms.Cong X A X V
H9 : Midpoint X A V
H5 : not (Logic.eq A V)
H1 : tarski_axioms.Cong X A C D
H4 : not (Logic.eq A A)
H0 : tarski_axioms.Cong X V C D
H7 : not (Logic.eq X V)
H : Bet A X V
H6 : not (Logic.eq A X)
A,X,C,D,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma InCirc_not_OnCirc: forall J A, InCirc J A -> ~ OnCirc J A.
Proof.
unfold InCirc in *.
unfold OnCirc in *.
intros A J.
destruct J as [[X C] D].
intros.
destruct H as [U [V HUV]].
spliter.
intro.
unfold Definitions.BetS in *.
spliter.
assert (tarski_axioms.Cong X U X V).

*****

*****

+++++
Qed.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (K : Circle) (_ : euclidean_axioms.InCirc A K), InCirc A K
+++++
Proof.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (K : Circle) (_ : euclidean_axioms.InCirc A K), InCirc A K
+++++
intros.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.

*****
H : euclidean_axioms.InCirc A K
K : Circle
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A K
+++++
unfold euclidean_axioms.InCirc in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.

*****
H : ex\n (fun X : Point =>\n ex\n (fun Y : Point =>\n ex\n (fun U : Point =>\n ex\n (fun V : Point =>\n ex\n (fun W : Point =>\n and (euclidean_axioms.CI K U V W)\n (or (eq A U)\n (and (BetS U Y X)\n (and (Cong U X V W) (Cong U A U Y)))))))))
K : Circle
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A K
+++++
destruct K as [[C U] V].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].

*****
H : ex\n (fun X : Point =>\n ex\n (fun Y : Point =>\n ex\n (fun U0 : Point =>\n ex\n (fun V : Point =>\n ex\n (fun W : Point =>\n and (euclidean_axioms.CI (pair (pair C U)  V) U0 V W)\n (or (eq A U0)\n (and (BetS U0 Y X)\n (and (Cong U0 X V W) (Cong U0 A U0 Y)))))))))
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
unfold euclidean_axioms.InCirc in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.

*****
H : ex\n (fun X : Point =>\n ex\n (fun Y : Point =>\n ex\n (fun U0 : Point =>\n ex\n (fun V : Point =>\n ex\n (fun W : Point =>\n and (euclidean_axioms.CI (pair (pair C U)  V) U0 V W)\n (or (eq A U0)\n (and (BetS U0 Y X)\n (and (Cong U0 X V W) (Cong U0 A U0 Y)))))))))
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].

*****
HW2 : or (eq A C0) (and (BetS C0 Y X) (and (Cong C0 X V W) (Cong C0 A C0 Y)))
HW1 : euclidean_axioms.CI (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
destruct HW2.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.

*****
H : eq A C0
HW1 : euclidean_axioms.CI (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
unfold eq in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.

*****
H : Logic.eq A C0
HW1 : euclidean_axioms.CI (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
subst.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.

*****
HW1 : euclidean_axioms.CI (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc C0 (pair (pair C U) V)
+++++
unfold euclidean_axioms.CI in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.

*****
HW1 : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc C0 (pair (pair C U) V)
+++++
simpl in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
HW1 : CI (pair (pair C U)  V) C0 V W
C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y U V) (and (tarski_axioms.Cong C X U V) (Definitions.BetS X C0 Y)))))
+++++
unfold CI in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
HW1 : and (Logic.eq (pair (pair C U)  V) (pair (pair C0 V) W))\n (not (Logic.eq V W))
C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y U V) (and (tarski_axioms.Cong C X U V) (Definitions.BetS X C0 Y)))))
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C U)  V) (pair (pair C0 V) W)
C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y U V) (and (tarski_axioms.Cong C X U V) (Definitions.BetS X C0 Y)))))
+++++
inversion H.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H4 : Logic.eq  V W
H3 : Logic.eq U V
H2 : Logic.eq C C0
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C U)  V) (pair (pair C0 V) W)
C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X C0 Y)))))
+++++
subst.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X C0 Y)))))
+++++
destruct (eq_dec_points C0 V).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).

*****
H1 : Logic.eq C0 V
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X C0 Y)))))
+++++
subst.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.

*****
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
X,Y,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V X V W) (Definitions.BetS X V Y)))))
+++++
destruct (symmetric_point_construction W V) as [X0 HX].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].

*****
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
X,Y,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V X V W) (Definitions.BetS X V Y)))))
+++++
exists X0.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.

*****
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
X,Y,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS X0 V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V Y))))
+++++
exists W.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.

*****
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
X,Y,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 V W) (and (tarski_axioms.Cong V W V W) (and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W)))
+++++
assert_bets.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.

*****
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
X,Y,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 V W) (and (tarski_axioms.Cong V W V W) (and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W)))
+++++
assert_diffs.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 V W) (and (tarski_axioms.Cong V W V W) (and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W)))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X0 V W
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X0 V W
+++++
unfold Definitions.BetS.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
unfold Definitions.BetS.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 V W) (and (not (Logic.eq X0 V)) (not (Logic.eq V W)))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong V W V W) (and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong V W V W) (and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong V W V W
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W)
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.
finish.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong V X0 V W) (Definitions.BetS X0 V W)
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.
finish.
split.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong V X0 V W
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.
finish.
split.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X0 V W
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.
finish.
split.
finish.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X0 V W
+++++
unfold Definitions.BetS.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
subst.
destruct (symmetric_point_construction W V) as [X0 HX].
exists X0.
exists W.
assert_bets.
assert_diffs.
split.
finish.
split.
finish.
split.
finish.
unfold Definitions.BetS.

*****
H5 : not (Logic.eq V X0)
H2 : not (Logic.eq W X0)
H1 : Bet W V X0
HX : Midpoint V W X0
X0 : Tpoint
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair V V) W) (pair (pair V V) W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 V W) (and (not (Logic.eq X0 V)) (not (Logic.eq V W)))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).

*****
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X C0 Y)))))
+++++
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].

*****
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X C0 Y)))))
+++++
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].

*****
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X C0 Y)))))
+++++
exists X0.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.

*****
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS X0 C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 C0 Y))))
+++++
exists Y0.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.

*****
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 C0 Y0) (and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 C0 Y0)))
+++++
assert_bets.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.

*****
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 C0 Y0) (and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 C0 Y0)))
+++++
assert_diffs.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 C0 Y0) (and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 C0 Y0)))
+++++
unfold Definitions.BetS.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0)))) (and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0))))))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0)))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0)))))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0)))))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 Y0 V W
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0))))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.
split.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 X0 V W
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.
split.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0)))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.
split.
split.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X0 C0 Y0
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
unfold eq in *.
subst.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
destruct (eq_dec_points C0 V).
destruct (segment_construction_3 C0 V V W H1 H0) as [X0 [HX0 HX1]].
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
exists X0.
exists Y0.
assert_bets.
assert_diffs.
unfold Definitions.BetS.
split.
finish.
split.
split.
split.

*****
H7 : not (Logic.eq C0 Y0)
H4 : not (Logic.eq X0 Y0)
H3 : not (Logic.eq C0 X0)
H2 : Bet X0 C0 Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 V X0
X0 : Tpoint
H1 : not (Logic.eq C0 V)
H0 : not (Logic.eq V W)
H : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.

*****
H : and (BetS C0 Y X) (and (Cong C0 X V W) (Cong C0 A C0 Y))
HW1 : euclidean_axioms.CI (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.

*****
H1 : Cong C0 A C0 Y
H0 : Cong C0 X V W
H : BetS C0 Y X
HW1 : euclidean_axioms.CI (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
unfold euclidean_axioms.CI in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.

*****
H1 : Cong C0 A C0 Y
H0 : Cong C0 X V W
H : BetS C0 Y X
HW1 : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair C U)  V) C0 V W
X,Y,C0,V,W : Point
C,U,V : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc A (pair (pair C U) V)
+++++
simpl in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
HW1 : CI (pair (pair C U)  V) C0 V W
A,C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y U V) (and (tarski_axioms.Cong C X U V) (Definitions.BetS X A Y)))))
+++++
unfold CI in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
HW1 : and (Logic.eq (pair (pair C U)  V) (pair (pair C0 V) W))\n (not (Logic.eq V W))
A,C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y U V) (and (tarski_axioms.Cong C X U V) (Definitions.BetS X A Y)))))
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C U)  V) (pair (pair C0 V) W)
A,C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C Y) (and (tarski_axioms.Cong C Y U V) (and (tarski_axioms.Cong C X U V) (Definitions.BetS X A Y)))))
+++++
inversion H2.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.

*****
H7 : Logic.eq  V W
H6 : Logic.eq U V
H5 : Logic.eq C C0
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C U)  V) (pair (pair C0 V) W)
A,C,U,V,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
subst.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.

*****
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (C0 <> A).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).

*****
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq C0 A)
+++++
intro.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
intro.

*****
H4 : Logic.eq C0 A
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
intro.
treat_equalities.

*****
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 C0 X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold Definitions.BetS in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
intro.
treat_equalities.
unfold Definitions.BetS in *.

*****
H0 : tarski_axioms.Cong C0 X V W
H : and (Bet C0 C0 X) (and (not (Logic.eq C0 C0)) (not (Logic.eq C0 X)))
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
X,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).

*****
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].

*****
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
destruct (eq_dec_points A X0).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).

*****
H5 : Logic.eq A X0
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
treat_equalities.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.

*****
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert_diffs.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.

*****
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (HCong: tarski_axioms.Cong C0 Y C0 X).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).

*****
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 Y C0 X
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).

*****
HCong : tarski_axioms.Cong C0 Y C0 X
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).
idtac.

*****
HCong : tarski_axioms.Cong C0 Y C0 X
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
unfold Definitions.BetS in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).
idtac.
unfold Definitions.BetS in *.

*****
HCong : tarski_axioms.Cong C0 Y C0 X
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : and (Bet C0 Y X) (and (not (Logic.eq C0 Y)) (not (Logic.eq Y X)))
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).
idtac.
unfold Definitions.BetS in *.
spliter.

*****
HCong : tarski_axioms.Cong C0 Y C0 X
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H8 : not (Logic.eq Y X)
H7 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
assert (eq:= between_cong C0 X Y H HCong).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).
idtac.
unfold Definitions.BetS in *.
spliter.
assert (eq:= between_cong C0 X Y H HCong).

*****
eq : Logic.eq Y X
HCong : tarski_axioms.Cong C0 Y C0 X
H6 : not (Logic.eq C0 X)
H5 : not (Logic.eq C0 Y)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H8 : not (Logic.eq Y X)
H7 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
subst.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
treat_equalities.
assert_diffs.
assert (HCong: tarski_axioms.Cong C0 Y C0 X).
idtac.
unfold Definitions.BetS in *.
spliter.
assert (eq:= between_cong C0 X Y H HCong).
subst.

*****
HCong : tarski_axioms.Cong C0 X C0 X
H5,H6 : not (Logic.eq C0 X)
HX0 : Out C0 A A
HX1 : tarski_axioms.Cong C0 A V W
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 X
H0 : tarski_axioms.Cong C0 X V W
H : Bet C0 X X
H7 : not (Logic.eq C0 X)
H8 : not (Logic.eq X X)
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
intuition.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).

*****
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].

*****
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
destruct (eq_dec_points A Y0).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).

*****
H6 : Logic.eq A Y0
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
treat_equalities.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.

*****
HY0 : Midpoint C0 X0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
unfold Definitions.BetS in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.

*****
HY0 : Midpoint C0 X0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : and (Bet C0 Y X) (and (not (Logic.eq C0 Y)) (not (Logic.eq Y X)))
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.

*****
HY0 : Midpoint C0 X0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
assert_diffs.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.

*****
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
HY0 : Midpoint C0 X0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
unfold Midpoint in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.

*****
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
HY0 : and (Bet X0 C0 A) (tarski_axioms.Cong X0 C0 C0 A)
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.

*****
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).

*****
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 X0 C0 X
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
assert (HCong2: tarski_axioms.Cong C0 Y C0 X).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (HCong2: tarski_axioms.Cong C0 Y C0 X).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 Y C0 X
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (HCong2: tarski_axioms.Cong C0 Y C0 X).

*****
HCong2 : tarski_axioms.Cong C0 Y C0 X
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (HCong2: tarski_axioms.Cong C0 Y C0 X).
idtac.

*****
HCong2 : tarski_axioms.Cong C0 Y C0 X
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
assert (eq:= between_cong C0 X Y H HCong2).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (HCong2: tarski_axioms.Cong C0 Y C0 X).
idtac.
assert (eq:= between_cong C0 X Y H HCong2).

*****
eq : Logic.eq Y X
HCong2 : tarski_axioms.Cong C0 Y C0 X
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H7 : not (Logic.eq Y X)
H6 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
subst.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
treat_equalities.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Midpoint in *.
spliter.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (HCong2: tarski_axioms.Cong C0 Y C0 X).
idtac.
assert (eq:= between_cong C0 X Y H HCong2).
subst.

*****
HCong2 : tarski_axioms.Cong C0 X C0 X
HCong : tarski_axioms.Cong C0 X0 C0 X
H9 : not (Logic.eq C0 X0)
H8 : not (Logic.eq C0 X)
H11 : tarski_axioms.Cong X0 C0 C0 A
H10 : Bet X0 C0 A
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 X
H0 : tarski_axioms.Cong C0 X V W
H : Bet C0 X X
H6 : not (Logic.eq C0 X)
H7 : not (Logic.eq X X)
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (and (Bet X C0 Y) (and (not (Logic.eq X C0)) (not (Logic.eq C0 Y)))) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (and (Bet X A Y) (and (not (Logic.eq X A)) (not (Logic.eq A Y))))))))
+++++
intuition.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HX0 : Out C0 A X0
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
destruct HX0 as [HA [ HB [HC | HC]]].
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
exists X0.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS X0 C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 A Y))))
+++++
exists Y0.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 C0 Y0) (and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 A Y0)))
+++++
assert_diffs.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X0 C0 Y0) (and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 A Y0)))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X0 C0 Y0
+++++
unfold Definitions.BetS.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 C0 Y0) (and (not (Logic.eq X0 C0)) (not (Logic.eq C0 Y0)))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (Definitions.BetS X0 A Y0))
+++++
unfold Definitions.BetS.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 A Y0) (and (not (Logic.eq X0 A)) (not (Logic.eq A Y0)))))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 Y0 V W) (and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 A Y0) (and (not (Logic.eq X0 A)) (not (Logic.eq A Y0)))))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 Y0 V W
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong C0 X0 V W) (and (Bet X0 A Y0) (and (not (Logic.eq X0 A)) (not (Logic.eq A Y0))))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 X0 V W
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.

*****
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 A Y0) (and (not (Logic.eq X0 A)) (not (Logic.eq A Y0)))
+++++
assert_bets.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.
assert_bets.

*****
H9 : Bet X0 C0 Y0
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 A Y0) (and (not (Logic.eq X0 A)) (not (Logic.eq A Y0)))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.
assert_bets.
finish.

*****
H9 : Bet X0 C0 Y0
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X0 A Y0) (and (not (Logic.eq X0 A)) (not (Logic.eq A Y0)))
+++++
split.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.
assert_bets.
finish.
split.

*****
H9 : Bet X0 C0 Y0
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X0 A Y0
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.
assert_bets.
finish.
split.
finish.

*****
H9 : Bet X0 C0 Y0
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X0 A Y0
+++++
eBetween.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
exists X0.
exists Y0.
assert_diffs.
split.
unfold Definitions.BetS.
finish.
split.
split.
assert_bets.
finish.
split.

*****
H9 : Bet X0 C0 Y0
H11 : not (Logic.eq C0 Y0)
H10 : not (Logic.eq X0 Y0)
H8 : not (Logic.eq C0 X)
H7 : not (Logic.eq C0 Y)
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 A X0
HB : not (Logic.eq X0 C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq X0 A)) (not (Logic.eq A Y0))
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (Lt C0 Y C0 X).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 Y C0 X
+++++
unfold Definitions.BetS in *.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
unfold Definitions.BetS in *.

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : and (Bet C0 Y X) (and (not (Logic.eq C0 Y)) (not (Logic.eq Y X)))
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 Y C0 X
+++++
spliter.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
unfold Definitions.BetS in *.
spliter.

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H8 : not (Logic.eq Y X)
H7 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 Y C0 X
+++++
apply (bet__lt1213).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
unfold Definitions.BetS in *.
spliter.
apply (bet__lt1213).

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H8 : not (Logic.eq Y X)
H7 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq Y X)
+++++
auto.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
unfold Definitions.BetS in *.
spliter.
apply (bet__lt1213).

*****
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H8 : not (Logic.eq Y X)
H7 : not (Logic.eq C0 Y)
H : Bet C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C0 Y X
+++++
auto.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).

*****
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.

*****
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (Le C0 X0 C0 A).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).

*****
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C0 X0 C0 A
+++++
apply (bet__le1213).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
apply (bet__le1213).

*****
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C0 X0 A
+++++
auto.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).

*****
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.

*****
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).

*****
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 X0 C0 X
+++++
eCong.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (Lt C0 X C0 A).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 X C0 A
+++++
apply (cong2_lt__lt C0 X0 C0 A).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
apply (cong2_lt__lt C0 X0 C0 A).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 X0 C0 A
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
apply (cong2_lt__lt C0 X0 C0 A).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 X0 C0 X
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
apply (cong2_lt__lt C0 X0 C0 A).

*****
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 A C0 A
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).

*****
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.

*****
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (Lt C0 Y C0 A).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).

*****
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 Y C0 A
+++++
apply (le3456_lt__lt) with C0 X.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
apply (le3456_lt__lt) with C0 X.

*****
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C0 Y C0 X
+++++
auto using lt__le.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
apply (le3456_lt__lt) with C0 X.

*****
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C0 X C0 A
+++++
auto using lt__le.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).

*****
H10 : Lt C0 Y C0 A
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
idtac.

*****
H10 : Lt C0 Y C0 A
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
assert (Hc : tarski_axioms.Cong C0 Y C0 A).
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
idtac.
assert (Hc : tarski_axioms.Cong C0 Y C0 A).

*****
H10 : Lt C0 Y C0 A
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong C0 Y C0 A
+++++
finish.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
idtac.
assert (Hc : tarski_axioms.Cong C0 Y C0 A).

*****
Hc : tarski_axioms.Cong C0 Y C0 A
H10 : Lt C0 Y C0 A
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
idtac.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
idtac.
assert (Hc : tarski_axioms.Cong C0 Y C0 A).
idtac.

*****
Hc : tarski_axioms.Cong C0 Y C0 A
H10 : Lt C0 Y C0 A
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
apply cong__nlt in Hc.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H2.
subst.
assert (C0 <> A).
destruct (segment_construction_3 C0 A V W H4 H3) as [X0 [HX0 HX1]].
destruct (eq_dec_points A X0).
destruct (symmetric_point_construction X0 C0) as [Y0 HY0].
destruct (eq_dec_points A Y0).
destruct HX0 as [HA [ HB [HC | HC]]].
assert (Lt C0 Y C0 X).
idtac.
assert (Le C0 X0 C0 A).
idtac.
assert (HCong: tarski_axioms.Cong C0 X0 C0 X).
idtac.
assert (Lt C0 X C0 A).
idtac.
assert (Lt C0 Y C0 A).
idtac.
assert (Hc : tarski_axioms.Cong C0 Y C0 A).
idtac.
apply cong__nlt in Hc.

*****
Hc : not (Lt C0 Y C0 A)
H10 : Lt C0 Y C0 A
H9 : Lt C0 X C0 A
HCong : tarski_axioms.Cong C0 X0 C0 X
H8 : Le C0 X0 C0 A
H7 : Lt C0 Y C0 X
H6 : not (Logic.eq A Y0)
HY0 : Midpoint C0 X0 Y0
Y0 : Tpoint
H5 : not (Logic.eq A X0)
HX1 : tarski_axioms.Cong C0 X0 V W
HC : Bet C0 X0 A
HB : not (Logic.eq X0 C0)
HA : not (Logic.eq A C0)
X0 : Tpoint
H4 : not (Logic.eq C0 A)
H1 : tarski_axioms.Cong C0 A C0 Y
H0 : tarski_axioms.Cong C0 X V W
H : Definitions.BetS C0 Y X
H3 : not (Logic.eq V W)
H2 : Logic.eq (pair (pair C0 V) W) (pair (pair C0 V) W)
A,X,Y,C0,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X C0 Y) (and (tarski_axioms.Cong C0 Y V W) (and (tarski_axioms.Cong C0 X V W) (Definitions.BetS X A Y)))))
+++++
intuition.
-----
Lemma InCirc_InCirc : forall A K, euclidean_axioms.InCirc A K -> InCirc A K.
Proof.
intros.
unfold euclidean_axioms.InCirc in *.
destruct K as [[C U] V].
unfold euclidean_axioms.InCirc in *.
destruct H as [X [Y [C0 [V [W [HW1 HW2]]]]]].
destruct HW2.

*****

*****

+++++
Qed.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A P Q R : Tpoint) (_ : not (Logic.eq Q R)) (_ : OnCirc A (pair (pair P Q) R)), euclidean_axioms.OnCirc A (pair (pair P Q) R)
+++++
Proof.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A P Q R : Tpoint) (_ : not (Logic.eq Q R)) (_ : OnCirc A (pair (pair P Q) R)), euclidean_axioms.OnCirc A (pair (pair P Q) R)
+++++
intros.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.

*****
H0 : OnCirc A (pair (pair P Q) R)
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc A (pair (pair P Q) R)
+++++
unfold OnCirc in *.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc A (pair (pair P Q) R)
+++++
unfold euclidean_axioms.OnCirc.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => ex (fun U : Point => and (euclidean_axioms.CI (pair (pair P Q) R) U X Y) (Cong U A X Y))))
+++++
exists Q.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Point => ex (fun U : Point => and (euclidean_axioms.CI (pair (pair P Q) R) U Q Y) (Cong U A Q Y)))
+++++
exists R.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.
exists R.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun U : Point => and (euclidean_axioms.CI (pair (pair P Q) R) U Q R) (Cong U A Q R))
+++++
exists P.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.
exists R.
exists P.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (euclidean_axioms.CI (pair (pair P Q) R) P Q R) (Cong P A Q R)
+++++
unfold euclidean_axioms.CI.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.
exists R.
exists P.
unfold euclidean_axioms.CI.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and ((let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in CI) (pair (pair P Q) R) P Q R) (Cong P A Q R)
+++++
simpl.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.
exists R.
exists P.
unfold euclidean_axioms.CI.
simpl.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CI (pair (pair P Q) R) P Q R) (tarski_axioms.Cong P A Q R)
+++++
unfold CI.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.
exists R.
exists P.
unfold euclidean_axioms.CI.
simpl.
unfold CI.

*****
H0 : tarski_axioms.Cong P A Q R
H : not (Logic.eq Q R)
A,P,Q,R : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Logic.eq (pair (pair P Q) R) (pair (pair P Q) R)) (not (Logic.eq Q R))) (tarski_axioms.Cong P A Q R)
+++++
finish.
-----
Lemma OnCirc_OnCirc : forall A P Q R, Q<>R -> OnCirc A (P,Q,R) -> euclidean_axioms.OnCirc A (P,Q,R).
Proof.
intros.
unfold OnCirc in *.
unfold euclidean_axioms.OnCirc.
exists Q.
exists R.
exists P.
unfold euclidean_axioms.CI.
simpl.
unfold CI.
finish.

*****

*****

+++++
Qed.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (K : Circle) (_ : euclidean_axioms.OnCirc A K), OnCirc A K
+++++
Proof.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (K : Circle) (_ : euclidean_axioms.OnCirc A K), OnCirc A K
+++++
intros.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.

*****
H : euclidean_axioms.OnCirc A K
K : Circle
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc A K
+++++
unfold OnCirc.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.

*****
H : euclidean_axioms.OnCirc A K
K : Circle
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
let (p, B) := K in let (X, A0) := p in tarski_axioms.Cong X A A0 B
+++++
destruct K.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.

*****
H : euclidean_axioms.OnCirc A (pair p t)
t : Tpoint
p : prod Tpoint Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
let (X, A0) := p in tarski_axioms.Cong X A A0 t
+++++
destruct p.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.

*****
H : euclidean_axioms.OnCirc A (pair (pair t0 t1) t)
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
unfold euclidean_axioms.OnCirc in *.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.

*****
H : ex\n (fun X : Point =>\n ex\n (fun Y : Point =>\n ex\n (fun U : Point =>\n and (euclidean_axioms.CI (pair (pair t0 t1) t) U X Y)\n (Cong U A X Y))))
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
destruct H as [X [Y [U HXY]]].
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].

*****
HXY : and (euclidean_axioms.CI (pair (pair t0 t1) t) U X Y) (Cong U A X Y)
X,Y,U : Point
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
spliter.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.

*****
H0 : Cong U A X Y
H : euclidean_axioms.CI (pair (pair t0 t1) t) U X Y
X,Y,U : Point
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
unfold euclidean_axioms.CI in *.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.

*****
H0 : Cong U A X Y
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair t0 t1) t) U X Y
X,Y,U : Point
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
simpl in *.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H0 : tarski_axioms.Cong U A X Y
H : CI (pair (pair t0 t1) t) U X Y
A,t0,t1,t,X,Y,U : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
unfold CI in *.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H0 : tarski_axioms.Cong U A X Y
H : and (Logic.eq (pair (pair t0 t1) t) (pair (pair U X) Y))\n (not (Logic.eq X Y))
A,t0,t1,t,X,Y,U : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
spliter.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H0 : tarski_axioms.Cong U A X Y
H1 : not (Logic.eq X Y)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair U X) Y)
A,t0,t1,t,X,Y,U : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong t0 A t1 t
+++++
inversion H.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H5 : Logic.eq t Y
H4 : Logic.eq t1 X
H3 : Logic.eq t0 U
H0 : tarski_axioms.Cong U A X Y
H1 : not (Logic.eq X Y)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair U X) Y)
A,t0,t1,t,X,Y,U : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong U A X Y
+++++
subst.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H0 : tarski_axioms.Cong U A X Y
H1 : not (Logic.eq X Y)
H : Logic.eq (pair (pair U X) Y) (pair (pair U X) Y)
A,X,Y,U : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong U A X Y
+++++
finish.
-----
Lemma eOnCirc_OnCirc : forall A K, euclidean_axioms.OnCirc A K -> OnCirc A K.
Proof.
intros.
unfold OnCirc.
destruct K.
destruct p.
unfold euclidean_axioms.OnCirc in *.
destruct H as [X [Y [U HXY]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
finish.

*****

*****

+++++
Qed.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (K : Circle) (_ : euclidean_axioms.OutCirc A K), OutCirc A K
+++++
Proof.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A : Point) (K : Circle) (_ : euclidean_axioms.OutCirc A K), OutCirc A K
+++++
intros.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.

*****
H : euclidean_axioms.OutCirc A K
K : Circle
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A K
+++++
destruct K.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.

*****
H : euclidean_axioms.OutCirc A (pair p t)
t : Tpoint
p : prod Tpoint Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A (pair p t)
+++++
destruct p.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.

*****
H : euclidean_axioms.OutCirc A (pair (pair t0 t1) t)
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A (pair (pair t0 t1) t)
+++++
unfold euclidean_axioms.OutCirc in *.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.

*****
H : ex\n (fun X : Point =>\n ex\n (fun U : Point =>\n ex\n (fun V : Point =>\n ex\n (fun W : Point =>\n and (euclidean_axioms.CI (pair (pair t0 t1) t) U V W)\n (and (BetS U X A) (Cong U X V W))))))
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A (pair (pair t0 t1) t)
+++++
destruct H as [X [Y [U [V HV]]]].
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].

*****
HV : and (euclidean_axioms.CI (pair (pair t0 t1) t) Y U V)\n (and (BetS Y X A) (Cong Y X U V))
X,Y,U,V : Point
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A (pair (pair t0 t1) t)
+++++
spliter.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.

*****
H1 : Cong Y X U V
H0 : BetS Y X A
H : euclidean_axioms.CI (pair (pair t0 t1) t) Y U V
X,Y,U,V : Point
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A (pair (pair t0 t1) t)
+++++
unfold euclidean_axioms.CI in *.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.

*****
H1 : Cong Y X U V
H0 : BetS Y X A
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair t0 t1) t) Y U V
X,Y,U,V : Point
t0,t1,t : Tpoint
A : Point
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc A (pair (pair t0 t1) t)
+++++
simpl in *.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H1 : tarski_axioms.Cong Y X U V
H0 : Definitions.BetS Y X A
H : CI (pair (pair t0 t1) t) Y U V
A,t0,t1,t,X,Y,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS t0 X A) (tarski_axioms.Cong t0 X t1 t))
+++++
unfold CI in *.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H1 : tarski_axioms.Cong Y X U V
H0 : Definitions.BetS Y X A
H : and (Logic.eq (pair (pair t0 t1) t) (pair (pair Y U) V))\n (not (Logic.eq U V))
A,t0,t1,t,X,Y,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS t0 X A) (tarski_axioms.Cong t0 X t1 t))
+++++
spliter.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H1 : tarski_axioms.Cong Y X U V
H0 : Definitions.BetS Y X A
H2 : not (Logic.eq U V)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair Y U) V)
A,t0,t1,t,X,Y,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS t0 X A) (tarski_axioms.Cong t0 X t1 t))
+++++
inversion H.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H6 : Logic.eq t V
H5 : Logic.eq t1 U
H4 : Logic.eq t0 Y
H1 : tarski_axioms.Cong Y X U V
H0 : Definitions.BetS Y X A
H2 : not (Logic.eq U V)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair Y U) V)
A,t0,t1,t,X,Y,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS Y X A) (tarski_axioms.Cong Y X U V))
+++++
subst.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H1 : tarski_axioms.Cong Y X U V
H0 : Definitions.BetS Y X A
H2 : not (Logic.eq U V)
H : Logic.eq (pair (pair Y U) V) (pair (pair Y U) V)
A,X,Y,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Definitions.BetS Y X A) (tarski_axioms.Cong Y X U V))
+++++
exists X.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
exists X.

*****
H1 : tarski_axioms.Cong Y X U V
H0 : Definitions.BetS Y X A
H2 : not (Logic.eq U V)
H : Logic.eq (pair (pair Y U) V) (pair (pair Y U) V)
A,X,Y,U,V : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS Y X A) (tarski_axioms.Cong Y X U V)
+++++
finish.
-----
Lemma eOutCirc_OutCirc : forall A K, euclidean_axioms.OutCirc A K -> OutCirc A K.
Proof.
intros.
destruct K.
destruct p.
unfold euclidean_axioms.OutCirc in *.
destruct H as [X [Y [U [V HV]]]].
spliter.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.
exists X.
finish.

*****

*****

+++++
Qed.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (U V W : Tpoint) (_ : not (Logic.eq V W)), InCirc U (pair (pair U V) W)
+++++
Proof.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (U V W : Tpoint) (_ : not (Logic.eq V W)), InCirc U (pair (pair U V) W)
+++++
intros.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.

*****
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc U (pair (pair U V) W)
+++++
unfold InCirc.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.

*****
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
destruct (eq_dec_points U V).
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).

*****
H0 : Logic.eq U V
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
subst.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.

*****
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V X V W) (Definitions.BetS X V Y)))))
+++++
exists W.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.

*****
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS W V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V W V W) (Definitions.BetS W V Y))))
+++++
destruct (symmetric_point_construction W V) as [Y HY].
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.
destruct (symmetric_point_construction W V) as [Y HY].

*****
HY : Midpoint V W Y
Y : Tpoint
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS W V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V W V W) (Definitions.BetS W V Y))))
+++++
exists Y.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.
destruct (symmetric_point_construction W V) as [Y HY].
exists Y.

*****
HY : Midpoint V W Y
Y : Tpoint
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS W V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V W V W) (Definitions.BetS W V Y)))
+++++
assert_diffs.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.
destruct (symmetric_point_construction W V) as [Y HY].
exists Y.
assert_diffs.

*****
H2 : not (Logic.eq V Y)
H1 : not (Logic.eq W Y)
HY : Midpoint V W Y
Y : Tpoint
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS W V Y) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V W V W) (Definitions.BetS W V Y)))
+++++
unfold Definitions.BetS.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.
destruct (symmetric_point_construction W V) as [Y HY].
exists Y.
assert_diffs.
unfold Definitions.BetS.

*****
H2 : not (Logic.eq V Y)
H1 : not (Logic.eq W Y)
HY : Midpoint V W Y
Y : Tpoint
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (and (Bet W V Y) (and (not (Logic.eq W V)) (not (Logic.eq V Y)))) (and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V W V W) (and (Bet W V Y) (and (not (Logic.eq W V)) (not (Logic.eq V Y))))))
+++++
split.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.
destruct (symmetric_point_construction W V) as [Y HY].
exists Y.
assert_diffs.
unfold Definitions.BetS.
split.

*****
H2 : not (Logic.eq V Y)
H1 : not (Logic.eq W Y)
HY : Midpoint V W Y
Y : Tpoint
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet W V Y) (and (not (Logic.eq W V)) (not (Logic.eq V Y)))
+++++
finish.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
subst.
exists W.
destruct (symmetric_point_construction W V) as [Y HY].
exists Y.
assert_diffs.
unfold Definitions.BetS.
split.

*****
H2 : not (Logic.eq V Y)
H1 : not (Logic.eq W Y)
HY : Midpoint V W Y
Y : Tpoint
H : not (Logic.eq V W)
V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong V Y V W) (and (tarski_axioms.Cong V W V W) (and (Bet W V Y) (and (not (Logic.eq W V)) (not (Logic.eq V Y)))))
+++++
finish.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).

*****
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
destruct (segment_construction_3 U V V W H0 H) as [X HX].
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].

*****
HX : and (Out U V X) (tarski_axioms.Cong U X V W)
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
destruct (symmetric_point_construction X U) as [Y HY].
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].

*****
HY : Midpoint U X Y
Y : Tpoint
HX : and (Out U V X) (tarski_axioms.Cong U X V W)
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
spliter.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.

*****
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
assert_diffs.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.

*****
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
assert_bets.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))))
+++++
exists X.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y))))
+++++
exists Y.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Definitions.BetS X U Y) (and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)))
+++++
split.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X U Y
+++++
unfold Definitions.BetS.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.
unfold Definitions.BetS.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X U Y) (and (not (Logic.eq X U)) (not (Logic.eq U Y)))
+++++
finish.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong U Y V W) (and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y))
+++++
split.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.
split.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong U Y V W
+++++
eCong.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.
split.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (tarski_axioms.Cong U X V W) (Definitions.BetS X U Y)
+++++
split.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.
split.
split.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong U X V W
+++++
eCong.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.
split.
split.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X U Y
+++++
unfold Definitions.BetS.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).
destruct (segment_construction_3 U V V W H0 H) as [X HX].
destruct (symmetric_point_construction X U) as [Y HY].
spliter.
assert_diffs.
assert_bets.
exists X.
exists Y.
split.
split.
split.
unfold Definitions.BetS.

*****
H4 : Bet X U Y
H6 : not (Logic.eq U Y)
H5 : not (Logic.eq X Y)
H3 : not (Logic.eq U X)
HY : Midpoint U X Y
Y : Tpoint
H2 : tarski_axioms.Cong U X V W
H1 : Out U V X
X : Tpoint
H0 : not (Logic.eq U V)
H : not (Logic.eq V W)
U,V,W : Tpoint
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet X U Y) (and (not (Logic.eq X U)) (not (Logic.eq U Y)))
+++++
finish.
-----
Lemma InCircCenter: forall U V W, V<>W -> InCirc U (U, V, W).
Proof.
intros.
unfold InCirc.
destruct (eq_dec_points U V).

*****

*****

+++++
Qed.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass :\n  euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral
+++++
Proof.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral
+++++
assert (cc : circle_circle).
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
circle_circle
+++++
cut (circle_circle_axiom).
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_axiom, circle_circle
+++++
apply equivalent_variants_of_circle_circle.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).
apply equivalent_variants_of_circle_circle.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In circle_circle (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).
apply equivalent_variants_of_circle_circle.
simpl.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq circle_circle circle_circle) (or (Logic.eq circle_circle_two circle_circle) (or (Logic.eq circle_circle_bis circle_circle) (or (Logic.eq circle_circle_axiom circle_circle) (or (Logic.eq euclid_s_prop_1_22 circle_circle) False))))
+++++
tauto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).
apply equivalent_variants_of_circle_circle.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In circle_circle_axiom (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).
apply equivalent_variants_of_circle_circle.
simpl.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq circle_circle circle_circle_axiom) (or (Logic.eq circle_circle_two circle_circle_axiom) (or (Logic.eq circle_circle_bis circle_circle_axiom) (or (Logic.eq circle_circle_axiom circle_circle_axiom) (or (Logic.eq euclid_s_prop_1_22 circle_circle_axiom) False))))
+++++
tauto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
circle_circle_axiom
+++++
unfold circle_circle_axiom.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
cut (circle_circle_axiom).
unfold circle_circle_axiom.

*****
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D B' D' : Tpoint) (_ : tarski_axioms.Cong A B' A B) (_ : tarski_axioms.Cong C D' C D) (_ : Bet A D' B) (_ : Bet C B' D), ex (fun Z : Tpoint => and (tarski_axioms.Cong A Z A B) (tarski_axioms.Cong C Z C D))
+++++
exact circle_circle_continuity.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).

*****
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.

*****
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C : Point) (K : Circle) (P Q : Point) (_ : euclidean_axioms.CI K C P Q) (_ : euclidean_axioms.InCirc B K) (_ : neq A B), ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
intros.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.

*****
H1 : neq A B
H0 : euclidean_axioms.InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
apply InCirc_InCirc in H0.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.

*****
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].

*****
HXY : and (Definitions.Col A B X)\n (and (Definitions.Col A B Y)\n (and (OnCirc X K) (and (OnCirc Y K) (Definitions.BetS X B Y))))
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.

*****
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
destruct (bet_dec A B Y).
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
exists X.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y)))))
+++++
exists Y.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B X
+++++
apply (Col_Col A B X).
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
apply (Col_Col A B X).

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B X
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y)))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B Y
+++++
unfold BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
(let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) A B Y
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS A B Y
+++++
unfold Definitions.BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B Y) (and (not (Logic.eq A B)) (not (Logic.eq B Y)))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B Y
+++++
assumption.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq A B)) (not (Logic.eq B Y))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq A B)
+++++
assumption.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Y)
+++++
unfold Definitions.BetS in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
split.
unfold Definitions.BetS in *.

*****
H7 : Bet A B Y
H6 : and (Bet X B Y) (and (not (Logic.eq X B)) (not (Logic.eq B Y)))
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Y)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
split.
unfold Definitions.BetS in *.
spliter.

*****
H7 : Bet A B Y
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq B Y)
+++++
finish.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X K
+++++
destruct K as [p q].
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair p q)
H4 : OnCirc X (pair p q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair p q)
H : euclidean_axioms.CI (pair p q) C P Q
P,Q : Point
q : Tpoint
p : prod Tpoint Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair p q)
+++++
destruct p.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t t0) q)
+++++
apply OnCirc_OnCirc.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold euclidean_axioms.CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
simpl in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : CI (pair (pair t t0) q) C P Q
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : and (Logic.eq (pair (pair t t0) q) (pair (pair C P) Q))\n (not (Logic.eq P Q))
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
inversion H.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H12 : Logic.eq q Q
H11 : Logic.eq t0 P
H10 : Logic.eq t C
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
subst.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H4 : tarski_axioms.Cong C X P Q
H5 : tarski_axioms.Cong C Y P Q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y P Q)\n (and (tarski_axioms.Cong C X P Q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc X (pair (pair t t0) q)
+++++
assumption.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (euclidean_axioms.OnCirc Y K) (BetS X B Y)
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc Y K
+++++
destruct K as [p q].
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair p q)
H4 : OnCirc X (pair p q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair p q)
H : euclidean_axioms.CI (pair p q) C P Q
P,Q : Point
q : Tpoint
p : prod Tpoint Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc Y (pair p q)
+++++
destruct p.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc Y (pair (pair t t0) q)
+++++
apply OnCirc_OnCirc.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold euclidean_axioms.CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
simpl in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : CI (pair (pair t t0) q) C P Q
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : and (Logic.eq (pair (pair t t0) q) (pair (pair C P) Q))\n (not (Logic.eq P Q))
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
inversion H.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H12 : Logic.eq q Q
H11 : Logic.eq t0 P
H10 : Logic.eq t C
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
subst.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H4 : tarski_axioms.Cong C X P Q
H5 : tarski_axioms.Cong C Y P Q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y P Q)\n (and (tarski_axioms.Cong C X P Q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Y (pair (pair t t0) q)
+++++
assumption.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS X B Y
+++++
unfold BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
unfold BetS.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
(let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) X B Y
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists X.
exists Y.
split.
split.
split.
split.
unfold BetS.
simpl.

*****
H7 : Bet A B Y
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS X B Y
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => ex (fun Y : Point => and (Col A B X) (and (BetS A B Y) (and (euclidean_axioms.OnCirc X K) (and (euclidean_axioms.OnCirc Y K) (BetS X B Y))))))
+++++
exists Y.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y0 : Point => and (Col A B Y) (and (BetS A B Y0) (and (euclidean_axioms.OnCirc Y K) (and (euclidean_axioms.OnCirc Y0 K) (BetS Y B Y0)))))
+++++
exists X.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A B Y) (and (BetS A B X) (and (euclidean_axioms.OnCirc Y K) (and (euclidean_axioms.OnCirc X K) (BetS Y B X))))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B Y
+++++
apply (Col_Col A B Y).
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
apply (Col_Col A B Y).

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.Col A B Y
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (BetS A B X) (and (euclidean_axioms.OnCirc Y K) (and (euclidean_axioms.OnCirc X K) (BetS Y B X)))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
unfold Definitions.BetS in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.

*****
H7 : not (Bet A B Y)
H6 : and (Bet X B Y) (and (not (Logic.eq X B)) (not (Logic.eq B Y)))
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.

*****
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
assert_diffs.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
unfold Definitions.Col in H2.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : or (Bet A B X) (or (Bet B X A) (Bet X A B))
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
destruct H2.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
unfold BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
unfold BetS.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
(let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) A B X
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
unfold BetS.
simpl.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS A B X
+++++
unfold Definitions.BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B X) (and (not (Logic.eq A B)) (not (Logic.eq B X)))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B X
+++++
finish.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq A B)) (not (Logic.eq B X))
+++++
finish.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : or (Bet B X A) (Bet X A B)
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
destruct H2.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet B X A
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
exfalso.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
exfalso.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet B X A
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H7.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
exfalso.
apply H7.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet B X A
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B Y
+++++
eBetween.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS A B X
+++++
unfold BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
(let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) A B X
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS A B X
+++++
unfold Definitions.BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B X) (and (not (Logic.eq A B)) (not (Logic.eq B X)))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B X
+++++
finish.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
finish.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B X
+++++
exfalso.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
finish.
exfalso.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H7.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.
finish.
exfalso.
apply H7.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B Y
+++++
eBetween.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
unfold Definitions.BetS in *.
spliter.
assert_diffs.
unfold Definitions.Col in H2.
destruct H2.
destruct H2.
unfold BetS.
simpl.
unfold Definitions.BetS.
split.

*****
H11 : not (Logic.eq A B)
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Bet X A B
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Logic.eq A B)) (not (Logic.eq B X))
+++++
finish.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (euclidean_axioms.OnCirc Y K) (and (euclidean_axioms.OnCirc X K) (BetS Y B X))
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc Y K
+++++
destruct K as [p q].
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair p q)
H4 : OnCirc X (pair p q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair p q)
H : euclidean_axioms.CI (pair p q) C P Q
P,Q : Point
q : Tpoint
p : prod Tpoint Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc Y (pair p q)
+++++
destruct p.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc Y (pair (pair t t0) q)
+++++
apply OnCirc_OnCirc.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold euclidean_axioms.CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
simpl in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : CI (pair (pair t t0) q) C P Q
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : and (Logic.eq (pair (pair t t0) q) (pair (pair C P) Q))\n (not (Logic.eq P Q))
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
inversion H.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H12 : Logic.eq q Q
H11 : Logic.eq t0 P
H10 : Logic.eq t C
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
subst.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H4 : tarski_axioms.Cong C X P Q
H5 : tarski_axioms.Cong C Y P Q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y P Q)\n (and (tarski_axioms.Cong C X P Q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Y (pair (pair t t0) q)
+++++
assumption.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (euclidean_axioms.OnCirc X K) (BetS Y B X)
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X K
+++++
destruct K as [p q].
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair p q)
H4 : OnCirc X (pair p q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair p q)
H : euclidean_axioms.CI (pair p q) C P Q
P,Q : Point
q : Tpoint
p : prod Tpoint Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair p q)
+++++
destruct p.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t t0) q)
+++++
apply OnCirc_OnCirc.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold euclidean_axioms.CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return\n (forall (_ : Circle) (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n CI) (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
simpl in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : CI (pair (pair t t0) q) C P Q
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H : and (Logic.eq (pair (pair t t0) q) (pair (pair C P) Q))\n (not (Logic.eq P Q))
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq t0 q)
+++++
inversion H.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.

*****
H12 : Logic.eq q Q
H11 : Logic.eq t0 P
H10 : Logic.eq t C
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : tarski_axioms.Cong t Y t0 q
H4 : tarski_axioms.Cong t X t0 q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X t Y)\n (and (tarski_axioms.Cong t Y t0 q)\n (and (tarski_axioms.Cong t X t0 q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair t t0) q) (pair (pair C P) Q)
A,B,C,t,t0,q,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
subst.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.
unfold euclidean_axioms.CI in *.
simpl in *.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H4 : tarski_axioms.Cong C X P Q
H5 : tarski_axioms.Cong C Y P Q
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n and (Definitions.BetS X C Y)\n (and (tarski_axioms.Cong C Y P Q)\n (and (tarski_axioms.Cong C X P Q) (Definitions.BetS X B Y)))))
H8 : not (Logic.eq P Q)
H : Logic.eq (pair (pair C P) Q) (pair (pair C P) Q)
A,B,C,P,Q : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq P Q)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
destruct K as [p q].
destruct p.
apply OnCirc_OnCirc.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y (pair (pair t t0) q)
H4 : OnCirc X (pair (pair t t0) q)
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B (pair (pair t t0) q)
H : euclidean_axioms.CI (pair (pair t t0) q) C P Q
P,Q : Point
t,t0,q : Tpoint
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc X (pair (pair t t0) q)
+++++
assumption.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS Y B X
+++++
unfold BetS.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
unfold BetS.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
(let (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as euclidean_neutral return (forall (_ : Point) (_ : Point) (_ : Point), Prop) := Euclid_neutral_follows_from_Tarski_neutral in BetS) Y B X
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
unfold BetS.
simpl.

*****
H7 : not (Bet A B Y)
H6 : Definitions.BetS X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS Y B X
+++++
unfold Definitions.BetS in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS in *.

*****
H7 : not (Bet A B Y)
H6 : and (Bet X B Y) (and (not (Logic.eq X B)) (not (Logic.eq B Y)))
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet Y B X) (and (not (Logic.eq Y B)) (not (Logic.eq B X)))
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
intros.
apply InCirc_InCirc in H0.
destruct (circle_line cc A B C K P Q H H0 H1) as [X [Y HXY]].
spliter.
destruct (bet_dec A B Y).
exists Y.
exists X.
split.
split.
split.
split.
unfold BetS.
simpl.
unfold Definitions.BetS in *.
spliter.

*****
H7 : not (Bet A B Y)
H9 : not (Logic.eq B Y)
H8 : not (Logic.eq X B)
H6 : Bet X B Y
H5 : OnCirc Y K
H4 : OnCirc X K
H3 : Definitions.Col A B Y
H2 : Definitions.Col A B X
X,Y : Tpoint
H1 : neq A B
H0 : InCirc B K
H : euclidean_axioms.CI K C P Q
P,Q : Point
K : Circle
A,B,C : Point
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet Y B X) (and (not (Logic.eq Y B)) (not (Logic.eq B X)))
+++++
finish.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.

*****
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C D F G : Point) (J K : Circle) (P Q R S : Point) (_ : euclidean_axioms.CI J C R S) (_ : euclidean_axioms.InCirc P J) (_ : euclidean_axioms.OutCirc Q J) (_ : euclidean_axioms.CI K D F G) (_ : euclidean_axioms.OnCirc P K) (_ : euclidean_axioms.OnCirc Q K), ex (fun X : Point => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
simpl.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.

*****
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C D F G : Tpoint) (J K : Tcircle) (P Q R S : Tpoint) (_ : CI J C R S) (_ : euclidean_axioms.InCirc P J) (_ : euclidean_axioms.OutCirc Q J) (_ : CI K D F G) (_ : euclidean_axioms.OnCirc P K) (_ : euclidean_axioms.OnCirc Q K), ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
intros.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.

*****
H4 : euclidean_axioms.OnCirc Q K
H3 : euclidean_axioms.OnCirc P K
H2 : CI K D F G
H1 : euclidean_axioms.OutCirc Q J
H0 : euclidean_axioms.InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
apply InCirc_InCirc in H0.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.

*****
H4 : euclidean_axioms.OnCirc Q K
H3 : euclidean_axioms.OnCirc P K
H2 : CI K D F G
H1 : euclidean_axioms.OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
apply eOnCirc_OnCirc in H3.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.

*****
H4 : euclidean_axioms.OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : euclidean_axioms.OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
apply eOnCirc_OnCirc in H4.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : euclidean_axioms.OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
apply eOutCirc_OutCirc in H1.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCirc P J
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCirc Q J
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CI K D F G
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc P K
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].

*****
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc Q K
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].

*****
HX : and (OnCirc X J) (OnCirc X K)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.

*****
HX : and (OnCirc X J) (OnCirc X K)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.

*****
H6 : OnCirc X K
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K))
+++++
exists X.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.

*****
H6 : OnCirc X K
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (euclidean_axioms.OnCirc X J) (euclidean_axioms.OnCirc X K)
+++++
split.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.

*****
H6 : OnCirc X K
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X J
+++++
destruct J.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.

*****
H6 : OnCirc X K
H5 : OnCirc X (pair p t)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q (pair p t)
H0 : InCirc P (pair p t)
H : CI (pair p t) C R S
P,Q,R,S : Tpoint
K : Tcircle
t : Tpoint
p : prod Tpoint Tpoint
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair p t)
+++++
destruct p.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.

*****
H6 : OnCirc X K
H5 : OnCirc X (pair (pair t0 t1) t)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q (pair (pair t0 t1) t)
H0 : InCirc P (pair (pair t0 t1) t)
H : CI (pair (pair t0 t1) t) C R S
P,Q,R,S : Tpoint
K : Tcircle
C,D,F,G,t0,t1,t : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t0 t1) t)
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.
unfold CI in *.

*****
H6 : OnCirc X K
H5 : OnCirc X (pair (pair t0 t1) t)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : and (Logic.eq K (pair (pair D F) G)) (not (Logic.eq F G))
H1 : OutCirc Q (pair (pair t0 t1) t)
H0 : InCirc P (pair (pair t0 t1) t)
H : and (Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S))\n (not (Logic.eq R S))
P,Q,R,S : Tpoint
K : Tcircle
C,D,F,G,t0,t1,t : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t0 t1) t)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.
unfold CI in *.
spliter.

*****
H6 : OnCirc X K
H5 : OnCirc X (pair (pair t0 t1) t)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H7 : not (Logic.eq F G)
H2 : Logic.eq K (pair (pair D F) G)
H1 : OutCirc Q (pair (pair t0 t1) t)
H0 : InCirc P (pair (pair t0 t1) t)
H8 : not (Logic.eq R S)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S)
P,Q,R,S : Tpoint
K : Tcircle
C,D,F,G,t0,t1,t : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t0 t1) t)
+++++
inversion H.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.
unfold CI in *.
spliter.
inversion H.

*****
H12 : Logic.eq t S
H11 : Logic.eq t1 R
H10 : Logic.eq t0 C
H6 : OnCirc X K
H5 : OnCirc X (pair (pair t0 t1) t)
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H7 : not (Logic.eq F G)
H2 : Logic.eq K (pair (pair D F) G)
H1 : OutCirc Q (pair (pair t0 t1) t)
H0 : InCirc P (pair (pair t0 t1) t)
H8 : not (Logic.eq R S)
H : Logic.eq (pair (pair t0 t1) t) (pair (pair C R) S)
P,Q,R,S : Tpoint
K : Tcircle
C,D,F,G,t0,t1,t : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair C R) S)
+++++
subst.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.
unfold CI in *.
spliter.
inversion H.
subst.

*****
H6 : OnCirc X (pair (pair D F) G)
H5 : OnCirc X (pair (pair C R) S)
X : Tpoint
H3 : OnCirc P (pair (pair D F) G)
H4 : OnCirc Q (pair (pair D F) G)
H7 : not (Logic.eq F G)
H0 : InCirc P (pair (pair C R) S)
H1 : OutCirc Q (pair (pair C R) S)
H8 : not (Logic.eq R S)
H : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,P,Q,R,S : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair C R) S)
+++++
apply OnCirc_OnCirc.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.
unfold CI in *.
spliter.
inversion H.
subst.
apply OnCirc_OnCirc.

*****
H6 : OnCirc X (pair (pair D F) G)
H5 : OnCirc X (pair (pair C R) S)
X : Tpoint
H3 : OnCirc P (pair (pair D F) G)
H4 : OnCirc Q (pair (pair D F) G)
H7 : not (Logic.eq F G)
H0 : InCirc P (pair (pair C R) S)
H1 : OutCirc Q (pair (pair C R) S)
H8 : not (Logic.eq R S)
H : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,P,Q,R,S : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq R S)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct J.
destruct p.
unfold CI in *.
spliter.
inversion H.
subst.
apply OnCirc_OnCirc.

*****
H6 : OnCirc X (pair (pair D F) G)
H5 : OnCirc X (pair (pair C R) S)
X : Tpoint
H3 : OnCirc P (pair (pair D F) G)
H4 : OnCirc Q (pair (pair D F) G)
H7 : not (Logic.eq F G)
H0 : InCirc P (pair (pair C R) S)
H1 : OutCirc Q (pair (pair C R) S)
H8 : not (Logic.eq R S)
H : Logic.eq (pair (pair C R) S) (pair (pair C R) S)
C,D,F,G,P,Q,R,S : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc X (pair (pair C R) S)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.

*****
H6 : OnCirc X K
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q K
H3 : OnCirc P K
H2 : CI K D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
P,Q,R,S : Tpoint
J,K : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X K
+++++
destruct K.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.

*****
H6 : OnCirc X (pair p t)
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q (pair p t)
H3 : OnCirc P (pair p t)
H2 : CI (pair p t) D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
t,P,Q,R,S : Tpoint
p : prod Tpoint Tpoint
J : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair p t)
+++++
destruct p.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.

*****
H6 : OnCirc X (pair (pair t0 t1) t)
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q (pair (pair t0 t1) t)
H3 : OnCirc P (pair (pair t0 t1) t)
H2 : CI (pair (pair t0 t1) t) D F G
H1 : OutCirc Q J
H0 : InCirc P J
H : CI J C R S
t0,t1,t,P,Q,R,S : Tpoint
J : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t0 t1) t)
+++++
unfold CI in *.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.
unfold CI in *.

*****
H6 : OnCirc X (pair (pair t0 t1) t)
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q (pair (pair t0 t1) t)
H3 : OnCirc P (pair (pair t0 t1) t)
H2 : and (Logic.eq (pair (pair t0 t1) t) (pair (pair D F) G))\n (not (Logic.eq F G))
H1 : OutCirc Q J
H0 : InCirc P J
H : and (Logic.eq J (pair (pair C R) S)) (not (Logic.eq R S))
t0,t1,t,P,Q,R,S : Tpoint
J : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t0 t1) t)
+++++
spliter.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.
unfold CI in *.
spliter.

*****
H6 : OnCirc X (pair (pair t0 t1) t)
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q (pair (pair t0 t1) t)
H3 : OnCirc P (pair (pair t0 t1) t)
H7 : not (Logic.eq F G)
H2 : Logic.eq (pair (pair t0 t1) t) (pair (pair D F) G)
H1 : OutCirc Q J
H0 : InCirc P J
H8 : not (Logic.eq R S)
H : Logic.eq J (pair (pair C R) S)
t0,t1,t,P,Q,R,S : Tpoint
J : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair t0 t1) t)
+++++
inversion H2.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.
unfold CI in *.
spliter.
inversion H2.

*****
H12 : Logic.eq t G
H11 : Logic.eq t1 F
H10 : Logic.eq t0 D
H6 : OnCirc X (pair (pair t0 t1) t)
H5 : OnCirc X J
X : Tpoint
H4 : OnCirc Q (pair (pair t0 t1) t)
H3 : OnCirc P (pair (pair t0 t1) t)
H7 : not (Logic.eq F G)
H2 : Logic.eq (pair (pair t0 t1) t) (pair (pair D F) G)
H1 : OutCirc Q J
H0 : InCirc P J
H8 : not (Logic.eq R S)
H : Logic.eq J (pair (pair C R) S)
t0,t1,t,P,Q,R,S : Tpoint
J : Tcircle
C,D,F,G : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair D F) G)
+++++
subst.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.
unfold CI in *.
spliter.
inversion H2.
subst.

*****
H6 : OnCirc X (pair (pair D F) G)
H5 : OnCirc X (pair (pair C R) S)
X : Tpoint
H3 : OnCirc P (pair (pair D F) G)
H4 : OnCirc Q (pair (pair D F) G)
H7 : not (Logic.eq F G)
H2 : Logic.eq (pair (pair D F) G) (pair (pair D F) G)
H0 : InCirc P (pair (pair C R) S)
H1 : OutCirc Q (pair (pair C R) S)
H8 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_axioms.OnCirc X (pair (pair D F) G)
+++++
apply OnCirc_OnCirc.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.
unfold CI in *.
spliter.
inversion H2.
subst.
apply OnCirc_OnCirc.

*****
H6 : OnCirc X (pair (pair D F) G)
H5 : OnCirc X (pair (pair C R) S)
X : Tpoint
H3 : OnCirc P (pair (pair D F) G)
H4 : OnCirc Q (pair (pair D F) G)
H7 : not (Logic.eq F G)
H2 : Logic.eq (pair (pair D F) G) (pair (pair D F) G)
H0 : InCirc P (pair (pair C R) S)
H1 : OutCirc Q (pair (pair C R) S)
H8 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Logic.eq F G)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).
split.
simpl.
intros.
apply InCirc_InCirc in H0.
apply eOnCirc_OnCirc in H3.
apply eOnCirc_OnCirc in H4.
apply eOutCirc_OutCirc in H1.
destruct (circle_circle' cc C D F G J K P Q R S H) as [X HX].
auto.
spliter.
exists X.
split.
destruct K.
destruct p.
unfold CI in *.
spliter.
inversion H2.
subst.
apply OnCirc_OnCirc.

*****
H6 : OnCirc X (pair (pair D F) G)
H5 : OnCirc X (pair (pair C R) S)
X : Tpoint
H3 : OnCirc P (pair (pair D F) G)
H4 : OnCirc Q (pair (pair D F) G)
H7 : not (Logic.eq F G)
H2 : Logic.eq (pair (pair D F) G) (pair (pair D F) G)
H0 : InCirc P (pair (pair C R) S)
H1 : OutCirc Q (pair (pair C R) S)
H8 : not (Logic.eq R S)
C,D,F,G,P,Q,R,S : Tpoint
cc : circle_circle
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCirc X (pair (pair D F) G)
+++++
auto.
-----
Global Instance Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass : euclidean_neutral_ruler_compass Euclid_neutral_follows_from_Tarski_neutral.
Proof.
assert (cc : circle_circle).

*****

*****

+++++
Defined.
-----
End RulerAndCompass.
-----
Section Euclidean.
-----
Context `{TRC:Tarski_ruler_and_compass}.
-----
Context `{TE:@Tarski_euclidean Tn TnEQD}.
-----
Lemma Euclid5 :\n   forall a p q r s t,\n    BetS r t s -> BetS p t q -> BetS r a q ->\n    Cong p t q t -> Cong t r t s -> nCol p q s ->\n    exists X, BetS p a X /\ BetS s q X.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.

*****
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (a p q r s t : Point) (_ : BetS r t s) (_ : BetS p t q) (_ : BetS r a q) (_ : Cong p t q t) (_ : Cong t r t s) (_ : nCol p q s), ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
Proof.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.

*****
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (a p q r s t : Point) (_ : BetS r t s) (_ : BetS p t q) (_ : BetS r a q) (_ : Cong p t q t) (_ : Cong t r t s) (_ : nCol p q s), ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
intros.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.

*****
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
assert (T:tarski_s_parallel_postulate -> euclid_5).
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).

*****
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, euclid_5
+++++
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).

*****
T : all_equiv.all_equiv\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons triangle_circumscription_principle nil)))))))))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, euclid_5
+++++
unfold all_equiv.all_equiv in *.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).
unfold all_equiv.all_equiv in *.

*****
T : forall (x y : Prop)\n (_ : List.In x\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil))))))))))\n (_ : List.In y\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil)))))))))), \niff x y
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : tarski_s_parallel_postulate, euclid_5
+++++
apply T.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).
unfold all_equiv.all_equiv in *.
apply T.

*****
T : forall (x y : Prop)\n (_ : List.In x\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil))))))))))\n (_ : List.In y\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil)))))))))), \niff x y
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In euclid_5 (cons alternative_strong_parallel_postulate (cons alternative_proclus_postulate (cons euclid_5 (cons euclid_s_parallel_postulate (cons inverse_projection_postulate (cons proclus_postulate (cons strong_parallel_postulate (cons tarski_s_parallel_postulate (cons triangle_circumscription_principle nil)))))))))
+++++
simpl.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).
unfold all_equiv.all_equiv in *.
apply T.
simpl.

*****
T : forall (x y : Prop)\n (_ : List.In x\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil))))))))))\n (_ : List.In y\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil)))))))))), \niff x y
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq alternative_strong_parallel_postulate euclid_5) (or (Logic.eq alternative_proclus_postulate euclid_5) (or (Logic.eq euclid_5 euclid_5) (or (Logic.eq euclid_s_parallel_postulate euclid_5) (or (Logic.eq inverse_projection_postulate euclid_5) (or (Logic.eq proclus_postulate euclid_5) (or (Logic.eq strong_parallel_postulate euclid_5) (or (Logic.eq tarski_s_parallel_postulate euclid_5) (or (Logic.eq triangle_circumscription_principle euclid_5) False))))))))
+++++
auto 10.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).
unfold all_equiv.all_equiv in *.
apply T.

*****
T : forall (x y : Prop)\n (_ : List.In x\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil))))))))))\n (_ : List.In y\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil)))))))))), \niff x y
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
List.In tarski_s_parallel_postulate (cons alternative_strong_parallel_postulate (cons alternative_proclus_postulate (cons euclid_5 (cons euclid_s_parallel_postulate (cons inverse_projection_postulate (cons proclus_postulate (cons strong_parallel_postulate (cons tarski_s_parallel_postulate (cons triangle_circumscription_principle nil)))))))))
+++++
simpl.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T:=equivalent_postulates_without_decidability_of_intersection_of_lines_bis).
unfold all_equiv.all_equiv in *.
apply T.
simpl.

*****
T : forall (x y : Prop)\n (_ : List.In x\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil))))))))))\n (_ : List.In y\n (cons alternative_strong_parallel_postulate\n (cons alternative_proclus_postulate\n (cons euclid_5\n (cons euclid_s_parallel_postulate\n (cons inverse_projection_postulate\n (cons proclus_postulate\n (cons strong_parallel_postulate\n (cons tarski_s_parallel_postulate\n (cons\n triangle_circumscription_principle\n nil)))))))))), \niff x y
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Logic.eq alternative_strong_parallel_postulate tarski_s_parallel_postulate) (or (Logic.eq alternative_proclus_postulate tarski_s_parallel_postulate) (or (Logic.eq euclid_5 tarski_s_parallel_postulate) (or (Logic.eq euclid_s_parallel_postulate tarski_s_parallel_postulate) (or (Logic.eq inverse_projection_postulate tarski_s_parallel_postulate) (or (Logic.eq proclus_postulate tarski_s_parallel_postulate) (or (Logic.eq strong_parallel_postulate tarski_s_parallel_postulate) (or (Logic.eq tarski_s_parallel_postulate tarski_s_parallel_postulate) (or (Logic.eq triangle_circumscription_principle tarski_s_parallel_postulate) False))))))))
+++++
auto 10.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).

*****
T : forall _ : tarski_s_parallel_postulate, euclid_5
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
assert (T2:euclid_5).
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).

*****
T : forall _ : tarski_s_parallel_postulate, euclid_5
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclid_5
+++++
apply T.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
apply T.

*****
T : forall _ : tarski_s_parallel_postulate, euclid_5
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_s_parallel_postulate
+++++
unfold tarski_s_parallel_postulate.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
apply T.
unfold tarski_s_parallel_postulate.

*****
T : forall _ : tarski_s_parallel_postulate, euclid_5
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (Logic.eq A D)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Bet A B X) (and (Bet A C Y) (Bet X T Y))))
+++++
apply euclid.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).

*****
T2 : euclid_5
T : forall _ : tarski_s_parallel_postulate, euclid_5
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
unfold euclid_5 in *.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\ Definitions.BetS p a I).
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Definitions.BetS s q I) (Definitions.BetS p a I))
+++++
apply (T2 p q r s t a).
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS p t q
+++++
auto using BetS_BetS.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS r t s
+++++
auto using BetS_BetS.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS q a r
+++++
auto using BetS_BetS.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS q a r
+++++
unfold BetS in *.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
unfold BetS in *.

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return (forall (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n BetS) r a q
H0 : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return (forall (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n BetS) p t q
H : (let\n (Point, Circle, Cong, BetS, PA, PB, PC, CI, _, _, _, _, _, _, _, _,\n _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) as\n euclidean_neutral\n return (forall (_ : Point) (_ : Point) (_ : Point), Prop) :=\n Euclid_neutral_follows_from_Tarski_neutral in\n BetS) r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS q a r
+++++
simpl in *.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
unfold BetS in *.
simpl in *.

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : tarski_axioms.Cong t r t s
H2 : tarski_axioms.Cong p t q t
H1 : Definitions.BetS r a q
H0 : Definitions.BetS p t q
H : Definitions.BetS r t s
a,p,q,r,s,t : Tpoint
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Definitions.BetS q a r
+++++
unfold Definitions.BetS in *.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
unfold BetS in *.
simpl in *.
unfold Definitions.BetS in *.

*****
T2 : forall (P Q R S T U : Tpoint)\n (_ : and (Bet P T Q) (and (not (Logic.eq P T)) (not (Logic.eq T Q))))\n (_ : and (Bet R T S) (and (not (Logic.eq R T)) (not (Logic.eq T S))))\n (_ : and (Bet Q U R) (and (not (Logic.eq Q U)) (not (Logic.eq U R))))\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and\n (and (Bet S Q I) (and (not (Logic.eq S Q)) (not (Logic.eq Q I))))\n (and (Bet P U I) (and (not (Logic.eq P U)) (not (Logic.eq U I)))))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : and (Bet P T Q) (and (not (Logic.eq P T)) (not (Logic.eq T Q))))\n (_ : and (Bet R T S) (and (not (Logic.eq R T)) (not (Logic.eq T S))))\n (_ : and (Bet Q U R) (and (not (Logic.eq Q U)) (not (Logic.eq U R))))\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and\n (and (Bet S Q I) (and (not (Logic.eq S Q)) (not (Logic.eq Q I))))\n (and (Bet P U I) (and (not (Logic.eq P U)) (not (Logic.eq U I)))))
H4 : nCol p q s
H3 : tarski_axioms.Cong t r t s
H2 : tarski_axioms.Cong p t q t
H1 : and (Bet r a q) (and (not (Logic.eq r a)) (not (Logic.eq a q)))
H0 : and (Bet p t q) (and (not (Logic.eq p t)) (not (Logic.eq t q)))
H : and (Bet r t s) (and (not (Logic.eq r t)) (not (Logic.eq t s)))
a,p,q,r,s,t : Tpoint
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet q a r) (and (not (Logic.eq q a)) (not (Logic.eq a r)))
+++++
spliter.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
unfold BetS in *.
simpl in *.
unfold Definitions.BetS in *.
spliter.

*****
T2 : forall (P Q R S T U : Tpoint)\n (_ : and (Bet P T Q) (and (not (Logic.eq P T)) (not (Logic.eq T Q))))\n (_ : and (Bet R T S) (and (not (Logic.eq R T)) (not (Logic.eq T S))))\n (_ : and (Bet Q U R) (and (not (Logic.eq Q U)) (not (Logic.eq U R))))\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and\n (and (Bet S Q I) (and (not (Logic.eq S Q)) (not (Logic.eq Q I))))\n (and (Bet P U I) (and (not (Logic.eq P U)) (not (Logic.eq U I)))))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : and (Bet P T Q) (and (not (Logic.eq P T)) (not (Logic.eq T Q))))\n (_ : and (Bet R T S) (and (not (Logic.eq R T)) (not (Logic.eq T S))))\n (_ : and (Bet Q U R) (and (not (Logic.eq Q U)) (not (Logic.eq U R))))\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and\n (and (Bet S Q I) (and (not (Logic.eq S Q)) (not (Logic.eq Q I))))\n (and (Bet P U I) (and (not (Logic.eq P U)) (not (Logic.eq U I)))))
H4 : nCol p q s
H3 : tarski_axioms.Cong t r t s
H2 : tarski_axioms.Cong p t q t
H6 : not (Logic.eq a q)
H5 : not (Logic.eq r a)
H1 : Bet r a q
H8 : not (Logic.eq t q)
H7 : not (Logic.eq p t)
H0 : Bet p t q
H10 : not (Logic.eq t s)
H9 : not (Logic.eq r t)
H : Bet r t s
a,p,q,r,s,t : Tpoint
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet q a r) (and (not (Logic.eq q a)) (not (Logic.eq a r)))
+++++
finish.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Definitions.Col p q s)
+++++
auto using BetS_BetS.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Definitions.Col p q s)
+++++
intro HnCol.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
intro HnCol.

*****
HnCol : Definitions.Col p q s
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply Col_Col in HnCol.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
intro HnCol.
apply Col_Col in HnCol.

*****
HnCol : Col p q s
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply nCol_not_Col in H4.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.
intro HnCol.
apply Col_Col in HnCol.
apply nCol_not_Col in H4.

*****
HnCol : Col p q s
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : not (Col p q s)
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
intuition.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong p t q t
+++++
auto using BetS_BetS.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong r t s t
+++++
auto using BetS_BetS.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
apply (T2 p q r s t a).
auto using BetS_BetS.

*****
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
tarski_axioms.Cong r t s t
+++++
finish.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).

*****
T3 : ex\n (fun I : Tpoint =>\n and (Definitions.BetS s q I) (Definitions.BetS p a I))
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
destruct T3 as [X HX].
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
destruct T3 as [X HX].

*****
HX : and (Definitions.BetS s q X) (Definitions.BetS p a X)
X : Tpoint
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
exists X.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
destruct T3 as [X HX].
exists X.

*****
HX : and (Definitions.BetS s q X) (Definitions.BetS p a X)
X : Tpoint
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (BetS p a X) (BetS s q X)
+++++
spliter.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).
assert (T2:euclid_5).
unfold euclid_5 in *.
assert (T3:exists I : Tpoint, Definitions.BetS s q I /\\ Definitions.BetS p a I).
destruct T3 as [X HX].
exists X.
spliter.

*****
H6 : Definitions.BetS p a X
H5 : Definitions.BetS s q X
X : Tpoint
T2 : forall (P Q R S T U : Tpoint) (_ : Definitions.BetS P T Q)\n (_ : Definitions.BetS R T S) (_ : Definitions.BetS Q U R)\n (_ : not (Definitions.Col P Q S)) (_ : tarski_axioms.Cong P T Q T)\n (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
T : forall (_ : tarski_s_parallel_postulate) (P Q R S T U : Tpoint)\n (_ : Definitions.BetS P T Q) (_ : Definitions.BetS R T S)\n (_ : Definitions.BetS Q U R) (_ : not (Definitions.Col P Q S))\n (_ : tarski_axioms.Cong P T Q T) (_ : tarski_axioms.Cong R T S T),\nex\n (fun I : Tpoint =>\n and (Definitions.BetS S Q I) (Definitions.BetS P U I))
H4 : nCol p q s
H3 : Cong t r t s
H2 : Cong p t q t
H1 : BetS r a q
H0 : BetS p t q
H : BetS r t s
a,p,q,r,s,t : Point
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (BetS p a X) (BetS s q X)
+++++
auto.
-----
Lemma Euclid5 : forall a p q r s t, BetS r t s -> BetS p t q -> BetS r a q -> Cong p t q t -> Cong t r t s -> nCol p q s -> exists X, BetS p a X /\\ BetS s q X.
Proof.
intros.
assert (T:tarski_s_parallel_postulate -> euclid_5).

*****

*****

+++++
Qed.
-----
Global Instance Euclid_follows_from_Tarski_euclidean :\n euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.
-----
Global Instance Euclid_follows_from_Tarski_euclidean : euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.

*****
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass
+++++
Proof.
-----
Global Instance Euclid_follows_from_Tarski_euclidean : euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.
Proof.

*****
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass
+++++
intros.
-----
Global Instance Euclid_follows_from_Tarski_euclidean : euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.
Proof.
intros.

*****
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass
+++++
split.
-----
Global Instance Euclid_follows_from_Tarski_euclidean : euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.
Proof.
intros.
split.

*****
TE : Tarski_euclidean TnEQD
TRC : Tarski_ruler_and_compass TnEQD
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (a p q r s t : Point) (_ : BetS r t s) (_ : BetS p t q) (_ : BetS r a q) (_ : Cong p t q t) (_ : Cong t r t s) (_ : nCol p q s), ex (fun X : Point => and (BetS p a X) (BetS s q X))
+++++
apply Euclid5.
-----
Global Instance Euclid_follows_from_Tarski_euclidean : euclidean_euclidean Euclid_neutral_ruler_compass_follows_from_Tarski_ruler_and_compass.
Proof.
intros.
split.
apply Euclid5.

*****

*****

+++++
Qed.
-----
End Euclidean.
-----
