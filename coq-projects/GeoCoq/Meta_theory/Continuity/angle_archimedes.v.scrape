Require Import GeoCoq.Axioms.continuity_axioms.
-----
Require Import GeoCoq.Meta_theory.Continuity.archimedes.
-----
Require Import GeoCoq.Tarski_dev.Annexes.suma.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section Archimedes_for_angles.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma grada_distincts : forall A B C D E F,\n  GradA A B C D E F ->\n  A <> B /\ C <> B /\ D <> E /\ F <> E.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradA A B C D E F), and (not (eq A B)) (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
+++++
Proof.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradA A B C D E F), and (not (eq A B)) (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
+++++
induction 1.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.

*****
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A B)) (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
+++++
assert_diffs.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
assert_diffs.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A B)) (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
+++++
repeat split.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
assert_diffs.
repeat split.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
trivial.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
assert_diffs.
repeat split.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C B)
+++++
trivial.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
assert_diffs.
repeat split.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
trivial.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
assert_diffs.
repeat split.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F E)
+++++
trivial.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.

*****
IHGradA : and (not (eq A B))\n (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A B)) (and (not (eq C B)) (and (not (eq G H)) (not (eq I H))))
+++++
apply suma_distincts in H2.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
apply suma_distincts in H2.

*****
IHGradA : and (not (eq A B))\n (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
H2 : and (not (eq D E))\n (and (not (eq E F))\n (and (not (eq A B))\n (and (not (eq B C)) (and (not (eq G H)) (not (eq H I))))))
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A B)) (and (not (eq C B)) (and (not (eq G H)) (not (eq I H))))
+++++
spliter.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
apply suma_distincts in H2.
spliter.

*****
H6 : not (eq F E)
H5 : not (eq D E)
H4 : not (eq C B)
H3 : not (eq A B)
H11 : not (eq H I)
H10 : not (eq G H)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E F)
H2 : not (eq D E)
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq A B)) (and (not (eq C B)) (and (not (eq G H)) (not (eq I H))))
+++++
repeat split.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
apply suma_distincts in H2.
spliter.
repeat split.

*****
H6 : not (eq F E)
H5 : not (eq D E)
H4 : not (eq C B)
H3 : not (eq A B)
H11 : not (eq H I)
H10 : not (eq G H)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E F)
H2 : not (eq D E)
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
apply suma_distincts in H2.
spliter.
repeat split.

*****
H6 : not (eq F E)
H5 : not (eq D E)
H4 : not (eq C B)
H3 : not (eq A B)
H11 : not (eq H I)
H10 : not (eq G H)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E F)
H2 : not (eq D E)
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C B)
+++++
auto.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
apply suma_distincts in H2.
spliter.
repeat split.

*****
H6 : not (eq F E)
H5 : not (eq D E)
H4 : not (eq C B)
H3 : not (eq A B)
H11 : not (eq H I)
H10 : not (eq G H)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E F)
H2 : not (eq D E)
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq G H)
+++++
auto.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.
apply suma_distincts in H2.
spliter.
repeat split.

*****
H6 : not (eq F E)
H5 : not (eq D E)
H4 : not (eq C B)
H3 : not (eq A B)
H11 : not (eq H I)
H10 : not (eq G H)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E F)
H2 : not (eq D E)
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq I H)
+++++
auto.
-----
Lemma grada_distincts : forall A B C D E F, GradA A B C D E F -> A <> B /\\ C <> B /\\ D <> E /\\ F <> E.
Proof.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F',\n  GradA A B C D E F ->\n  CongA A B C A' B' C' -> CongA D E F D' E' F' ->\n  GradA A' B' C' D' E' F'.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F A' B' C' D' E' F' : Tpoint) (_ : GradA A B C D E F) (_ : CongA A B C A' B' C') (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
+++++
Proof.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F A' B' C' D' E' F' : Tpoint) (_ : GradA A B C D E F) (_ : CongA A B C A' B' C') (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
+++++
intros A B C D E F A' B' C' D' E' F' HGA.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.

*****
HGA : GradA A B C D E F
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : CongA A B C A' B' C') (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
+++++
revert A' B' C' D' E' F'.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.

*****
HGA : GradA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C') (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
+++++
induction HGA.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.

*****
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C') (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
+++++
intros A' B' C' D' E' F' Hconga1 Hconga2.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.

*****
Hconga2 : CongA D E F D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A' B' C' D' E' F'
+++++
apply grada_init, conga_trans with D E F.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
apply grada_init, conga_trans with D E F.

*****
Hconga2 : CongA D E F D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A' B' C' D E F
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
apply grada_init, conga_trans with D E F.
trivial.

*****
Hconga2 : CongA D E F D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A' B' C' D E F
+++++
apply conga_trans with A B C.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
apply grada_init, conga_trans with D E F.
trivial.
apply conga_trans with A B C.

*****
Hconga2 : CongA D E F D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A' B' C' A B C
+++++
CongA.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
apply grada_init, conga_trans with D E F.
trivial.
apply conga_trans with A B C.

*****
Hconga2 : CongA D E F D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C D E F
+++++
CongA.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
apply grada_init, conga_trans with D E F.

*****
Hconga2 : CongA D E F D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D' E' F'
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.

*****
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C') (_ : CongA G H I D' E' F'), GradA A' B' C' D' E' F'
+++++
intros A' B' C' D' E' F' Hconga1 Hconga2.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.

*****
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A' B' C' D' E' F'
+++++
suma.assert_diffs.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.

*****
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A' B' C' D' E' F'
+++++
assert (Hconga3 : CongA D E F D E F).
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).

*****
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
CongA.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A' B' C' D' E' F'
+++++
idtac.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A' B' C' D' E' F'
+++++
apply grada_stab with D E F.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A' B' C' D E F
+++++
apply (IHHGA A' B' C' D E F).
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (IHHGA A' B' C' D E F).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (IHHGA A' B' C' D E F).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F A' B' C'
+++++
apply (conga2_sams__sams D E F A B C).
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga2_sams__sams D E F A B C).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga2_sams__sams D E F A B C).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga2_sams__sams D E F A B C).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F A B C
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F A' B' C' D' E' F'
+++++
apply (conga3_suma__suma D E F A B C G H I).
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga3_suma__suma D E F A B C G H I).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F A B C G H I
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga3_suma__suma D E F A B C G H I).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga3_suma__suma D E F A B C G H I).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A' B' C'
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.
intros A' B' C' D' E' F' Hconga1 Hconga2.
suma.assert_diffs.
assert (Hconga3 : CongA D E F D E F).
idtac.
apply grada_stab with D E F.
apply (conga3_suma__suma D E F A B C G H I).

*****
Hconga3 : CongA D E F D E F
H13 : not (eq E F)
H11 : not (eq D E)
H9 : not (eq C' B')
H8 : not (eq F' E')
H7 : not (eq A' B')
H6 : not (eq D' E')
H5 : not (eq C B)
H4 : not (eq I H)
H3 : not (eq A B)
H2 : not (eq G H)
Hconga2 : CongA G H I D' E' F'
Hconga1 : CongA A B C A' B' C'
A',B',C',D',E',F' : Tpoint
IHHGA : forall (A' B' C' D' E' F' : Tpoint) (_ : CongA A B C A' B' C')\n (_ : CongA D E F D' E' F'), GradA A' B' C' D' E' F'
H1 : SumA D E F A B C G H I
H0 : SAMS D E F A B C
HGA : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA G H I D' E' F'
+++++
trivial.
-----
Lemma conga2_grada__grada : forall A B C D E F A' B' C' D' E' F', GradA A B C D E F -> CongA A B C A' B' C' -> CongA D E F D' E' F' -> GradA A' B' C' D' E' F'.
Proof.
intros A B C D E F A' B' C' D' E' F' HGA.
revert A' B' C' D' E' F'.
induction HGA.

*****

*****

+++++
Qed.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradA A B C D E F), LeA A B C D E F
+++++
Proof.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradA A B C D E F), LeA A B C D E F
+++++
intros A B C D E F.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.

*****
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : GradA A B C D E F, LeA A B C D E F
+++++
induction 1.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.

*****
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C D E F
+++++
Lea.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.

*****
IHGradA : LeA A B C D E F
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C G H I
+++++
apply lea_trans with D E F.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.
apply lea_trans with D E F.

*****
IHGradA : LeA A B C D E F
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C D E F
+++++
trivial.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.
apply lea_trans with D E F.

*****
IHGradA : LeA A B C D E F
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F G H I
+++++
trivial.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.
apply lea_trans with D E F.
trivial.

*****
IHGradA : LeA A B C D E F
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F G H I
+++++
apply sams_suma__lea123789 with A B C.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.
apply lea_trans with D E F.
trivial.
apply sams_suma__lea123789 with A B C.

*****
IHGradA : LeA A B C D E F
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F A B C G H I
+++++
trivial.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.
apply lea_trans with D E F.
trivial.
apply sams_suma__lea123789 with A B C.

*****
IHGradA : LeA A B C D E F
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F A B C
+++++
trivial.
-----
Lemma grada__lea : forall A B C D E F, GradA A B C D E F -> LeA A B C D E F.
Proof.
intros A B C D E F.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma grada_out__out : forall A B C D E F,\n  Out E D F -> GradA A B C D E F ->\n  Out B A C.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : Out E D F) (_ : GradA A B C D E F), Out B A C
+++++
Proof.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : Out E D F) (_ : GradA A B C D E F), Out B A C
+++++
intros A B C D E F Hout HGA.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.
intros A B C D E F Hout HGA.

*****
HGA : GradA A B C D E F
Hout : Out E D F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A C
+++++
apply out_lea__out with D E F.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.
intros A B C D E F Hout HGA.
apply out_lea__out with D E F.

*****
HGA : GradA A B C D E F
Hout : Out E D F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D F
+++++
trivial.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.
intros A B C D E F Hout HGA.
apply out_lea__out with D E F.

*****
HGA : GradA A B C D E F
Hout : Out E D F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C D E F
+++++
trivial.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.
intros A B C D E F Hout HGA.
apply out_lea__out with D E F.
trivial.

*****
HGA : GradA A B C D E F
Hout : Out E D F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C D E F
+++++
apply grada__lea.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.
intros A B C D E F Hout HGA.
apply out_lea__out with D E F.
trivial.
apply grada__lea.

*****
HGA : GradA A B C D E F
Hout : Out E D F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma grada_out__out : forall A B C D E F, Out E D F -> GradA A B C D E F -> Out B A C.
Proof.
intros A B C D E F Hout HGA.
apply out_lea__out with D E F.

*****

*****

+++++
Qed.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M,\n  GradA A B C D E F -> GradA A B C G H I ->\n  SAMS D E F G H I -> SumA D E F G H I K L M ->\n  GradA A B C K L M.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F G H I K L M : Tpoint) (_ : GradA A B C D E F) (_ : GradA A B C G H I) (_ : SAMS D E F G H I) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
Proof.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F G H I K L M : Tpoint) (_ : GradA A B C D E F) (_ : GradA A B C G H I) (_ : SAMS D E F G H I) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.

*****
HIsi : SAMS D E F G H I
HGA2 : GradA A B C G H I
HGA1 : GradA A B C D E F
A,B,C,D,E,F,G,H,I,K,L,M : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SumA D E F G H I K L M, GradA A B C K L M
+++++
revert K L M.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.

*****
HIsi : SAMS D E F G H I
HGA2 : GradA A B C G H I
HGA1 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
induction HGA2.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.

*****
HIsi : SAMS D E F D0 E0 F0
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), GradA A B C K L M
+++++
rename H into HConga.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.

*****
HIsi : SAMS D E F D0 E0 F0
HConga : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), GradA A B C K L M
+++++
rename D0 into G.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.

*****
HIsi : SAMS D E F G E0 F0
HConga : CongA A B C G E0 F0
G,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G E0 F0 K L M), GradA A B C K L M
+++++
rename E0 into H.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.

*****
HIsi : SAMS D E F G H F0
HConga : CongA A B C G H F0
G,H,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H F0 K L M), GradA A B C K L M
+++++
rename F0 into I.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.

*****
HIsi : SAMS D E F G H I
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
intros K L M HSuma.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.

*****
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F G H I
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
suma.assert_diffs.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F G H I
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F A B C K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.
CongA.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F A B C K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
apply grada_stab with D E F.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.
CongA.
apply grada_stab with D E F.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F A B C K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.
CongA.
apply grada_stab with D E F.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F A B C K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F A B C
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.
CongA.
apply grada_stab with D E F.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F A B C K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F A B C K L M
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA G H I A B C
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.
CongA.
apply (conga3_suma__suma D E F G H I K L M D E F A B C K L M) in HSuma.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F A B C
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA K L M K L M
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F G H I
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
rename H into HConga.
rename D0 into G.
rename E0 into H.
rename F0 into I.
intros K L M HSuma.
suma.assert_diffs.
apply (conga2_sams__sams D E F G H I D E F A B C) in HIsi.

*****
H11 : not (eq L M)
H9 : not (eq K L)
H7 : not (eq E F)
H5 : not (eq D E)
H3 : not (eq I H)
H2 : not (eq G H)
H1 : not (eq C B)
H0 : not (eq A B)
HSuma : SumA D E F G H I K L M
K,L,M : Tpoint
HIsi : SAMS D E F G H I
HConga : CongA A B C G H I
G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA G H I A B C
+++++
CongA.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.

*****
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).

*****
Hd1 : and (not (eq D0 E0))\n (and (not (eq E0 F0)) (and (not (eq A B)) (not (eq B C))))
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
assert (Hd2 := sams_distincts D E F G H I HIsi).
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).

*****
Hd2 : and (not (eq D E))\n (and (not (eq E F)) (and (not (eq G H)) (not (eq H I))))
Hd1 : and (not (eq D0 E0))\n (and (not (eq E0 F0)) (and (not (eq A B)) (not (eq B C))))
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
spliter.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.

*****
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].

*****
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
auto.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].

*****
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E F)
+++++
auto.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].

*****
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D0 E0)
+++++
auto.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].

*****
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E0 F0)
+++++
auto.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].

*****
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
auto.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.

*****
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (K L M : Tpoint) (_ : SumA D E F G H I K L M), GradA A B C K L M
+++++
intros K0 L0 M0 HSuma2.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K0 L0 M0
+++++
assert (HIsi2 : SAMS D E F D0 E0 F0).
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D0 E0 F0
+++++
apply sams_lea2__sams with D E F G H I.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply sams_lea2__sams with D E F G H I.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F G H I
+++++
Lea.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply sams_lea2__sams with D E F G H I.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F D E F
+++++
Lea.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply sams_lea2__sams with D E F G H I.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D0 E0 F0 G H I
+++++
Lea.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply sams_lea2__sams with D E F G H I.
Lea.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D0 E0 F0 G H I
+++++
apply sams_suma__lea123789 with A B C.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply sams_lea2__sams with D E F G H I.
Lea.
apply sams_suma__lea123789 with A B C.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D0 E0 F0 A B C G H I
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply sams_lea2__sams with D E F G H I.
Lea.
apply sams_suma__lea123789 with A B C.

*****
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D0 E0 F0 A B C
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K0 L0 M0
+++++
apply grada_stab with K L M.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C K L M
+++++
apply IHHGA2.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply IHHGA2.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply IHHGA2.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D0 E0 F0
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply IHHGA2.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F D0 E0 F0 K L M
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS K L M A B C
+++++
apply sams_assoc_2 with D E F D0 E0 F0 G H I.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply sams_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D0 E0 F0
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply sams_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D0 E0 F0 A B C
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply sams_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F D0 E0 F0 K L M
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply sams_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D0 E0 F0 A B C G H I
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply sams_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F G H I
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA K L M A B C K0 L0 M0
+++++
apply suma_assoc_2 with D E F D0 E0 F0 G H I.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply suma_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D0 E0 F0
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply suma_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D0 E0 F0 A B C
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply suma_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F D0 E0 F0 K L M
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply suma_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D0 E0 F0 A B C G H I
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.
assert (Hd1 := sams_distincts D0 E0 F0 A B C H0).
assert (Hd2 := sams_distincts D E F G H I HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [K [L [M HSuma]]].
auto.
intros K0 L0 M0 HSuma2.
assert (HIsi2 : SAMS D E F D0 E0 F0).
apply grada_stab with K L M.
apply suma_assoc_2 with D E F D0 E0 F0 G H I.

*****
HIsi2 : SAMS D E F D0 E0 F0
HSuma2 : SumA D E F G H I K0 L0 M0
K0,L0,M0 : Tpoint
HSuma : SumA D E F D0 E0 F0 K L M
K,L,M : Tpoint
H5 : not (eq H I)
H4 : not (eq G H)
H3 : not (eq E F)
H2 : not (eq D E)
H9 : not (eq B C)
H8 : not (eq A B)
H7 : not (eq E0 F0)
H6 : not (eq D0 E0)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : SAMS D E F D0 E0 F0)\n (K L M : Tpoint) (_ : SumA D E F D0 E0 F0 K L M), \nGradA A B C K L M
HIsi : SAMS D E F G H I
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F G H I K0 L0 M0
+++++
trivial.
-----
Lemma grada2_sams_suma__grada : forall A B C D E F G H I K L M, GradA A B C D E F -> GradA A B C G H I -> SAMS D E F G H I -> SumA D E F G H I K L M -> GradA A B C K L M.
Proof.
intros A B C D E F G H I K L M HGA1 HGA2 HIsi.
revert K L M.
induction HGA2.

*****

*****

+++++
Qed.
-----
Lemma gradaexp__grada : forall A B C D E F,\n  GradAExp A B C D E F -> GradA A B C D E F.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradAExp A B C D E F), GradA A B C D E F
+++++
Proof.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F : Tpoint) (_ : GradAExp A B C D E F), GradA A B C D E F
+++++
intros A B C.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (D E F : Tpoint) (_ : GradAExp A B C D E F), GradA A B C D E F
+++++
induction 1.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.

*****
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
apply grada_init.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.
apply grada_init.

*****
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C D E F
+++++
trivial.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.

*****
IHGradAExp : GradA A B C D E F
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C G H I
+++++
apply grada2_sams_suma__grada with D E F D E F.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.
apply grada2_sams_suma__grada with D E F D E F.

*****
IHGradAExp : GradA A B C D E F
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.
apply grada2_sams_suma__grada with D E F D E F.

*****
IHGradAExp : GradA A B C D E F
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.
apply grada2_sams_suma__grada with D E F D E F.

*****
IHGradAExp : GradA A B C D E F
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D E F
+++++
trivial.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.
apply grada2_sams_suma__grada with D E F D E F.

*****
IHGradAExp : GradA A B C D E F
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F D E F G H I
+++++
trivial.
-----
Lemma gradaexp__grada : forall A B C D E F, GradAExp A B C D E F -> GradA A B C D E F.
Proof.
intros A B C.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma acute_archi_aux : forall O A B C D E,\n  Per O A B -> O <> A -> B <> A -> C <> D -> D <> E ->\n  Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E ->\n  Lt C D D E.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (O A B C D E : Tpoint) (_ : Per O A B) (_ : not (eq O A)) (_ : not (eq B A)) (_ : not (eq C D)) (_ : not (eq D E)) (_ : Bet A C D) (_ : Bet C D E) (_ : Bet D E B) (_ : CongA C O D D O E), Lt C D D E
+++++
Proof.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (O A B C D E : Tpoint) (_ : Per O A B) (_ : not (eq O A)) (_ : not (eq B A)) (_ : not (eq C D)) (_ : not (eq D E)) (_ : Bet A C D) (_ : Bet C D E) (_ : Bet D E B) (_ : CongA C O D D O E), Lt C D D E
+++++
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.

*****
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert_diffs.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.

*****
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).

*****
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HNCol2 : ~ Col O A D).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).

*****
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col O A D)
+++++
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.

*****
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.

*****
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col O D E)
+++++
intro; apply HNCol2; ColR.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.

*****
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HAcute : Acute A D O).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).

*****
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute A D O
+++++
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.

*****
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HF : InAngle P O D E).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).

*****
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P O D E
+++++
apply lea_in_angle; Side.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
apply lea_in_angle; Side.

*****
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA O D P O D E
+++++
apply (l11_30 A D O E D O); CongA.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
apply lea_in_angle; Side.
apply (l11_30 A D O E D O); CongA.

*****
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A D O E D O
+++++
destruct (acute_chara A D O E) as [HD HI]; eBetween.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
apply lea_in_angle; Side.
apply (l11_30 A D O E D O); CongA.
destruct (acute_chara A D O E) as [HD HI]; eBetween.

*****
HI : forall _ : LtA A D O E D O, Acute A D O
HD : forall _ : Acute A D O, LtA A D O E D O
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A D O E D O
+++++
apply lta__lea, HD, HAcute.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).

*****
HF : InAngle P O D E
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].

*****
Heq : eq F D
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
exfalso; subst F; apply HNCol2; ColR.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.

*****
HOut : Out D F P
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert_diffs.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.

*****
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D F P
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
apply l6_6 in HOut.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.

*****
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HCongA1 : CongA A D O O D F).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).

*****
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A D O O D F
+++++
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.

*****
HCongA1 : CongA A D O O D F
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HCongA2 : CongA O D C A D O).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).

*****
HCongA1 : CongA A D O O D F
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA O D C A D O
+++++
elim (eq_dec_points A C); intro.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.

*****
H6 : eq A C
HCongA1 : CongA A D O O D F
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA O D C A D O
+++++
treat_equalities; CongA.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.

*****
H6 : not (eq A C)
HCongA1 : CongA A D O O D F
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA O D C A D O
+++++
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.

*****
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H10 : not (eq O P)
H7 : not (eq F D)
HOut : Out D P F
HBet4 : Bet O F E
F : Tpoint
HDP : not (eq P D)
HAcute : Acute A D O
HP2 : OS O D P E
HP1 : CongA A D O O D P
P : Tpoint
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
clear dependent P.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.

*****
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).

*****
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
assert_diffs.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.

*****
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.

*****
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col O D C)
+++++
intro; apply HNCol2; ColR.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.

*****
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D O C D O F
+++++
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.

*****
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA O D C O D F
+++++
apply conga_trans with A D O; trivial.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.

*****
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D D E
+++++
apply (cong2_lt__lt D F D E); Cong.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.

*****
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt D F D E
+++++
assert (HNCol4 : ~ Col E D F).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).

*****
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col E D F)
+++++
intro; elim (eq_dec_points E F); intro; [|apply HNCol3; ColR].
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
intro; elim (eq_dec_points E F); intro; [|apply HNCol3; ColR].

*****
H8 : eq E F
H6 : Col E D F
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
intro; elim (eq_dec_points E F); intro; [|apply HNCol3; ColR].
treat_equalities.

*****
HNCol3 : not (Col O D E)
HCong1 : Cong O C O E
HCong2 : Cong D C D E
HCongA3 : CongA O C D O E D
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D E
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (acute_not_per A D O); trivial.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
intro; elim (eq_dec_points E F); intro; [|apply HNCol3; ColR].
treat_equalities.
apply (acute_not_per A D O); trivial.

*****
HNCol3 : not (Col O D E)
HCong1 : Cong O C O E
HCong2 : Cong D C D E
HCongA3 : CongA O C D O E D
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D E
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A D O
+++++
apply l8_2, per_col with C; Col.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
intro; elim (eq_dec_points E F); intro; [|apply HNCol3; ColR].
treat_equalities.
apply (acute_not_per A D O); trivial.
apply l8_2, per_col with C; Col.

*****
HNCol3 : not (Col O D E)
HCong1 : Cong O C O E
HCong2 : Cong D C D E
HCongA3 : CongA O C D O E D
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D E
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per O D C
+++++
exists E; repeat split; Cong.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).

*****
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt D F D E
+++++
assert_diffs.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.

*****
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt D F D E
+++++
apply l11_44_2_b; trivial.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.

*****
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA D E F D F E
+++++
apply lta_trans with F D O.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.

*****
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA D E F F D O
+++++
-
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-

*****
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA D E F F D O
+++++
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.

*****
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D E O)
+++++
intro; apply HNCol3; ColR.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
intro; apply HNCol3; ColR.

*****
Hlta2 : LtA D E O O D C
Hlta1 : LtA D O E O D C
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA D E F F D O
+++++
apply (conga_preserves_lta D E O O D C); trivial; [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA; try (apply out_trivial; auto).
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
intro; apply HNCol3; ColR.
apply (conga_preserves_lta D E O O D C); trivial; [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA; try (apply out_trivial; auto).

*****
Hlta2 : LtA D E O O D C
Hlta1 : LtA D O E O D C
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E F O
+++++
apply bet_out; Between.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
intro; apply HNCol3; ColR.
apply (conga_preserves_lta D E O O D C); trivial; [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA; try (apply out_trivial; auto).
apply bet_out; Between.

*****
Hlta2 : LtA D E O O D C
Hlta1 : LtA D O E O D C
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out D A C
+++++
apply l6_6, bet_out; eBetween.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
intro; apply HNCol3; ColR.
apply (conga_preserves_lta D E O O D C); trivial; [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA; try (apply out_trivial; auto).
apply bet_out; Between.
apply l6_6, bet_out; eBetween.

*****

*****

+++++
-
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
intro; apply HNCol3; ColR.
apply (conga_preserves_lta D E O O D C); trivial; [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA; try (apply out_trivial; auto).
apply bet_out; Between.
apply l6_6, bet_out; eBetween.
-

*****
H13 : not (eq E F)
HNCol4 : not (Col E D F)
HCongA3 : CongA O C D O F D
HCong2 : Cong D C D F
HCong1 : Cong O C O F
H12 : not (eq O F)
HNCol3 : not (Col O D F)
HCongA2 : CongA O D C A D O
HCongA1 : CongA A D O O D F
H7 : not (eq F D)
HBet4 : Bet O F E
F : Tpoint
HAcute : Acute A D O
HNCol2 : not (Col O A D)
HNCol1 : not (Col O A B)
H5 : not (eq E O)
H4 : not (eq D O)
H3 : not (eq C O)
H2 : not (eq O B)
H1 : not (eq A D)
H0 : not (eq C E)
H : not (eq D B)
HCongA : CongA C O D D O E
HBet3 : Bet D E B
HBet2 : Bet C D E
HBet1 : Bet A C D
HDE : not (eq D E)
HCD : not (eq C D)
HBA : not (eq B A)
HOA : not (eq O A)
HPer : Per O A B
O,A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA F D O D F E
+++++
destruct (l11_41 F O D E); Col.
-----
Lemma acute_archi_aux : forall O A B C D E, Per O A B -> O <> A -> B <> A -> C <> D -> D <> E -> Bet A C D -> Bet C D E -> Bet D E B -> CongA C O D D O E -> Lt C D D E.
Proof.
intros O A B C D E HPer HOA HBA HCD HDE HBet1 HBet2 HBet3 HCongA.
assert_diffs.
assert (HNCol1 : ~ Col O A B) by (apply per_not_col; auto).
assert (HNCol2 : ~ Col O A D).
intro; elim (eq_dec_points A C); intro; assert_cols; treat_equalities; apply HNCol1; ColR.
destruct (angle_construction_1 A D O O D E) as [P [HP1 HP2]]; Col.
intro; apply HNCol2; ColR.
assert (HAcute : Acute A D O).
apply l11_43_aux; Col; left; apply l8_2, per_col with B; auto; ColR.
assert (HF : InAngle P O D E).
destruct HF as [_ [_ [HDP [F [HBet4 [Heq|HOut]]]]]].
exfalso; subst F; apply HNCol2; ColR.
assert_diffs.
apply l6_6 in HOut.
assert (HCongA1 : CongA A D O O D F).
apply (out_conga A D O O D P); trivial; apply out_trivial; auto.
assert (HCongA2 : CongA O D C A D O).
elim (eq_dec_points A C); intro.
treat_equalities; CongA.
apply (out_conga O D C C D O); CongA; try (apply out_trivial; auto); apply bet_out; eBetween.
clear dependent P.
assert (HNCol3 : ~ Col O D F) by (apply (ncol_conga_ncol A D O); Col).
assert_diffs.
destruct (l11_50_1 O D C O D F) as [HCong1 [HCong2 HCongA3]]; Cong.
intro; apply HNCol2; ColR.
apply (out_conga D O C D O E); CongA; try (apply out_trivial; auto); apply l6_6, bet_out; auto.
apply conga_trans with A D O; trivial.
apply (cong2_lt__lt D F D E); Cong.
assert (HNCol4 : ~ Col E D F).
assert_diffs.
apply l11_44_2_b; trivial.
apply lta_trans with F D O.
-
destruct (l11_41 D E O C) as [Hlta1 Hlta2]; Between.
intro; apply HNCol3; ColR.
apply (conga_preserves_lta D E O O D C); trivial; [apply (out_conga D E F D E F)|apply (out_conga O D A F D O)]; CongA; try (apply out_trivial; auto).
apply bet_out; Between.
apply l6_6, bet_out; eBetween.
-
destruct (l11_41 F O D E); Col.

*****

*****

+++++
Qed.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R,\n  Per O A0 B -> B <> A0 -> Bet A0 A1 B ->\n  GradA A0 O A1 P Q R -> A0 <> A1 ->\n  LeA A0 O B P Q R \/ exists A, Bet A0 A1 A /\ Bet A0 A B /\ CongA P Q R A0 O A.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (O A0 A1 B P Q R : Tpoint) (_ : Per O A0 B) (_ : not (eq B A0)) (_ : Bet A0 A1 B) (_ : GradA A0 O A1 P Q R) (_ : not (eq A0 A1)), or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
Proof.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (O A0 A1 B P Q R : Tpoint) (_ : Per O A0 B) (_ : not (eq B A0)) (_ : Bet A0 A1 B) (_ : GradA A0 O A1 P Q R) (_ : not (eq A0 A1)), or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.

*****
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.

*****
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).

*****
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
assert_diffs.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.

*****
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
elim (lea_total A0 O B P Q R); auto.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.

*****
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : LeA P Q R A0 O B, or (LeA A0 O B P Q R) (ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))))
+++++
intro HLeA; right.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.

*****
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
assert (HNCol2 : ~ Col P Q R).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).

*****
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P Q R)
+++++
intro HCol.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
intro HCol.

*****
HCol : Col P Q R
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HBet1 : Bet P Q R).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
intro HCol.
assert (HBet1 : Bet P Q R).

*****
HCol : Col P Q R
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q R
+++++
apply not_out_bet; trivial.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
intro HCol.
assert (HBet1 : Bet P Q R).
apply not_out_bet; trivial.

*****
HCol : Col P Q R
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Out Q P R)
+++++
intro HOut; assert (Out O A0 A1) by (apply grada_out__out with P Q R; trivial).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
intro HCol.
assert (HBet1 : Bet P Q R).
apply not_out_bet; trivial.
intro HOut; assert (Out O A0 A1) by (apply grada_out__out with P Q R; trivial).

*****
H3 : Out O A0 A1
HOut : Out Q P R
HCol : Col P Q R
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol; ColR.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
intro HCol.
assert (HBet1 : Bet P Q R).
apply not_out_bet; trivial.
intro HOut; assert (Out O A0 A1) by (apply grada_out__out with P Q R; trivial).
apply HNCol; ColR.

*****
HBet1 : Bet P Q R
HCol : Col P Q R
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet A0 O B); assert_cols; Col.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
intro HCol.
assert (HBet1 : Bet P Q R).
apply not_out_bet; trivial.
intro HOut; assert (Out O A0 A1) by (apply grada_out__out with P Q R; trivial).
apply HNCol; ColR.
assert (Bet A0 O B); assert_cols; Col.

*****
H3 : Col A0 A1 B
HBet1 : Bet P Q R
HCol : Col P Q R
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 O B
+++++
apply bet_lea__bet with P Q R; trivial.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).

*****
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.

*****
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
assert (HA : InAngle C A0 O B).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).

*****
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle C A0 O B
+++++
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.

*****
HA : InAngle C A0 O B
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].

*****
HUn : or (eq A O) (Out O A C)
HA : Bet A0 A B
A : Tpoint
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
destruct HUn as [Heq|Hout].
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].

*****
Heq : eq A O
HA : Bet A0 A B
A : Tpoint
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
exfalso; treat_equalities; apply HNCol; Col.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.

*****
Hout : Out O A C
HA : Bet A0 A B
A : Tpoint
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A)))
+++++
exists A.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.

*****
Hout : Out O A C
HA : Bet A0 A B
A : Tpoint
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O C
C : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))
+++++
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].

*****
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C,A : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P Q R A0 O A))
+++++
repeat (split; trivial).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).

*****
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C,A : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
elim (eq_dec_points A1 A).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).

*****
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C,A : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A1 A, Bet A0 A1 A
+++++
intro; subst A; Between.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.

*****
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C,A : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A1 A), Bet A0 A1 A
+++++
intro HAA1.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.

*****
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C,A : Tpoint
HNCol2 : not (Col P Q R)
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.

*****
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
assert (HInangle : InAngle A1 A0 O A).
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).

*****
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle A1 A0 O A
+++++
apply lea_in_angle.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
apply lea_in_angle.

*****
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A0 O A1 A0 O A
+++++
apply (l11_30 A0 O A1 P Q R); CongA; apply grada__lea; trivial.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
apply lea_in_angle.
apply (l11_30 A0 O A1 P Q R); CongA; apply grada__lea; trivial.

*****
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A0 O A A1
+++++
apply out_one_side; auto.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
apply lea_in_angle.
apply (l11_30 A0 O A1 P Q R); CongA; apply grada__lea; trivial.
apply out_one_side; auto.

*****
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A0 A A1
+++++
assert_diffs.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
apply lea_in_angle.
apply (l11_30 A0 O A1 P Q R); CongA; apply grada__lea; trivial.
apply out_one_side; auto.
assert_diffs.

*****
H7 : not (eq A0 C)
H9 : not (eq A0 A)
H5 : not (eq O A)
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A0 A A1
+++++
apply l6_7 with B; [|apply l6_6]; apply bet_out; auto.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).

*****
HInangle : InAngle A1 A0 O A
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].

*****
HUn : or (eq X O) (Out O X A1)
HX1 : Bet A0 X A
X : Tpoint
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
destruct HUn as [HX2|HX2].
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].
destruct HUn as [HX2|HX2].

*****
HX2 : eq X O
HX1 : Bet A0 X A
X : Tpoint
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
subst X; exfalso; Col.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].
destruct HUn as [HX2|HX2].
subst X; exfalso; Col.

*****
HX2 : Out O X A1
HX1 : Bet A0 X A
X : Tpoint
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
elim (eq_dec_points X A1); intro.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].
destruct HUn as [HX2|HX2].
subst X; exfalso; Col.
elim (eq_dec_points X A1); intro.

*****
H3 : eq X A1
HX2 : Out O X A1
HX1 : Bet A0 X A
X : Tpoint
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
subst X; trivial.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].
destruct HUn as [HX2|HX2].
subst X; exfalso; Col.
elim (eq_dec_points X A1); intro.
subst X; trivial.

*****
H3 : not (eq X A1)
HX2 : Out O X A1
HX1 : Bet A0 X A
X : Tpoint
HAA1 : not (eq A1 A)
Hout : Out O A C
HA : Bet A0 A B
HCO : not (eq C O)
HOS : OS A0 O C B
Hconga : CongA P Q R A0 O A
C : Tpoint
HNCol2 : not (Col A0 O A)
A : Tpoint
HLeA : LeA P Q R A0 O B
H8 : not (eq O B)
HNCol : not (Col O A0 B)
H2 : not (eq R Q)
H1 : not (eq P Q)
H0 : not (eq A1 O)
H : not (eq A0 O)
HA0A1 : not (eq A0 A1)
HGA : GradA A0 O A1 P Q R
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HPer : Per O A0 B
O,A0,A1,B,P,Q,R : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A1 A
+++++
exfalso; apply HNCol2; assert_diffs; ColR.
-----
Lemma acute_archi_aux1 : forall O A0 A1 B P Q R, Per O A0 B -> B <> A0 -> Bet A0 A1 B -> GradA A0 O A1 P Q R -> A0 <> A1 -> LeA A0 O B P Q R \\/ exists A, Bet A0 A1 A /\\ Bet A0 A B /\\ CongA P Q R A0 O A.
Proof.
intros O A0 A1 B P Q R HPer HBA0 HBet HGA HA0A1.
assert (Hdiff := grada_distincts A0 O A1 P Q R HGA); spliter.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert_diffs.
elim (lea_total A0 O B P Q R); auto.
intro HLeA; right.
assert (HNCol2 : ~ Col P Q R).
destruct (angle_construction_1 P Q R A0 O B) as [C [Hconga HOS]]; Col.
assert (HA : InAngle C A0 O B).
apply lea_in_angle; Side; apply (l11_30 P Q R A0 O B); CongA.
destruct HA as [_ [_ [HCO [A [HA HUn]]]]].
destruct HUn as [Heq|Hout].
exfalso; treat_equalities; apply HNCol; Col.
exists A.
apply (out_conga P Q R A0 O C P R A0 A) in Hconga; try (apply out_trivial; auto); [|apply l6_6; trivial].
repeat (split; trivial).
elim (eq_dec_points A1 A).
intro; subst A; Between.
intro HAA1.
apply (ncol_conga_ncol P Q R A0 O A) in HNCol2; trivial.
assert (HInangle : InAngle A1 A0 O A).
destruct HInangle as [_ [_ [_ [X [HX1 HUn]]]]].
destruct HUn as [HX2|HX2].
subst X; exfalso; Col.
elim (eq_dec_points X A1); intro.
subst X; trivial.
exfalso; apply HNCol2; assert_diffs; ColR.

*****

*****

+++++
Qed.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C,\n  Per O A0 B -> O <> A0 -> B <> A0 ->\n  Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C ->\n  exists P, exists Q, exists R, GradA A0 O A1 P Q R /\ (LeA A0 O B P Q R \/\n  exists A', Bet A0 A1 A' /\ Bet A0 A' B /\ CongA P Q R A0 O A' /\ Le A0 C A0 A' /\\n  exists A, Bet A0 A A' /\ CongA A O A' A0 O A1 /\ Le A0 A1 A A').
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (O A0 A1 B C : Tpoint) (_ : Per O A0 B) (_ : not (eq O A0)) (_ : not (eq B A0)) (_ : Bet A0 A1 B) (_ : not (eq A0 A1)) (_ : Grad A0 A1 C), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
Proof.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (O A0 A1 B C : Tpoint) (_ : Per O A0 B) (_ : not (eq O A0)) (_ : not (eq B A0)) (_ : Bet A0 A1 B) (_ : not (eq A0 A1)) (_ : Grad A0 A1 C), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.

*****
HG : Grad A0 A1 E
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,A0,A1,B,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 E A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).

*****
HNCol : not (Col O A0 B)
HG : Grad A0 A1 E
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,A0,A1,B,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 E A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).

*****
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
HG : Grad A0 A1 E
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,A0,A1,B,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 E A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
assert_diffs.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.

*****
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
HG : Grad A0 A1 E
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,A0,A1,B,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 E A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
induction HG; rename A into A0; rename B0 into A1.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.

*****
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 A1 A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].

*****
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B A0 O A1) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA A0 O A1 A0 O A') (and (Le A0 A1 A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))
+++++
right; exists A1; repeat (split; CongA); Between; Le.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.

*****
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A A1) (and (CongA A O A1 A0 O A1) (Le A0 A1 A A1)))
+++++
exists A0; repeat (split; CongA); Between; Le.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.

*****
IHHG : forall (_ : Per O A0 B) (_ : not (eq O A0)) (_ : not (eq B A0))\n (_ : Bet A0 A1 B) (_ : not (eq A0 A1)) (_ : not (Col O A0 B))\n (_ : not (Col A0 O A1)) (_ : not (eq O A1)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A0 O A1 P Q R)\n (or (LeA A0 O B P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet A0 A1 A')\n (and (Bet A0 A' B)\n (and (CongA P Q R A0 O A')\n (and (Le A0 C A0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet A0 A A')\n (and (CongA A O A' A0 O A1)\n (Le A0 A1 A A')))))))))))))
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.

*****
HUn : or (LeA A0 O B P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet A0 A1 A')\n (and (Bet A0 A' B)\n (and (CongA P Q R A0 O A')\n (and (Le A0 C A0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet A0 A A')\n (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
destruct HUn as [HLea|HA'].
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].

*****
HLea : LeA A0 O B P Q R
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
exists P; exists Q; exists R; split; trivial; left; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.

*****
HA' : ex\n (fun A' : Tpoint =>\n and (Bet A0 A1 A')\n (and (Bet A0 A' B)\n (and (CongA P Q R A0 O A')\n (and (Le A0 C A0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet A0 A A')\n (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
destruct HA as [A [HBet1 [HConga HLe]]].
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
assert (HIsi : SAMS P Q R A0 O A1).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R A0 O A1
+++++
apply sams_lea2__sams with A0 O B A0 O B.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS A0 O B A0 O B
+++++
-
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS A0 O B A0 O B
+++++
apply acute__sams, l11_43_aux; Col.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.

*****

*****

+++++
-
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA P Q R A0 O B
+++++
apply (l11_30 A0 O A' A0 O B); CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A0 O A' A0 O B
+++++
exists A'; assert_diffs; split; CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.

*****
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle A' A0 O B
+++++
repeat split; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.

*****
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Bet A0 X B) (or (eq X O) (Out O X A')))
+++++
exists A'; split; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.
exists A'; split; trivial.

*****
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq A' O) (Out O A' A')
+++++
right; apply out_trivial; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.
exists A'; split; trivial.
right; apply out_trivial; auto.

*****

*****

+++++
-
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.
exists A'; split; trivial.
right; apply out_trivial; auto.
-

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A0 O A1 A0 O B
+++++
exists A1; split; CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.
exists A'; split; trivial.
right; apply out_trivial; auto.
-
exists A1; split; CongA.

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle A1 A0 O B
+++++
repeat split; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.
exists A'; split; trivial.
right; apply out_trivial; auto.
-
exists A1; split; CongA.
repeat split; auto.

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Bet A0 X B) (or (eq X O) (Out O X A1)))
+++++
exists A1; split; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
apply sams_lea2__sams with A0 O B A0 O B.
-
apply acute__sams, l11_43_aux; Col.
-
apply (l11_30 A0 O A' A0 O B); CongA.
exists A'; assert_diffs; split; CongA.
repeat split; auto.
exists A'; split; trivial.
right; apply out_trivial; auto.
-
exists A1; split; CongA.
repeat split; auto.
exists A1; split; trivial.

*****
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq A1 O) (Out O A1 A1)
+++++
right; apply out_trivial; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).

*****
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
assert_diffs.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.

*****
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.

*****
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).

*****
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A0 O A1 P Q R) (or (LeA A0 O B P Q R) (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P Q R A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))))))
+++++
exists P'; exists Q'; exists R'; split; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.

*****
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B P' Q' R') (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))
+++++
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.

*****
HA'' : ex\n (fun A : Tpoint =>\n and (Bet A0 A1 A) (and (Bet A0 A B) (CongA P' Q' R' A0 O A)))
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA A0 O B P' Q' R') (ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A')))))))))
+++++
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].

*****
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).

*****
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).

*****
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HNCol4 : ~ Col A' O A'').
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').

*****
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A' O A'')
+++++
intro HCol; apply HNCol1.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
intro HCol; apply HNCol1.

*****
HCol : Col A' O A''
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A0 O A1
+++++
elim (eq_dec_points A' A''); intro; [|ColR].
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
intro HCol; apply HNCol1.
elim (eq_dec_points A' A''); intro; [|ColR].

*****
H11 : eq A' A''
HCol : Col A' O A''
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A0 O A1
+++++
treat_equalities.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
intro HCol; apply HNCol1.
elim (eq_dec_points A' A''); intro; [|ColR].
treat_equalities.

*****
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A'
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A0 O A1
+++++
assert (HSuma2 : SumA A0 O A' A0 O A1 A0 O A').
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
intro HCol; apply HNCol1.
elim (eq_dec_points A' A''); intro; [|ColR].
treat_equalities.
assert (HSuma2 : SumA A0 O A' A0 O A1 A0 O A').

*****
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A'
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A0 O A' A0 O A1 A0 O A'
+++++
apply (conga3_suma__suma P Q R A0 O A1 P' Q' R'); CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
intro HCol; apply HNCol1.
elim (eq_dec_points A' A''); intro; [|ColR].
treat_equalities.
assert (HSuma2 : SumA A0 O A' A0 O A1 A0 O A').
apply (conga3_suma__suma P Q R A0 O A1 P' Q' R'); CongA.

*****
HSuma2 : SumA A0 O A' A0 O A1 A0 O A'
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A'
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A0 O A1
+++++
apply sams_suma__out546 in HSuma2; Col.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
intro HCol; apply HNCol1.
elim (eq_dec_points A' A''); intro; [|ColR].
treat_equalities.
assert (HSuma2 : SumA A0 O A' A0 O A1 A0 O A').
apply (conga3_suma__suma P Q R A0 O A1 P' Q' R'); CongA.
apply sams_suma__out546 in HSuma2; Col.

*****
HSuma2 : SumA A0 O A' A0 O A1 A0 O A'
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A'
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS A0 O A' A0 O A1
+++++
apply (conga2_sams__sams P Q R A0 O A1); CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').

*****
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HBet4 : Bet A0 A' A'').
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 A' A''
+++++
apply col_two_sides_bet with O.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
apply col_two_sides_bet with O.

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A' A0 A''
+++++
ColR.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
apply col_two_sides_bet with O.
ColR.

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A' O A0 A''
+++++
apply in_angle_two_sides; Col.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
apply col_two_sides_bet with O.
ColR.
apply in_angle_two_sides; Col.

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle A' A0 O A''
+++++
apply lea_in_angle.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
apply col_two_sides_bet with O.
ColR.
apply in_angle_two_sides; Col.
apply lea_in_angle.

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A0 O A' A0 O A''
+++++
apply (l11_30 P Q R P' Q' R'); CongA; apply sams_suma__lea123789 with A0 O A1; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
apply col_two_sides_bet with O.
ColR.
apply in_angle_two_sides; Col.
apply lea_in_angle.
apply (l11_30 P Q R P' Q' R'); CongA; apply sams_suma__lea123789 with A0 O A1; trivial.

*****
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A0 O A'' A'
+++++
apply out_one_side; Col; apply l6_7 with B; [|apply l6_6]; assert_diffs; apply bet_out; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').

*****
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HConga4 : CongA A O A' A' O A'').
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').

*****
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A O A' A' O A''
+++++
assert_diffs.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.

*****
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A O A' A' O A''
+++++
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A O A' A' O A''
+++++
apply conga_trans with A0 O A1; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A0 O A1 A' O A''
+++++
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R A' O A''
+++++
-
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R A' O A''
+++++
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS A0 O A' A' O A''
+++++
split; auto; split.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Out O A' A'') (not (Bet A0 O A'))
+++++
right; intro; Col.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.
right; intro; Col.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun J : Tpoint => and (CongA A' O J A' O A'') (and (not (OS O A' A0 J)) (and (not (TS A0 O A' J)) (Coplanar A0 O A' J))))
+++++
exists A''; repeat (split; CongA); Cop.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.
right; intro; Col.
exists A''; repeat (split; CongA); Cop.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS A0 O A' A'')
+++++
apply l9_9_bis, out_one_side; Col.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.
right; intro; Col.
exists A''; repeat (split; CongA); Cop.
apply l9_9_bis, out_one_side; Col.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A0 A' A''
+++++
apply bet_out; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.
right; intro; Col.
exists A''; repeat (split; CongA); Cop.
apply l9_9_bis, out_one_side; Col.
apply bet_out; auto.

*****

*****

+++++
-
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.
right; intro; Col.
exists A''; repeat (split; CongA); Cop.
apply l9_9_bis, out_one_side; Col.
apply bet_out; auto.
-

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P Q R A' O A'' P' Q' R'
+++++
apply (conga3_suma__suma A0 O A' A' O A'' A0 O A''); CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert_diffs.
assert (HNOS : ~ OS O A' A0 A'') by (apply l9_9; repeat split; auto; Col; exists A'; Col).
apply conga_trans with A0 O A1; trivial.
apply sams2_suma2__conga456 with P Q R P' Q' R'; trivial.
-
apply (conga2_sams__sams A0 O A' A' O A''); CongA.
split; auto; split.
right; intro; Col.
exists A''; repeat (split; CongA); Cop.
apply l9_9_bis, out_one_side; Col.
apply bet_out; auto.
-
apply (conga3_suma__suma A0 O A' A' O A'' A0 O A''); CongA.

*****
HNOS : not (OS O A' A0 A'')
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A0 O A' A' O A'' A0 O A''
+++++
exists A''; repeat (split; CongA); Cop.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').

*****
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
assert (HLe'' : Le A0 A1 A' A'').
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').

*****
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 A1 A' A''
+++++
apply le_transitivity with A A'; trivial; assert_diffs.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.

*****
H12 : not (eq R' Q')
H11 : not (eq P' Q')
H18 : not (eq A' A'')
H16 : not (eq A0 A'')
H13 : not (eq O A'')
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A A' A' A''
+++++
apply lt__le, acute_archi_aux with O A0 B; eBetween.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.
apply lt__le, acute_archi_aux with O A0 B; eBetween.

*****
HLe'' : Le A0 A1 A' A''
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A' : Tpoint => and (Bet A0 A1 A') (and (Bet A0 A' B) (and (CongA P' Q' R' A0 O A') (and (Le A0 C' A0 A') (ex (fun A : Tpoint => and (Bet A0 A A') (and (CongA A O A' A0 O A1) (Le A0 A1 A A'))))))))
+++++
exists A''; repeat (split; trivial).
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.
apply lt__le, acute_archi_aux with O A0 B; eBetween.
exists A''; repeat (split; trivial).

*****
HLe'' : Le A0 A1 A' A''
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A0 C' A0 A''
+++++
apply bet2_le2__le1346 with C A'; auto.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.
apply lt__le, acute_archi_aux with O A0 B; eBetween.
exists A''; repeat (split; trivial).
apply bet2_le2__le1346 with C A'; auto.

*****
HLe'' : Le A0 A1 A' A''
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C C' A' A''
+++++
apply (l5_6 A0 A1 A' A''); Cong.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.
apply lt__le, acute_archi_aux with O A0 B; eBetween.
exists A''; repeat (split; trivial).
apply bet2_le2__le1346 with C A'; auto.
apply (l5_6 A0 A1 A' A''); Cong.

*****
HLe'' : Le A0 A1 A' A''
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A : Tpoint => and (Bet A0 A A'') (and (CongA A O A'' A0 O A1) (Le A0 A1 A A'')))
+++++
exists A'; split; trivial; split; trivial.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.
apply lt__le, acute_archi_aux with O A0 B; eBetween.
exists A''; repeat (split; trivial).
apply bet2_le2__le1346 with C A'; auto.
apply (l5_6 A0 A1 A' A''); Cong.
exists A'; split; trivial; split; trivial.

*****
HLe'' : Le A0 A1 A' A''
HConga4 : CongA A O A' A' O A''
HBet4 : Bet A0 A' A''
HNCol5 : not (Col A0 O A'')
HNCol4 : not (Col A' O A'')
HNCol3 : not (Col A0 O A')
HNCol2 : not (Col A O A')
HConga'' : CongA P' Q' R' A0 O A''
HBet2'' : Bet A0 A'' B
HBet1'' : Bet A0 A1 A''
A'' : Tpoint
HGA' : GradA A0 O A1 P' Q' R'
HSuma : SumA P Q R A0 O A1 P' Q' R'
P',Q',R' : Tpoint
H10 : not (eq R Q)
H9 : not (eq A' O)
H8 : not (eq P Q)
H7 : not (eq A O)
H6 : not (eq A A')
H4 : not (eq A0 C')
H3 : not (eq C C')
H2 : not (eq A0 A')
HIsi : SAMS P Q R A0 O A1
HLe : Le A0 A1 A A'
HConga : CongA A O A' A0 O A1
HBet1 : Bet A0 A A'
A : Tpoint
HLe' : Le A0 C A0 A'
HConga' : CongA P Q R A0 O A'
HBet2' : Bet A0 A' B
HBet1' : Bet A0 A1 A'
A' : Tpoint
HGA : GradA A0 O A1 P Q R
P,Q,R : Tpoint
H5 : not (eq O B)
H1 : not (eq O A1)
HNCol1 : not (Col A0 O A1)
HNCol : not (Col O A0 B)
H0 : Cong A0 A1 C C'
H : Bet A0 C C'
HG : Grad A0 A1 C
C,C' : Tpoint
HA0A1 : not (eq A0 A1)
HBet : Bet A0 A1 B
A1 : Tpoint
HBA0 : not (eq B A0)
HOA0 : not (eq O A0)
HPer : Per O A0 B
O,B,A0 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A' O A'' A0 O A1
+++++
apply conga_trans with A O A'; CongA.
-----
Lemma acute_archi_aux2 : forall O A0 A1 B C, Per O A0 B -> O <> A0 -> B <> A0 -> Bet A0 A1 B -> A0 <> A1 -> Grad A0 A1 C -> exists P, exists Q, exists R, GradA A0 O A1 P Q R /\\ (LeA A0 O B P Q R \\/ exists A', Bet A0 A1 A' /\\ Bet A0 A' B /\\ CongA P Q R A0 O A' /\\ Le A0 C A0 A' /\\ exists A, Bet A0 A A' /\\ CongA A O A' A0 O A1 /\\ Le A0 A1 A A').
Proof.
intros O A0 A1 B E HPer HOA0 HBA0 HBet HA0A1 HG.
assert (HNCol : ~ Col O A0 B) by (apply per_not_col; auto).
assert (HNCol1 : ~ Col A0 O A1) by (intro; apply HNCol; ColR).
assert_diffs.
induction HG; rename A into A0; rename B0 into A1.
exists A0; exists O; exists A1; split; [apply grada_init; CongA|].
right; exists A1; repeat (split; CongA); Between; Le.
exists A0; repeat (split; CongA); Between; Le.
destruct IHHG as [P [Q [R [HGA HUn]]]]; auto.
destruct HUn as [HLea|HA'].
exists P; exists Q; exists R; split; trivial; left; trivial.
destruct HA' as [A' [HBet1' [HBet2' [HConga' [HLe' HA]]]]].
destruct HA as [A [HBet1 [HConga HLe]]].
assert (HIsi : SAMS P Q R A0 O A1).
assert_diffs.
destruct (ex_suma P Q R A0 O A1) as [P' [Q' [R' HSuma]]]; auto.
assert (HGA' : GradA A0 O A1 P' Q' R') by (apply grada_stab with P Q R; trivial).
exists P'; exists Q'; exists R'; split; trivial.
destruct (acute_archi_aux1 O A0 A1 B P' Q' R') as [HLea|HA'']; auto.
right; destruct HA'' as [A'' [HBet1'' [HBet2'' HConga'']]].
assert (HNCol2 : ~ Col A O A') by (apply (ncol_conga_ncol A0 O A1); Col; CongA).
assert (HNCol3 : ~ Col A0 O A') by (intro; assert_diffs; apply HNCol; ColR).
assert (HNCol4 : ~ Col A' O A'').
assert (HNCol5 : ~ Col A0 O A'') by (intro; assert_diffs; apply HNCol4; ColR).
assert (HBet4 : Bet A0 A' A'').
assert (HConga4 : CongA A O A' A' O A'').
assert (HLe'' : Le A0 A1 A' A'').
apply le_transitivity with A A'; trivial; assert_diffs.
apply lt__le, acute_archi_aux with O A0 B; eBetween.
exists A''; repeat (split; trivial).
apply bet2_le2__le1346 with C A'; auto.
apply (l5_6 A0 A1 A' A''); Cong.
exists A'; split; trivial; split; trivial.
apply conga_trans with A O A'; CongA.

*****

*****

+++++
Qed.
-----
Lemma archi_in_acute_angles :\n  archimedes_axiom ->\n  forall A B C D E F,\n    ~ Col A B C -> Acute D E F ->\n    exists P Q R, GradA A B C P Q R /\ LeA D E F P Q R.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : not (Col A B C)) (_ : Acute D E F), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
Proof.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : not (Col A B C)) (_ : Acute D E F), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
intros archi A B C D E F HNCol HAcute.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.

*****
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert_diffs.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.

*****
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
elim (col_dec D E F).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).

*****
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col D E F, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
intro HCol.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
exists A.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C A Q R) (LeA D E F A Q R)))
+++++
exists B.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C A B R) (LeA D E F A B R))
+++++
exists C.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C A B C) (LeA D E F A B C)
+++++
split.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C A B C
+++++
apply grada_init.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply grada_init.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A B C
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F A B C
+++++
apply l11_31_1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D F
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D F
+++++
apply not_bet_out.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D E F
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet D E F)
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet D E F)
+++++
intro HBet.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (nlta D E F), acute_obtuse__lta.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.
apply (nlta D E F), acute_obtuse__lta.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D E F
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.
apply (nlta D E F), acute_obtuse__lta.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse D E F
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.
apply (nlta D E F), acute_obtuse__lta.
trivial.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse D E F
+++++
apply bet__obtuse.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.
apply (nlta D E F), acute_obtuse__lta.
trivial.
apply bet__obtuse.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D E F
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.
apply (nlta D E F), acute_obtuse__lta.
trivial.
apply bet__obtuse.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.
auto.
apply not_bet_out.
trivial.
intro HBet.
apply (nlta D E F), acute_obtuse__lta.
trivial.
apply bet__obtuse.

*****
HBet : Bet D E F
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E F)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HCol.
exists A.
exists B.
exists C.
split.
apply l11_31_1.

*****
HCol : Col D E F
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C B)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).

*****
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col D E F), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
intro HNCol1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
elim (lea_total D E F A B C).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : LeA D E F A B C, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : LeA D E F A B C, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
intro HLea.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
exists A.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C A Q R) (LeA D E F A Q R)))
+++++
exists B.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.
exists B.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C A B R) (LeA D E F A B R))
+++++
exists C.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.
exists B.
exists C.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C A B C) (LeA D E F A B C)
+++++
split.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.
exists B.
exists C.
split.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C A B C
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.
exists B.
exists C.
split.
trivial.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C A B C
+++++
apply grada_init.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.
exists B.
exists C.
split.
trivial.
apply grada_init.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A B C
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
exists A.
exists B.
exists C.
split.

*****
HLea : LeA D E F A B C
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F A B C
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : LeA A B C D E F, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : LeA A B C D E F, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
intro HLea.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.

*****
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].

*****
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D E F)
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert (HOut : Out E D0 D).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D0 D
+++++
apply acute_col_perp__out with F.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute F E D
+++++
Col.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.
Col.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute F E D
+++++
Perp.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.
Col.
Perp.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute F E D
+++++
apply acute_sym.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.
Col.
Perp.
apply acute_sym.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D E F
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col E D D0
+++++
Col.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp E D F D0
+++++
Col.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
apply acute_col_perp__out with F.
Col.

*****
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp E D F D0
+++++
Perp.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).

*****
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
idtac.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.

*****
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert_diffs.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert (HConga : CongA D E F D0 E F).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D0 E F
+++++
apply (out_conga D0 E F D0 E F).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D0 E F D0 E F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D0 D
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E F F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).
CongA.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E F F
+++++
apply out_trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).
CongA.
apply out_trivial.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F E)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D0 D0
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).
CongA.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D0 D0
+++++
apply out_trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).
CongA.
apply out_trivial.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D0 E)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E F F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).
CongA.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E F F
+++++
apply out_trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
apply (out_conga D0 E F D0 E F).
CongA.
apply out_trivial.

*****
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F E)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
idtac.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
apply (acute_conga__acute D E F D0 E F) in HAcute.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert (HPer : Per E D0 F).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per E D0 F
+++++
apply perp_per_1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
apply perp_per_1.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp D0 E F D0
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
apply perp_per_1.
auto.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp D0 E F D0
+++++
apply perp_left_comm, perp_col with D.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with D.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E D0)
+++++
Perp.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with D.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp E D F D0
+++++
Perp.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with D.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col E D D0
+++++
Perp.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
apply perp_per_1.
auto.
apply perp_left_comm, perp_col with D.
Perp.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col E D D0
+++++
Col.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).

*****
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
idtac.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.

*****
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
clear H0 HD0 HD0' HOut H9.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.

*****
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].

*****
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].

*****
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D0 E F)
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D0 E D1' D0 E F
+++++
Side.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D0 E D1' D0 E F
+++++
apply (l11_30 A B C D0 E F).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
apply (l11_30 A B C D0 E F).

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C D0 E F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
apply (l11_30 A B C D0 E F).

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C D0 E D1'
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
apply (l11_30 A B C D0 E F).

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D0 E F D0 E F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].

*****
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS D0 E F D1'
+++++
Side.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].

*****
HUn : or (eq D1 E) (Out E D1 D1')
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
Side.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.

*****
HUn : or (eq D1 E) (Out E D1 D1')
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct HUn as [Heq|HOut].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].

*****
Heq : eq D1 E
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
exfalso.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
exfalso.

*****
Heq : eq D1 E
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst D1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
exfalso.
subst D1.

*****
HBet : Bet D0 E F
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].

*****
HOut : Out E D1 D1'
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
apply l6_6 in HOut.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
try (apply out_trivial; auto).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
apply one_side_not_col123 in HOS.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert_diffs.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.

*****
H : not (eq D E)
H8 : not (eq D1 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
assert (D0 <> D1).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).

*****
H : not (eq D E)
H8 : not (eq D1 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D0 D1)
+++++
intro.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
intro.

*****
H0 : eq D0 D1
H : not (eq D E)
H8 : not (eq D1 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst D1.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
intro.
subst D1.

*****
H : not (eq D E)
H8 : not (eq D0 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HBet : Bet D0 D0 F
HOut : Out E D1' D0
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D0
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_cols.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
intro.
subst D1.
assert_cols.

*****
H9 : Col E D1' D0
H0 : Col D0 D0 F
H : not (eq D E)
H8 : not (eq D0 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HBet : Bet D0 D0 F
HOut : Out E D1' D0
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D0
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).

*****
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
idtac.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.

*****
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
H10 : not (eq D0 D1')
H7 : not (eq E D1')
HOut : Out E D1' D1
HBet : Bet D0 D1 F
HOS : not (Col D0 E D1')
HConga1 : CongA A B C D0 E D1
D1',D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
clear dependent D1'.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.

*****
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].

*****
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].

*****
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D0 D1)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per E D0 F
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E D0)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F D0)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D0 D1 F
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D0 D1)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Grad D0 D1 G
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))))
+++++
exists P.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R)))
+++++
exists Q.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P Q R) (LeA D E F P Q R))
+++++
exists R.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P Q R) (LeA D E F P Q R)
+++++
split.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA).

*****
Hdistincts : and (not (eq D0 E))\n (and (not (eq D1 E)) (and (not (eq P Q)) (not (eq R Q))))
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
spliter.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA).
spliter.

*****
H11 : not (eq R Q)
H10 : not (eq P Q)
H9 : not (eq D1 E)
H7 : not (eq D0 E)
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
apply (conga2_grada__grada D0 E D1 P Q R).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA).
spliter.
apply (conga2_grada__grada D0 E D1 P Q R).

*****
H11 : not (eq R Q)
H10 : not (eq P Q)
H9 : not (eq D1 E)
H7 : not (eq D0 E)
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA D0 E D1 P Q R
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA).
spliter.
apply (conga2_grada__grada D0 E D1 P Q R).

*****
H11 : not (eq R Q)
H10 : not (eq P Q)
H9 : not (eq D1 E)
H7 : not (eq D0 E)
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D0 E D1 A B C
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
assert (Hdistincts := grada_distincts D0 E D1 P Q R HGA).
spliter.
apply (conga2_grada__grada D0 E D1 P Q R).

*****
H11 : not (eq R Q)
H10 : not (eq P Q)
H9 : not (eq D1 E)
H7 : not (eq D0 E)
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA P Q R P Q R
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HUn : or (LeA D0 E F P Q R)\n (ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
destruct HUn as [HLea2|Habs].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].

*****
HLea2 : LeA D0 E F P Q R
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
assert_diffs.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
assert_diffs.

*****
H16 : not (eq R Q)
H13 : not (eq P Q)
H10 : not (eq D0 G)
H9 : not (eq F F')
H7 : not (eq D0 F')
HLea2 : LeA D0 E F P Q R
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
apply (l11_30 D0 E F P Q R).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
assert_diffs.
apply (l11_30 D0 E F P Q R).

*****
H16 : not (eq R Q)
H13 : not (eq P Q)
H10 : not (eq D0 G)
H9 : not (eq F F')
H7 : not (eq D0 F')
HLea2 : LeA D0 E F P Q R
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D0 E F P Q R
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
assert_diffs.
apply (l11_30 D0 E F P Q R).

*****
H16 : not (eq R Q)
H13 : not (eq P Q)
H10 : not (eq D0 G)
H9 : not (eq F F')
H7 : not (eq D0 F')
HLea2 : LeA D0 E F P Q R
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D0 E F D E F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
assert_diffs.
apply (l11_30 D0 E F P Q R).

*****
H16 : not (eq R Q)
H13 : not (eq P Q)
H10 : not (eq D0 G)
H9 : not (eq F F')
H7 : not (eq D0 F')
HLea2 : LeA D0 E F P Q R
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA P Q R P Q R
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].

*****
Habs : ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A'))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
exfalso.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.

*****
Habs : ex\n (fun A' : Tpoint =>\n and (Bet D0 D1 A')\n (and (Bet D0 A' F)\n (and (CongA P Q R D0 E A')\n (and (Le D0 G D0 A')\n (ex\n (fun A : Tpoint =>\n and (Bet D0 A A')\n (and (CongA A E A' D0 E D1) (Le D0 D1 A A'))))))))
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (le__nlt D0 F' D0 G).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D0 F' D0 G
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt D0 G D0 F'
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt D0 G D0 F'
+++++
apply le1234_lt__lt with D0 F.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D0 G D0 F
+++++
apply le_transitivity with D0 A'.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
apply le_transitivity with D0 A'.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D0 G D0 A'
+++++
Le.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
apply le_transitivity with D0 A'.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D0 A' D0 F
+++++
Le.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt D0 F D0 F'
+++++
split.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le D0 F D0 F'
+++++
Le.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong D0 F D0 F')
+++++
Le.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.

*****
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong D0 F D0 F')
+++++
intro HCong.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.

*****
HCong : Cong D0 F D0 F'
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (F = F').
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.
assert (F = F').

*****
HCong : Cong D0 F D0 F'
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq F F'
+++++
apply between_cong with D0.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.
assert (F = F').
apply between_cong with D0.

*****
HCong : Cong D0 F D0 F'
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D0 F F'
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.
assert (F = F').
apply between_cong with D0.

*****
HCong : Cong D0 F D0 F'
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong D0 F D0 F'
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.
assert (F = F').

*****
H7 : eq F F'
HCong : Cong D0 F D0 F'
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.
assert (F = F').
idtac.

*****
H7 : eq F F'
HCong : Cong D0 F D0 F'
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A A') (and (CongA A E A' D0 E D1) (Le D0 D1 A A')))
HLe : Le D0 G D0 A'
HConga2 : CongA P Q R D0 E A'
HBet3 : Bet D0 A' F
HBet2 : Bet D0 D1 A'
A' : Tpoint
HGA : GradA D0 E D1 P Q R
P,Q,R : Tpoint
HG2 : Le D0 F' D0 G
HG1 : Grad D0 D1 G
G : Tpoint
HF'2 : Cong F F' D0 F
HF'1 : Bet D0 F F'
F' : Tpoint
H0 : not (eq D0 D1)
H : not (eq D E)
H8 : not (eq D1 E)
HBet : Bet D0 D1 F
HConga1 : CongA A B C D0 E D1
D1 : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.
try (apply out_trivial; auto).
apply one_side_not_col123 in HOS.
assert_diffs.
assert (D0 <> D1).
idtac.
clear dependent D1'.
destruct (segment_construction D0 F D0 F) as [F' [HF'1 HF'2]].
destruct (archi D0 D1 D0 F') as [G [HG1 HG2]].
auto.
destruct (acute_archi_aux2 E D0 D1 F G) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
destruct HUn as [HLea2|Habs].
exfalso.
destruct Habs as [A' [HBet2 [HBet3 [HConga2 [HLe HA]]]]].
apply (le__nlt D0 F' D0 G).
trivial.
apply le1234_lt__lt with D0 F.
split.
Le.
intro HCong.
assert (F = F').
idtac.
treat_equalities.

*****
HConga2 : CongA P Q R D0 E D0
HGA : GradA D0 E D0 P Q R
HA : ex\n (fun A : Tpoint =>\n and (Bet D0 A D0) (and (CongA A E D0 D0 E D0) (Le D0 D0 A D0)))
P,Q,R : Tpoint
HG1 : Grad D0 D0 D0
HG2 : Le D0 D0 D0 D0
H : not (eq D E)
HConga1 : CongA A B C D0 E D0
HConga : CongA D E D0 D0 E D0
HPer : Per E D0 D0
H3 : not (eq D0 E)
HNCol1 : not (Col D0 E D0)
HLea : LeA A B C D0 E D0
H6 : not (eq D0 D0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E D0
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A A
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A A
+++++
try (apply out_trivial; auto).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B C C
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B C C
+++++
try (apply out_trivial; auto).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D0 D0
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.
trivial.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D0 D0
+++++
try (apply out_trivial; auto).
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.
trivial.
assert (HPer : Per E D0 F).
idtac.
clear H0 HD0 HD0' HOut H9.
destruct (angle_construction_1 A B C D0 E F) as [D1' [HConga1 HOS]].
trivial.
destruct (lea_in_angle D0 E F D1') as [_ [_ [_ [D1 [HBet HUn]]]]].
Side.
destruct HUn as [Heq|HOut].
apply l6_6 in HOut.
apply (out_conga A B C D0 E D1' A C D0 D1) in HConga1.

*****
HOut : Out E D1' D1
HBet : Bet D0 D1 F
D1 : Tpoint
HOS : OS D0 E D1' F
HConga1 : CongA A B C D0 E D1'
D1' : Tpoint
HPer : Per E D0 F
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
HLea : LeA A B C D0 E F
HNCol1 : not (Col D0 E F)
H3 : not (eq F E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D1' D1
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.
CongA.
apply (ncol_conga_ncol D E F D0 E F) in HNCol1.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D0 E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D0 E F
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C A B C
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.
trivial.
apply (l11_30 A B C D E F A B C D0 E F) in HLea.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D0 E F
D0 : Tpoint
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D0 E F
+++++
CongA.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).
auto.
intro HLea.
destruct (l8_18_existence D E F) as [D0 [HD0 HD0']].
trivial.
assert (HOut : Out E D0 D).
idtac.
assert_diffs.
assert (HConga : CongA D E F D0 E F).
idtac.
apply (acute_conga__acute D E F D0 E F) in HAcute.

*****
HConga : CongA D E F D0 E F
H5 : not (eq D0 E)
H6 : not (eq F D0)
H9 : not (eq D F)
HOut : Out E D0 D
HD0' : Perp D E F D0
HD0 : Col D E D0
D0 : Tpoint
HLea : LeA A B C D E F
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D0 E F
+++++
trivial.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E F)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).
intro HNCol1.
elim (lea_total D E F A B C).

*****
HNCol1 : not (Col D E F)
H3 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HAcute : Acute D E F
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
auto.
-----
Lemma archi_in_acute_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> Acute D E F -> exists P Q R, GradA A B C P Q R /\\ LeA D E F P Q R.
Proof.
intros archi A B C D E F HNCol HAcute.
assert_diffs.
elim (col_dec D E F).

*****

*****

+++++
Qed.
-----
Lemma angles_archi_aux :\n  forall A B C D E F G H I,\n    GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I ->\n    exists P Q R, GradA A B C P Q R /\ ~ SAMS P Q R A B C.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F G H I : Tpoint) (_ : GradA A B C D E F) (_ : GradA A B C G H I) (_ : not (SAMS D E F G H I)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
Proof.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F G H I : Tpoint) (_ : GradA A B C D E F) (_ : GradA A B C G H I) (_ : not (SAMS D E F G H I)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
intros A B C D E F G H I HGA1 HGA2.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.

*****
HGA2 : GradA A B C G H I
HGA1 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (SAMS D E F G H I), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
induction HGA2.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.

*****
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (SAMS D E F D0 E0 F0), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
intro HNIsi.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
exists D.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C D Q R) (not (SAMS D Q R A B C))))
+++++
exists E.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C D E R) (not (SAMS D E R A B C)))
+++++
exists F.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C D E F) (not (SAMS D E F A B C))
+++++
split.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS D E F A B C)
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.

*****
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS D E F A B C)
+++++
assert (Hd := grada_distincts A B C D E F HGA1).
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.
assert (Hd := grada_distincts A B C D E F HGA1).

*****
Hd : and (not (eq A B))\n (and (not (eq C B)) (and (not (eq D E)) (not (eq F E))))
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS D E F A B C)
+++++
spliter.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.
assert (Hd := grada_distincts A B C D E F HGA1).
spliter.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS D E F A B C)
+++++
intro HIsi.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.
assert (Hd := grada_distincts A B C D E F HGA1).
spliter.
intro HIsi.

*****
HIsi : SAMS D E F A B C
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNIsi, (conga2_sams__sams D E F A B C).
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.
assert (Hd := grada_distincts A B C D E F HGA1).
spliter.
intro HIsi.
apply HNIsi, (conga2_sams__sams D E F A B C).

*****
HIsi : SAMS D E F A B C
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F D E F
+++++
CongA.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.
assert (Hd := grada_distincts A B C D E F HGA1).
spliter.
intro HIsi.
apply HNIsi, (conga2_sams__sams D E F A B C).

*****
HIsi : SAMS D E F A B C
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C D0 E0 F0
+++++
CongA.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
exists D.
exists E.
exists F.
split.
trivial.
assert (Hd := grada_distincts A B C D E F HGA1).
spliter.
intro HIsi.
apply HNIsi, (conga2_sams__sams D E F A B C).

*****
HIsi : SAMS D E F A B C
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
HNIsi : not (SAMS D E F D0 E0 F0)
H : CongA A B C D0 E0 F0
D0,E0,F0 : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F A B C
+++++
CongA.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.

*****
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (SAMS D E F G H I), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
intro HNIsi.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.

*****
HNIsi : not (SAMS D E F G H I)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
elim (sams_dec D E F D0 E0 F0).
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).

*****
HNIsi : not (SAMS D E F G H I)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SAMS D E F D0 E0 F0, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
idtac.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.

*****
HNIsi : not (SAMS D E F G H I)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SAMS D E F D0 E0 F0, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
intro HIsi.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.

*****
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
clear IHHGA2.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.

*****
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).

*****
Hd : and (not (eq D E))\n (and (not (eq E F)) (and (not (eq D0 E0)) (not (eq E0 F0))))
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
spliter.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.

*****
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].

*****
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
auto.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].

*****
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E F)
+++++
auto.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].

*****
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D0 E0)
+++++
auto.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].

*****
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E0 F0)
+++++
auto.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
auto.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
exists P.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C))))
+++++
exists Q.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))
+++++
exists R.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P Q R) (not (SAMS P Q R A B C))
+++++
split.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
apply grada2_sams_suma__grada with D E F D0 E0 F0.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with D E F D0 E0 F0.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with D E F D0 E0 F0.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D0 E0 F0
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with D E F D0 E0 F0.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D0 E0 F0
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with D E F D0 E0 F0.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F D0 E0 F0 P Q R
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R A B C)
+++++
intro HIsi2.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
intro HIsi2.

*****
HIsi2 : SAMS P Q R A B C
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
intro HIsi2.
apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R.

*****
HIsi2 : SAMS P Q R A B C
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F D0 E0 F0
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
intro HIsi2.
apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R.

*****
HIsi2 : SAMS P Q R A B C
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D0 E0 F0 A B C
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
intro HIsi2.
apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R.

*****
HIsi2 : SAMS P Q R A B C
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F D0 E0 F0 P Q R
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
intro HIsi2.
apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R.

*****
HIsi2 : SAMS P Q R A B C
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D0 E0 F0 A B C G H I
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
idtac.
intro HIsi.
clear IHHGA2.
assert (Hd := sams_distincts D E F D0 E0 F0 HIsi).
spliter.
destruct (ex_suma D E F D0 E0 F0) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
intro HIsi2.
apply HNIsi, sams_assoc_1 with D0 E0 F0 A B C P Q R.

*****
HIsi2 : SAMS P Q R A B C
HSuma : SumA D E F D0 E0 F0 P Q R
P,Q,R : Tpoint
H5 : not (eq E0 F0)
H4 : not (eq D0 E0)
H3 : not (eq E F)
H2 : not (eq D E)
HIsi : SAMS D E F D0 E0 F0
HNIsi : not (SAMS D E F G H I)
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R A B C
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).

*****
HNIsi : not (SAMS D E F G H I)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (SAMS D E F D0 E0 F0), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
apply IHHGA2.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.
intro HNIsi.
elim (sams_dec D E F D0 E0 F0).
apply IHHGA2.

*****
HNIsi : not (SAMS D E F G H I)
IHHGA2 : forall (_ : GradA A B C D E F) (_ : not (SAMS D E F D0 E0 F0)),\nex\n (fun P : Tpoint =>\n ex\n (fun Q : Tpoint =>\n ex\n (fun R : Tpoint =>\n and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
H1 : SumA D0 E0 F0 A B C G H I
H0 : SAMS D0 E0 F0 A B C
HGA2 : GradA A B C D0 E0 F0
D0,E0,F0,G,H,I : Tpoint
HGA1 : GradA A B C D E F
D,E,F,A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C D E F
+++++
trivial.
-----
Lemma angles_archi_aux : forall A B C D E F G H I, GradA A B C D E F -> GradA A B C G H I -> ~ SAMS D E F G H I -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros A B C D E F G H I HGA1 HGA2.
induction HGA2.

*****

*****

+++++
Qed.
-----
Lemma angles_archi_aux1 :\n  archimedes_axiom ->\n  forall A B C D E F,\n    ~ Col A B C -> ~ Bet D E F ->\n    exists P Q R, GradA A B C P Q R /\ (LeA D E F P Q R \/ ~ SAMS P Q R A B C).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : not (Col A B C)) (_ : not (Bet D E F)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
Proof.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : not (Col A B C)) (_ : not (Bet D E F)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
intros archi A B C D E F HNCol HNBet.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.

*****
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert (Hdiff : D <> E /\ F <> E).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).

*****
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq D E)) (not (eq F E))
+++++
split.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
split.

*****
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
intro.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
split.
intro.

*****
H : eq D E
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst E.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
split.
intro.
subst E.

*****
HNBet : not (Bet D D F)
HNCol : not (Col A B C)
A,B,C,D,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Between.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
split.

*****
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F E)
+++++
intro.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
split.
intro.

*****
H : eq F E
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst E.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
split.
intro.
subst E.

*****
HNBet : not (Bet D F F)
HNCol : not (Col A B C)
A,B,C,D,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Between.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).

*****
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
idtac.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.

*****
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert_diffs.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.

*****
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].

*****
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].

*****
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F E)
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].

*****
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.

*****
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert(HNOS : ~ OS E F1 D F).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).

*****
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS E F1 D F)
+++++
assert_diffs.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.

*****
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS E F1 D F)
+++++
elim (col_dec D E F1).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).

*****
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col D E F1, not (OS E F1 D F)
+++++
intros HCol.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intros HCol.

*****
HCol : Col D E F1
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS E F1 D F)
+++++
apply col123__nos.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intros HCol.
apply col123__nos.

*****
HCol : Col D E F1
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col E F1 D
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).

*****
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col D E F1), not (OS E F1 D F)
+++++
intro HNCol1.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS E F1 D F)
+++++
apply l9_9, invert_two_sides, in_angle_two_sides.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.
apply l9_9, invert_two_sides, in_angle_two_sides.

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col E D F1)
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.
apply l9_9, invert_two_sides, in_angle_two_sides.

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col E F F1)
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.
apply l9_9, invert_two_sides, in_angle_two_sides.
Col.

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col E F F1)
+++++
apply not_col_permutation_1, (ncol_conga_ncol D E F1).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.
apply l9_9, invert_two_sides, in_angle_two_sides.
Col.
apply not_col_permutation_1, (ncol_conga_ncol D E F1).

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D E F1)
+++++
CongA.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.
apply l9_9, invert_two_sides, in_angle_two_sides.
Col.
apply not_col_permutation_1, (ncol_conga_ncol D E F1).

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA D E F1 F1 E F
+++++
CongA.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert_diffs.
elim (col_dec D E F1).
intro HNCol1.
apply l9_9, invert_two_sides, in_angle_two_sides.

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle F1 D E F
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).

*****
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert (HSuma : SumA D E F1 D E F1 D E F).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).

*****
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F1 D E F1 D E F
+++++
assert_diffs.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
assert_diffs.

*****
H : not (eq F1 E)
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F1 D E F1 D E F
+++++
exists F.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
assert_diffs.
exists F.

*****
H : not (eq F1 E)
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA F1 E F D E F1) (and (not (OS E F1 D F)) (and (Coplanar D E F1 F) (CongA D E F D E F)))
+++++
repeat (split; CongA).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
assert_diffs.
exists F.
repeat (split; CongA).

*****
H : not (eq F1 E)
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar D E F1 F
+++++
Cop.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
idtac.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D E F1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute D E F1
+++++
apply nbet_sams_suma__acute with D E F.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet D E F)
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F1 D E F1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F1 D E F1
+++++
assert_diffs.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F1 D E F1
+++++
split.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (or (Out E D F1) (not (Bet D E F1))) (ex (fun J : Tpoint => and (CongA F1 E J D E F1) (and (not (OS E F1 D J)) (and (not (TS D E F1 J)) (Coplanar D E F1 J)))))
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (or (Out E D F1) (not (Bet D E F1))) (ex (fun J : Tpoint => and (CongA F1 E J D E F1) (and (not (OS E F1 D J)) (and (not (TS D E F1 J)) (Coplanar D E F1 J)))))
+++++
split.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Out E D F1) (not (Bet D E F1))
+++++
right.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
right.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet D E F1)
+++++
intro HBet.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
right.
intro HBet.

*****
HBet : Bet D E F1
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNBet, bet_in_angle_bet with F1.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
right.
intro HBet.
apply HNBet, bet_in_angle_bet with F1.

*****
HBet : Bet D E F1
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet D E F1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
right.
intro HBet.
apply HNBet, bet_in_angle_bet with F1.

*****
HBet : Bet D E F1
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle F1 D E F
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun J : Tpoint => and (CongA F1 E J D E F1) (and (not (OS E F1 D J)) (and (not (TS D E F1 J)) (Coplanar D E F1 J))))
+++++
exists F.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA F1 E F D E F1) (and (not (OS E F1 D F)) (and (not (TS D E F1 F)) (Coplanar D E F1 F)))
+++++
repeat (split; CongA).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS D E F1 F)
+++++
Cop.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS D E F1 F)
+++++
elim (col_dec D E F1).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col D E F1, not (TS D E F1 F)
+++++
intros HCol HTS.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intros HCol HTS.

*****
HTS : TS D E F1 F
HCol : Col D E F1
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HTS.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intros HCol HTS.
destruct HTS.

*****
H6 : and (not (Col F D E))\n (ex (fun T : Tpoint => and (Col T D E) (Bet F1 T F)))
H5 : not (Col F1 D E)
HCol : Col D E F1
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col D E F1), not (TS D E F1 F)
+++++
intro HNCol1.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS D E F1 F)
+++++
elim (col_dec D E F).
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col D E F, not (TS D E F1 F)
+++++
intros HCol HTS.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).
intros HCol HTS.

*****
HTS : TS D E F1 F
HCol : Col D E F
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HTS as [_ []].
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).
intros HCol HTS.
destruct HTS as [_ []].

*****
H6 : ex (fun T : Tpoint => and (Col T D E) (Bet F1 T F))
H5 : not (Col F D E)
HCol : Col D E F
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).

*****
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col D E F), not (TS D E F1 F)
+++++
intro HNCol2.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).
intro HNCol2.

*****
HNCol2 : not (Col D E F)
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS D E F1 F)
+++++
apply l9_9_bis, in_angle_one_side.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).
intro HNCol2.
apply l9_9_bis, in_angle_one_side.

*****
HNCol2 : not (Col D E F)
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D E F)
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).
intro HNCol2.
apply l9_9_bis, in_angle_one_side.

*****
HNCol2 : not (Col D E F)
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col E D F1)
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).
Cop.
elim (col_dec D E F1).
intro HNCol1.
elim (col_dec D E F).
intro HNCol2.
apply l9_9_bis, in_angle_one_side.

*****
HNCol2 : not (Col D E F)
HNCol1 : not (Col D E F1)
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle F1 D E F
+++++
Col.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.
trivial.
assert_diffs.
split.
trivial.
split.
exists F.
repeat (split; CongA).

*****
H : not (eq F1 E)
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar D E F1 F
+++++
Cop.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
apply nbet_sams_suma__acute with D E F.

*****
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F1 D E F1 D E F
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].

*****
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.

*****
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert_diffs.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.

*****
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].

*****
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].

*****
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P1 Q1)
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].

*****
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q1 R1)
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].

*****
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P1 Q1)
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].

*****
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q1 R1)
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
exists P.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C)))))
+++++
exists Q.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))
+++++
exists R.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C)))
+++++
split.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
apply grada2_sams_suma__grada with P1 Q1 R1 P1 Q1 R1.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P1 Q1 R1 P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada2_sams_suma__grada with P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P1 Q1 R1 P1 Q1 R1 P Q R
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA D E F P Q R) (not (SAMS P Q R A B C))
+++++
left.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
left.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
left.
apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F1 P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
left.
apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F1 P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
left.
apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P1 Q1 R1 P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
left.
apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F1 D E F1 D E F
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (ex_suma P1 Q1 R1 P1 Q1 R1) as [P [Q [R HSuma1]]].
auto.
exists P.
exists Q.
exists R.
split.
left.
apply sams_lea2_suma2__lea with D E F1 D E F1 P1 Q1 R1 P1 Q1 R1.

*****
HSuma1 : SumA P1 Q1 R1 P1 Q1 R1 P Q R
P,Q,R : Tpoint
HIsi : SAMS P1 Q1 R1 P1 Q1 R1
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P1 Q1 R1 P1 Q1 R1 P Q R
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].

*****
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].

*****
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].

*****
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P1 Q1 R1
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].

*****
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P1 Q1 R1 P1 Q1 R1)
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
trivial.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
trivial.

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
exists P.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
trivial.
exists P.

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C)))))
+++++
exists Q.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
trivial.
exists P.
exists Q.

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))
+++++
exists R.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
trivial.
exists P.
exists Q.
exists R.

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C)))
+++++
split.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
trivial.
exists P.
exists Q.
exists R.
split.

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).
idtac.
assert_diffs.
destruct (angle_bisector D E F) as [F1 [HInangle HConga]].
auto.
assert(HNOS : ~ OS E F1 D F).
assert (HSuma : SumA D E F1 D E F1 D E F).
idtac.
destruct (archi_in_acute_angles archi A B C D E F1) as [P1 [Q1 [R1 [HGA HLea]]]].
trivial.
assert_diffs.
destruct (sams_dec P1 Q1 R1 P1 Q1 R1) as [HIsi|HNIsi].
destruct (angles_archi_aux A B C P1 Q1 R1 P1 Q1 R1) as [P [Q [R [HGA1 HNsams1]]]].
trivial.
exists P.
exists Q.
exists R.
split.

*****
HNsams1 : not (SAMS P Q R A B C)
HGA1 : GradA A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS P1 Q1 R1 P1 Q1 R1)
H10 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H : not (eq F1 E)
HLea : LeA D E F1 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HSuma : SumA D E F1 D E F1 D E F
HNOS : not (OS E F1 D F)
HConga : CongA F1 E D F1 E F
HInangle : InAngle F1 D E F
F1 : Tpoint
H3 : not (eq E F)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
Hdiff : and (not (eq D E)) (not (eq F E))
HNBet : not (Bet D E F)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA D E F P Q R) (not (SAMS P Q R A B C))
+++++
auto.
-----
Lemma angles_archi_aux1 : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> ~ Bet D E F -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HNBet.
assert (Hdiff : D <> E /\\ F <> E).

*****

*****

+++++
Qed.
-----
Lemma archi_in_angles :\n  archimedes_axiom ->\n  forall A B C D E F,\n    ~ Col A B C -> D <> E -> F <> E ->\n    exists P Q R, GradA A B C P Q R /\ (LeA D E F P Q R \/ ~ SAMS P Q R A B C).
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : not (Col A B C)) (_ : not (eq D E)) (_ : not (eq F E)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
Proof.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : not (Col A B C)) (_ : not (eq D E)) (_ : not (eq F E)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
intros archi A B C D E F HNCol HDE HFE.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.

*****
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
elim (bet_dec D E F).
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).

*****
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet D E F, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
idtac.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.

*****
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet D E F, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
intro HBet1.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.

*****
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].

*****
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert_diffs.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.

*****
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert (HNCol1 : ~ Col A0 B C).
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).

*****
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A0 B C)
+++++
intro.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
intro.

*****
H5 : Col A0 B C
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
intro.
apply HNCol.

*****
H5 : Col A0 B C
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).

*****
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
idtac.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.

*****
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].

*****
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
Between.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].

*****
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet C B A0)
+++++
Between.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].

*****
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
Between.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.

*****
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
elim (sams_dec P1 Q1 R1 A B C).
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).

*****
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SAMS P1 Q1 R1 A B C, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
idtac.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.

*****
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SAMS P1 Q1 R1 A B C, ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
intro HIsi.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.

*****
HIsi : SAMS P1 Q1 R1 A B C
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct HUn as [HLea|HNIsi].
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].

*****
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
idtac.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.

*****
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
assert_diffs.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.

*****
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].

*****
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P1 Q1)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].

*****
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q1 R1)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].

*****
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].

*****
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
exists P.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C)))))
+++++
exists Q.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))
+++++
exists R.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C)))
+++++
split.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
apply grada_stab with P1 Q1 R1.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada_stab with P1 Q1 R1.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P1 Q1 R1
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada_stab with P1 Q1 R1.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P1 Q1 R1 A B C
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
apply grada_stab with P1 Q1 R1.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P1 Q1 R1 A B C P Q R
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA D E F P Q R) (not (SAMS P Q R A B C))
+++++
suma.assert_diffs.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (LeA D E F P Q R) (not (SAMS P Q R A B C))
+++++
left.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
apply l11_31_2.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D E)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq F E)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq R Q)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q R
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q R
+++++
apply (bet_lea__bet A B A0).
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B A0
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B A0 P Q R
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B A0 P Q R
+++++
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A0 B C P1 Q1 R1
+++++
Lea.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C A B C
+++++
Lea.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P1 Q1 R1 A B C
+++++
Lea.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A0 B C A B C A B A0
+++++
Lea.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA A0 B C A B C A B A0
+++++
exists A.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA C B A A B C) (and (not (OS B C A0 A)) (and (Coplanar A0 B C A) (CongA A0 B A A B A0)))
+++++
repeat (split; CongA).
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS B C A0 A)
+++++
Cop.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (OS B C A0 A)
+++++
apply l9_9.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B C A0 A
+++++
repeat split.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A0 B C)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T B C) (Bet A0 T A))
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.
auto.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T B C) (Bet A0 T A))
+++++
exists B.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.
auto.
exists B.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col B B C) (Bet A0 B A)
+++++
split.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.
auto.
exists B.
split.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B C
+++++
Col.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.
auto.
exists B.
split.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 B A
+++++
Col.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).
Cop.
apply l9_9.
repeat split.
auto.
exists B.
split.
Col.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A0 B A
+++++
Between.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.
Lea.
exists A.
repeat (split; CongA).

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A0 B C A
+++++
Cop.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
idtac.
assert_diffs.
destruct (ex_suma P1 Q1 R1 A B C) as [P [Q [R HSuma]]].
auto.
exists P.
exists Q.
exists R.
split.
suma.assert_diffs.
left.
apply l11_31_2.
auto.
apply (bet_lea__bet A B A0).
trivial.
apply sams_lea2_suma2__lea with A0 B C A B C P1 Q1 R1 A B C.

*****
H15 : not (eq Q R)
H13 : not (eq P Q)
HSuma : SumA P1 Q1 R1 A B C P Q R
P,Q,R : Tpoint
H11 : not (eq R1 Q1)
H7 : not (eq P1 Q1)
H10 : not (eq A0 C)
HIsi : SAMS P1 Q1 R1 A B C
HLea : LeA C B A0 P1 Q1 R1
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P1 Q1 R1 A B C P Q R
+++++
Lea.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].

*****
HIsi : SAMS P1 Q1 R1 A B C
HNIsi : not (SAMS P1 Q1 R1 A B C)
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
exfalso.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
idtac.
intro HIsi.
destruct HUn as [HLea|HNIsi].
exfalso.

*****
HIsi : SAMS P1 Q1 R1 A B C
HNIsi : not (SAMS P1 Q1 R1 A B C)
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).

*****
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (SAMS P1 Q1 R1 A B C), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
intro.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
intro.

*****
H5 : not (SAMS P1 Q1 R1 A B C)
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
exists P1.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
intro.
exists P1.

*****
H5 : not (SAMS P1 Q1 R1 A B C)
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P1 Q R) (or (LeA D E F P1 Q R) (not (SAMS P1 Q R A B C)))))
+++++
exists Q1.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
intro.
exists P1.
exists Q1.

*****
H5 : not (SAMS P1 Q1 R1 A B C)
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P1 Q1 R) (or (LeA D E F P1 Q1 R) (not (SAMS P1 Q1 R A B C))))
+++++
exists R1.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
idtac.
intro HBet1.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
assert (HNCol1 : ~ Col A0 B C).
idtac.
destruct (angles_archi_aux1 archi A B C C B A0) as [P1 [Q1 [R1 [HGA HUn]]]].
Between.
elim (sams_dec P1 Q1 R1 A B C).
intro.
exists P1.
exists Q1.
exists R1.

*****
H5 : not (SAMS P1 Q1 R1 A B C)
HUn : or (LeA C B A0 P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C))
HGA : GradA A B C P1 Q1 R1
P1,Q1,R1 : Tpoint
HNCol1 : not (Col A0 B C)
H3 : not (eq B A0)
H0 : not (eq D F)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HBet1 : Bet D E F
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P1 Q1 R1) (or (LeA D E F P1 Q1 R1) (not (SAMS P1 Q1 R1 A B C)))
+++++
auto.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).

*****
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Bet D E F), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (or (LeA D E F P Q R) (not (SAMS P Q R A B C))))))
+++++
apply angles_archi_aux1.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
apply angles_archi_aux1.

*****
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
archimedes_axiom
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).
apply angles_archi_aux1.

*****
HFE : not (eq F E)
HDE : not (eq D E)
HNCol : not (Col A B C)
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
trivial.
-----
Lemma archi_in_angles : archimedes_axiom -> forall A B C D E F, ~ Col A B C -> D <> E -> F <> E -> exists P Q R, GradA A B C P Q R /\\ (LeA D E F P Q R \\/ ~ SAMS P Q R A B C).
Proof.
intros archi A B C D E F HNCol HDE HFE.
elim (bet_dec D E F).

*****

*****

+++++
Qed.
-----
Lemma archi__grada_destruction :\n  archimedes_axiom ->\n  forall A B C,\n    ~ Col A B C ->\n    exists P Q R, GradA A B C P Q R /\ ~ SAMS P Q R A B C.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C : Tpoint) (_ : not (Col A B C)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
Proof.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C : Tpoint) (_ : not (Col A B C)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
intros archi A B C HNCol.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.

*****
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].

*****
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
assert_diffs.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.

*****
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].

*****
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
auto.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].

*****
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].

*****
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A0 B)
+++++
auto.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
auto.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))))
+++++
exists P.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C))))
+++++
exists Q.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradA A B C P Q R) (not (SAMS P Q R A B C)))
+++++
exists R.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradA A B C P Q R) (not (SAMS P Q R A B C))
+++++
split.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradA A B C P Q R
+++++
auto.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R A B C)
+++++
auto.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.

*****
HUn : or (LeA A B A0 P Q R) (not (SAMS P Q R A B C))
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R A B C)
+++++
destruct HUn as [HLea|].
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].

*****
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R A B C)
+++++
trivial.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.

*****
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R A B C)
+++++
intro HIsi.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.
intro HIsi.

*****
HIsi : SAMS P Q R A B C
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HIsi as [_ [[HOut|HNBet] _]].
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.
intro HIsi.
destruct HIsi as [_ [[HOut|HNBet] _]].

*****
HOut : Out B A C
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.
intro HIsi.
destruct HIsi as [_ [[HOut|HNBet] _]].
apply HNCol.

*****
HOut : Out B A C
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
Col.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.
intro HIsi.
destruct HIsi as [_ [[HOut|HNBet] _]].

*****
HNBet : not (Bet P Q R)
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNBet, (bet_lea__bet A B A0).
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.
intro HIsi.
destruct HIsi as [_ [[HOut|HNBet] _]].
apply HNBet, (bet_lea__bet A B A0).

*****
HNBet : not (Bet P Q R)
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B A0
+++++
trivial.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].
trivial.
intro HIsi.
destruct HIsi as [_ [[HOut|HNBet] _]].
apply HNBet, (bet_lea__bet A B A0).

*****
HNBet : not (Bet P Q R)
HLea : LeA A B A0 P Q R
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B A0 P Q R
+++++
trivial.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].
auto.
exists P.
exists Q.
exists R.
split.
auto.
destruct HUn as [HLea|].

*****
H3 : not (SAMS P Q R A B C)
HGA : GradA A B C P Q R
P,Q,R : Tpoint
H0 : not (eq B A0)
H : not (eq A A0)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HCong : Cong B A0 A B
HBet : Bet A B A0
A0 : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R A B C)
+++++
trivial.
-----
Lemma archi__grada_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradA A B C P Q R /\\ ~ SAMS P Q R A B C.
Proof.
intros archi A B C HNCol.
destruct (segment_construction A B A B) as [A0 [HBet HCong]].
assert_diffs.
destruct (archi_in_angles archi A B C A B A0) as [P [Q [R [HGA HUn]]]].

*****

*****

+++++
Qed.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R,\n  GradA A B C P Q R ->\n  exists S T U, GradAExp A B C S T U /\ (Obtuse S T U \/ LeA P Q R S T U).
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C P Q R : Tpoint) (_ : GradA A B C P Q R), ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA P Q R S T U)))))
+++++
Proof.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C P Q R : Tpoint) (_ : GradA A B C P Q R), ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA P Q R S T U)))))
+++++
intros A B C.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.

*****
A,B,C : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R : Tpoint) (_ : GradA A B C P Q R), ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA P Q R S T U)))))
+++++
induction 1.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.

*****
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA D E F S T U)))))
+++++
assert_diffs.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA D E F S T U)))))
+++++
exists D.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C D T U) (or (Obtuse D T U) (LeA D E F D T U))))
+++++
exists E.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.
exists E.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun U : Tpoint => and (GradAExp A B C D E U) (or (Obtuse D E U) (LeA D E F D E U)))
+++++
exists F.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.
exists E.
exists F.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradAExp A B C D E F) (or (Obtuse D E F) (LeA D E F D E F))
+++++
split.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.
exists E.
exists F.
split.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradAExp A B C D E F
+++++
apply gradaexp_init.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.
exists E.
exists F.
split.
apply gradaexp_init.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A B C D E F
+++++
Lea.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.
exists E.
exists F.
split.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Obtuse D E F) (LeA D E F D E F)
+++++
right.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
assert_diffs.
exists D.
exists E.
exists F.
split.
right.

*****
H3 : not (eq F E)
H2 : not (eq D E)
H1 : not (eq C B)
H0 : not (eq A B)
H : CongA A B C D E F
A,B,C,D,E,F : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F D E F
+++++
Lea.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.

*****
IHGradA : ex\n (fun S : Tpoint =>\n ex\n (fun T : Tpoint =>\n ex\n (fun U : Tpoint =>\n and (GradAExp A B C S T U)\n (or (Obtuse S T U) (LeA D E F S T U)))))
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
assert (Hd := HGAE).
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).

*****
Hd : GradAExp A B C P Q R
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
apply gradaexp__grada, grada_distincts in Hd.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.

*****
Hd : and (not (eq A B))\n (and (not (eq C B)) (and (not (eq P Q)) (not (eq R Q))))
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
spliter.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.

*****
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
destruct HUn as [Habs|HLea].
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
Habs : Obtuse P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
absurd (SAMS P Q R P Q R).
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
absurd (SAMS P Q R P Q R).

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
Habs : Obtuse P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R P Q R)
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
absurd (SAMS P Q R P Q R).
trivial.

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
Habs : Obtuse P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R P Q R)
+++++
apply obtuse__nsams, Habs.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
absurd (SAMS P Q R P Q R).

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
Habs : Obtuse P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R P Q R
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q R)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].

*****
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q R)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
exists S.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U))))
+++++
exists T.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))
+++++
exists U.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U))
+++++
split.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradAExp A B C S T U
+++++
apply gradaexp_stab with P Q R.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
apply gradaexp_stab with P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradAExp A B C P Q R
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
apply gradaexp_stab with P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R P Q R
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
apply gradaexp_stab with P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P Q R P Q R S T U
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Obtuse S T U) (LeA G H I S T U)
+++++
right.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I S T U
+++++
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C P Q R
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.
trivial.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C P Q R
+++++
apply grada__lea, gradaexp__grada, HGAE.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R P Q R
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA D E F A B C G H I
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
destruct HUn as [Habs|HLea].
destruct (ex_suma P Q R P Q R) as [S [T [U HSuma]]].
auto.
exists S.
exists T.
exists U.
split.
right.
apply sams_lea2_suma2__lea with D E F A B C P Q R P Q R.

*****
HSuma : SumA P Q R P Q R S T U
S,T,U : Tpoint
HIsi : SAMS P Q R P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P Q R P Q R S T U
+++++
trivial.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].

*****
HNIsi : not (SAMS P Q R P Q R)
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
apply nsams__obtuse in HNIsi.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.
auto.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C S T U) (or (Obtuse S T U) (LeA G H I S T U)))))
+++++
exists P.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.
auto.
exists P.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => ex (fun U : Tpoint => and (GradAExp A B C P T U) (or (Obtuse P T U) (LeA G H I P T U))))
+++++
exists Q.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.
auto.
exists P.
exists Q.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun U : Tpoint => and (GradAExp A B C P Q U) (or (Obtuse P Q U) (LeA G H I P Q U)))
+++++
exists R.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.
auto.
exists P.
exists Q.
exists R.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradAExp A B C P Q R) (or (Obtuse P Q R) (LeA G H I P Q R))
+++++
split.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.
auto.
exists P.
exists Q.
exists R.
split.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradAExp A B C P Q R
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.
auto.
exists P.
exists Q.
exists R.
split.

*****
HNIsi : Obtuse P Q R
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Obtuse P Q R) (LeA G H I P Q R)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.

*****
HNIsi : not (SAMS P Q R P Q R)
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.
destruct IHGradA as [P [Q [R [HGAE HUn]]]].
assert (Hd := HGAE).
apply gradaexp__grada, grada_distincts in Hd.
spliter.
destruct (sams_dec P Q R P Q R) as [HIsi|HNIsi].
apply nsams__obtuse in HNIsi.

*****
HNIsi : not (SAMS P Q R P Q R)
H6 : not (eq R Q)
H5 : not (eq P Q)
H4 : not (eq C B)
H3 : not (eq A B)
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
H2 : SumA D E F A B C G H I
H1 : SAMS D E F A B C
H0 : GradA A B C D E F
A,B,C,D,E,F,G,H,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q R)
+++++
auto.
-----
Lemma gradaexp_destruction_aux : forall A B C P Q R, GradA A B C P Q R -> exists S T U, GradAExp A B C S T U /\\ (Obtuse S T U \\/ LeA P Q R S T U).
Proof.
intros A B C.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma archi__gradaexp_destruction :\n  archimedes_axiom ->\n  forall A B C,\n    ~ Col A B C ->\n    exists P Q R, GradAExp A B C P Q R /\ Obtuse P Q R.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C : Tpoint) (_ : not (Col A B C)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R))))
+++++
Proof.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C : Tpoint) (_ : not (Col A B C)), ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R))))
+++++
intros archi A B C HNCol.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.

*****
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R))))
+++++
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].

*****
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R))))
+++++
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R))))
+++++
exists P.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q : Tpoint => ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R)))
+++++
exists Q.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (GradAExp A B C P Q R) (Obtuse P Q R))
+++++
exists R.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (GradAExp A B C P Q R) (Obtuse P Q R)
+++++
split.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
GradAExp A B C P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.

*****
HUn : or (Obtuse P Q R) (LeA D E F P Q R)
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q R
+++++
destruct HUn as [HObtuse|HLea].
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].

*****
HObtuse : Obtuse P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].

*****
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.

*****
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q R
+++++
assert_diffs.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.

*****
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q R
+++++
apply nsams__obtuse.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.

*****
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
auto.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.

*****
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q R)
+++++
auto.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.

*****
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R P Q R)
+++++
auto.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.

*****
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (SAMS P Q R P Q R)
+++++
intro HIsi.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.
intro HIsi.

*****
HIsi : SAMS P Q R P Q R
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNIsi.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.
intro HIsi.
apply HNIsi.

*****
HIsi : SAMS P Q R P Q R
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS D E F A B C
+++++
apply sams_lea2__sams with P Q R P Q R.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.
intro HIsi.
apply HNIsi.
apply sams_lea2__sams with P Q R P Q R.

*****
HIsi : SAMS P Q R P Q R
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.
intro HIsi.
apply HNIsi.
apply sams_lea2__sams with P Q R P Q R.

*****
HIsi : SAMS P Q R P Q R
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.
intro HIsi.
apply HNIsi.
apply sams_lea2__sams with P Q R P Q R.

*****
HIsi : SAMS P Q R P Q R
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C P Q R
+++++
trivial.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.
trivial.
destruct HUn as [HObtuse|HLea].
trivial.
assert_diffs.
apply nsams__obtuse.
auto.
intro HIsi.
apply HNIsi.
apply sams_lea2__sams with P Q R P Q R.
trivial.

*****
HIsi : SAMS P Q R P Q R
H7 : not (eq R Q)
H3 : not (eq P Q)
H5 : not (eq F E)
H0 : not (eq D E)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HLea : LeA D E F P Q R
HGAE : GradAExp A B C P Q R
P,Q,R : Tpoint
HNIsi : not (SAMS D E F A B C)
HGA : GradA A B C D E F
D,E,F : Tpoint
HNCol : not (Col A B C)
A,B,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A B C P Q R
+++++
apply grada__lea, gradaexp__grada, HGAE.
-----
Lemma archi__gradaexp_destruction : archimedes_axiom -> forall A B C, ~ Col A B C -> exists P Q R, GradAExp A B C P Q R /\\ Obtuse P Q R.
Proof.
intros archi A B C HNCol.
destruct (archi__grada_destruction archi A B C HNCol) as [D [E [F [HGA HNIsi]]]].
destruct (gradaexp_destruction_aux A B C D E F HGA) as [P [Q [R [HGAE HUn]]]].
exists P.
exists Q.
exists R.
split.

*****

*****

+++++
Qed.
-----
End Archimedes_for_angles.
-----
