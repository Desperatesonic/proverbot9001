From Coq Require Import Bool.
-----
From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import   Coq.Arith.Euclid .
-----
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.BC BellantoniCook.BCLib.
-----
Fixpoint unary_preserv (e : BC) : bool :=\n  match e with\n    | zero => true\n    | proj n s j => true\n    | succ b => b\n    | pred => true\n    | cond => true\n    | rec g h0 h1 => unary_preserv g  &&\n                     unary_preserv h0 && \n                     unary_preserv h1 \n    | comp _ _ h nl sl => unary_preserv h && \n                          forallb unary_preserv nl &&\n                          forallb unary_preserv sl\n  end.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs),\n  unary_preserv e = true ->\n  forallb unary vnl = true ->\n  forallb unary vsl = true ->\n  unary (sem e vnl vsl) = true.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.

*****

*****
forall (e : BC) (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem e vnl vsl)) true
+++++
Proof.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.

*****

*****
forall (e : BC) (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem e vnl vsl)) true
+++++
induction e using BC_ind2.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****

*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv zero) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem zero vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****

*****
forall (vnl vsl : list (list bool)) (_ : eq true true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq true true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****
n,s,i : nat
*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv (proj n s i)) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem (proj n s i) vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****
n,s,i : nat
*****
forall (vnl vsl : list (list bool)) (_ : eq true true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)) true
+++++
case n.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (nth (Init.Nat.sub i O) vsl nil)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (nth (Init.Nat.sub i O) vsl nil)) true
+++++
apply forallb_nth.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
apply forallb_nth.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
apply forallb_nth.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
apply forallb_nth.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (forallb unary vsl) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
apply forallb_nth.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
forall n : nat, eq (unary (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
forall n : nat, eq (unary (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (if Nat.leb i n0 then nth i vnl nil else nth (Init.Nat.sub i (S n0)) vsl nil)) true
+++++
case (leb i n0).
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (nth i vnl nil)) true
+++++
apply forallb_nth.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.
simpl.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (forallb unary vnl) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.
simpl.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary (nth (Init.Nat.sub i (S n0)) vsl nil)) true
+++++
apply forallb_nth.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (unary nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.
simpl.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (forallb unary vsl) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
case n.
simpl.
intros.
case (leb i n0).
apply forallb_nth.
simpl.

*****
n0 : nat
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
n,s,i : nat
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****
b : bool
*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv (succ b)) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem (succ b) vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****
b : bool
*****
forall (vnl vsl : list (list bool)) (_ : eq b true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (andb (id b) (unary (hd nil vsl))) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq b true
vnl,vsl : list (list bool)
b : bool
*****
eq (andb (id b) (unary (hd nil vsl))) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq b true
vnl,vsl : list (list bool)
b : bool
*****
eq (andb (id b) (unary (hd nil vsl))) true
+++++
subst.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
subst.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
vnl,vsl : list (list bool)
*****
eq (andb (id true) (unary (hd nil vsl))) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
subst.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
vnl,vsl : list (list bool)
*****
eq (unary (hd nil vsl)) true
+++++
apply forallb_hd.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
subst.
simpl.
apply forallb_hd.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
vnl,vsl : list (list bool)
*****
eq (forallb unary vsl) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
subst.
simpl.
apply forallb_hd.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
vnl,vsl : list (list bool)
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
subst.
simpl.
apply forallb_hd.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
vnl,vsl : list (list bool)
*****
eq (unary nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
subst.
simpl.
apply forallb_hd.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
vnl,vsl : list (list bool)
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****

*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv pred) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem pred vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****

*****
forall (vnl vsl : list (list bool)) (_ : eq true true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (tl (hd nil vsl))) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (unary (tl (hd nil vsl))) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (unary (tl (hd nil vsl))) true
+++++
apply forallb_tl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
apply forallb_tl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (forallb id (hd nil vsl)) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
apply forallb_tl.
trivial.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (forallb id (hd nil vsl)) true
+++++
apply forallb_hd.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
apply forallb_tl.
trivial.
apply forallb_hd.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (forallb (forallb id) vsl) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
apply forallb_tl.
trivial.
apply forallb_hd.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (forallb (forallb id) vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
apply forallb_tl.
trivial.
apply forallb_hd.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (forallb id nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
apply forallb_tl.
trivial.
apply forallb_hd.
simpl.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****

*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv cond) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem cond vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****

*****
forall (vnl vsl : list (list bool)) (_ : eq true true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl,vsl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
destruct vsl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.

*****
H1 : eq (forallb unary nil) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl : list (list bool)
*****
eq (unary nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.

*****
H1 : eq (forallb unary nil) true
H0 : eq (forallb unary vnl) true
H : eq true true
vnl : list (list bool)
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.

*****
H1 : eq (forallb unary (cons l vsl)) true
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.

*****
H1 : eq (forallb unary (cons l vsl)) true
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.

*****
H1 : eq (forallb unary (cons l vsl)) true
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
simpl in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.

*****
H1 : eq (andb (unary l) (forallb unary vsl)) true
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
rewrite andb_true_iff in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.

*****
H1 : and (eq (unary l) true) (eq (forallb unary vsl) true)
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end) true
+++++
destruct vsl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.

*****
H1 : and (eq (unary l) true) (eq (forallb unary nil) true)
H0 : eq (forallb unary vnl) true
H : eq true true
l : list bool
vnl : list (list bool)
*****
eq (unary nil) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.

*****
H1 : and (eq (unary l) true) (eq (forallb unary nil) true)
H0 : eq (forallb unary vnl) true
H : eq true true
l : list bool
vnl : list (list bool)
*****
eq true true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.

*****
H1 : and (eq (unary l) true) (eq (forallb unary (cons l0 vsl)) true)
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons _ _ => nil end | cons c nil => match l with | nil => l0 | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match l with | nil => l0 | cons true _ => c | cons false _ => d end end) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.

*****
H1 : and (eq (unary l) true) (eq (forallb unary (cons l0 vsl)) true)
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons _ _ => nil end | cons c nil => match l with | nil => l0 | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match l with | nil => l0 | cons true _ => c | cons false _ => d end end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.

*****
H1 : and (eq (unary l) true) (eq (forallb unary (cons l0 vsl)) true)
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons _ _ => nil end | cons c nil => match l with | nil => l0 | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match l with | nil => l0 | cons true _ => c | cons false _ => d end end) true
+++++
simpl in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.

*****
H1 : and (eq (unary l) true) (eq (andb (unary l0) (forallb unary vsl)) true)
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons _ _ => nil end | cons c nil => match l with | nil => l0 | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match l with | nil => l0 | cons true _ => c | cons false _ => d end end) true
+++++
rewrite andb_true_iff in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary vsl) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons _ _ => nil end | cons c nil => match l with | nil => l0 | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match l with | nil => l0 | cons true _ => c | cons false _ => d end end) true
+++++
destruct vsl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary nil) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons _ _ => nil end) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary nil) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons _ _ => nil end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary nil) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons _ _ => nil end) true
+++++
case l.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
case l.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary nil) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
case l.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary nil) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
case l.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary nil) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0 : list bool
vnl : list (list bool)
*****
forall (_ : bool) (_ : list bool), eq (unary nil) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary (cons l1 vsl)) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end | cons d _ => match l with | nil => l0 | cons true _ => l1 | cons false _ => d end end) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary (cons l1 vsl)) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end | cons d _ => match l with | nil => l0 | cons true _ => l1 | cons false _ => d end end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary (cons l1 vsl)) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match vsl with | nil => match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end | cons d _ => match l with | nil => l0 | cons true _ => l1 | cons false _ => d end end) true
+++++
destruct vsl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary (cons l1 nil)) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary (cons l1 nil)) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (forallb unary (cons l1 nil)) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end) true
+++++
simpl in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (eq (andb (unary l1) true) true))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end) true
+++++
rewrite andb_true_iff in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end) true
+++++
case l.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.
trivial.
intros.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
forall (b : bool) (_ : list bool), eq (unary (if b then l1 else nil)) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
forall (b : bool) (_ : list bool), eq (unary (if b then l1 else nil)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.
trivial.
intros.

*****
l2 : list bool
b : bool
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary (if b then l1 else nil)) true
+++++
case b.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.
trivial.
intros.
case b.

*****
l2 : list bool
b : bool
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary l1) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
case l.
trivial.
intros.
case b.

*****
l2 : list bool
b : bool
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true) (and (eq (unary l1) true) (eq true true)))
H0 : eq (forallb unary vnl) true
H : eq true true
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq (unary nil) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (eq (forallb unary (cons l1 (cons l2 vsl))) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => l2 end) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (eq (forallb unary (cons l1 (cons l2 vsl))) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => l2 end) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (eq (forallb unary (cons l1 (cons l2 vsl))) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => l2 end) true
+++++
simpl in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (eq (andb (unary l1) (andb (unary l2) (forallb unary vsl))) true))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => l2 end) true
+++++
rewrite andb_true_iff,andb_true_iff in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary match l with | nil => l0 | cons true _ => l1 | cons false _ => l2 end) true
+++++
case l.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary l0) true
+++++
try tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
forall (b : bool) (_ : list bool), eq (unary (if b then l1 else l2)) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.
trivial.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
forall (b : bool) (_ : list bool), eq (unary (if b then l1 else l2)) true
+++++
try tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.
trivial.
try tauto.

*****
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
forall (b : bool) (_ : list bool), eq (unary (if b then l1 else l2)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.
trivial.
try tauto.
intros.

*****
l3 : list bool
b : bool
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary (if b then l1 else l2)) true
+++++
case b.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.
trivial.
try tauto.
intros.
case b.

*****
l3 : list bool
b : bool
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary l1) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff in H1.
destruct vsl.
simpl.
trivial.
destruct vsl.
simpl.
trivial.
simpl in H1.
rewrite andb_true_iff,andb_true_iff in H1.
case l.
trivial.
try tauto.
intros.
case b.

*****
l3 : list bool
b : bool
H1 : and (eq (unary l) true)\n (and (eq (unary l0) true)\n (and (eq (unary l1) true)\n (and (eq (unary l2) true) (eq (forallb unary vsl) true))))
H0 : eq (forallb unary vnl) true
H : eq true true
vsl : list (list bool)
l,l0,l1,l2 : list bool
vnl : list (list bool)
*****
eq (unary l2) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv (rec e1 e2 e3)) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem (rec e1 e2 e3) vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
forall (vnl vsl : list (list bool)) (_ : eq (andb (andb (unary_preserv e1) (unary_preserv e2)) (unary_preserv e3)) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem_rec (sem e1) (sem e2) (sem e3) (hd nil vnl) (tl vnl) vsl)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq\n (andb (andb (unary_preserv e1) (unary_preserv e2)) (unary_preserv e3))\n true
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) (hd nil vnl) (tl vnl) vsl)) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : eq\n (andb (andb (unary_preserv e1) (unary_preserv e2)) (unary_preserv e3))\n true
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) (hd nil vnl) (tl vnl) vsl)) true
+++++
repeat rewrite andb_true_iff in H.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) (hd nil vnl) (tl vnl) vsl)) true
+++++
assert (unary (hd nil vnl) = true).
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (hd nil vnl)) true
+++++
apply forallb_hd.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
apply forallb_hd.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
apply forallb_hd.

*****
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary nil) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).

*****
H2 : eq (unary (hd nil vnl)) true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) (hd nil vnl) (tl vnl) vsl)) true
+++++
induction (hd nil vnl).
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).

*****
H2 : eq (unary nil) true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) nil (tl vnl) vsl)) true
+++++
simpl in *.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem e1 (tl vnl) vsl)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem e1 (tl vnl) vsl)) true
+++++
apply IHe1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
apply IHe1.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary_preserv e1) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
apply IHe1.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (tl vnl)) true
+++++
apply forallb_tl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
apply IHe1.
apply forallb_tl.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
apply IHe1.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vsl) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
apply IHe1.
idtac.

*****
H2 : eq true true
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : eq (unary (cons a l)) true
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) (cons a l) (tl vnl) vsl)) true
+++++
simpl in *.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : eq (andb (id a) (unary l)) true
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (if a then sem e3 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl) else sem e2 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl))) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : eq (andb (id a) (unary l)) true
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (if a then sem e3 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl) else sem e2 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl))) true
+++++
case a.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : eq (andb (id a) (unary l)) true
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem e3 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl))) true
+++++
rewrite andb_true_iff in H2.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem e3 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl))) true
+++++
apply IHe3.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary_preserv e3) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons l (tl vnl))) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons l (tl vnl))) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (andb (unary l) (forallb unary (tl vnl))) true
+++++
rewrite andb_true_iff.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
and (eq (unary l) true) (eq (forallb unary (tl vnl)) true)
+++++
split.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary l) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (tl vnl)) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.
idtac.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (tl vnl)) true
+++++
apply forallb_tl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.
idtac.
apply forallb_tl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl)) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (andb (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) (forallb unary vsl)) true
+++++
rewrite andb_true_iff.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
and (eq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true) (eq (forallb unary vsl) true)
+++++
split.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
+++++
apply IHl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.
apply IHl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary l) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe3.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : eq (andb (id a) (unary l)) true
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem e2 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl))) true
+++++
rewrite andb_true_iff in H2.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem e2 (cons l (tl vnl)) (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl))) true
+++++
apply IHe2.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary_preserv e2) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons l (tl vnl))) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons l (tl vnl))) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (andb (unary l) (forallb unary (tl vnl))) true
+++++
rewrite andb_true_iff.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
and (eq (unary l) true) (eq (forallb unary (tl vnl)) true)
+++++
split.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary l) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (tl vnl)) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.
idtac.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (tl vnl)) true
+++++
apply forallb_tl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.
idtac.
apply forallb_tl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl)) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary (cons (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl) vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (andb (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) (forallb unary vsl)) true
+++++
rewrite andb_true_iff.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
and (eq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true) (eq (forallb unary vsl) true)
+++++
split.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
+++++
apply IHl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.
apply IHl.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (unary l) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H.
assert (unary (hd nil vnl) = true).
induction (hd nil vnl).
simpl in *.
intros.
case a.
rewrite andb_true_iff in H2.
apply IHe2.
idtac.
simpl.
rewrite andb_true_iff.
split.

*****
IHl : forall _ : eq (unary l) true,\neq (unary (sem_rec (sem e1) (sem e2) (sem e3) l (tl vnl) vsl)) true
H2 : and (eq (id a) true) (eq (unary l) true)
l : list bool
a : bool
H1 : eq (forallb unary vsl) true
H0 : eq (forallb unary vnl) true
H : and (and (eq (unary_preserv e1) true) (eq (unary_preserv e2) true))\n (eq (unary_preserv e3) true)
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e3) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e3 vnl vsl)) true
IHe2 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e2) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e2 vnl vsl)) true
IHe1 : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e1) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e1 vnl vsl)) true
e1,e2,e3 : BC
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv (comp n s e rl tl)) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem (comp n s e rl tl) vnl vsl)) true
+++++
simpl.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.

*****
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
forall (vnl vsl : list (list bool)) (_ : eq (andb (andb (unary_preserv e) (forallb unary_preserv rl)) (forallb unary_preserv tl)) true) (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true), eq (unary (sem e (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : eq\n (andb (andb (unary_preserv e) (forallb unary_preserv rl))\n (forallb unary_preserv tl)) true
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary (sem e (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : eq\n (andb (andb (unary_preserv e) (forallb unary_preserv rl))\n (forallb unary_preserv tl)) true
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary (sem e (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))) true
+++++
repeat rewrite andb_true_iff in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary (sem e (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))) true
+++++
apply IHe.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv e) true
+++++
tauto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary (map (fun ne : BC => sem ne vnl nil) rl)) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary (map (fun ne : BC => sem ne vnl nil) rl)) true
+++++
apply forallb_map.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
forall (x : BC) (_ : In x rl), eq (unary (sem x vnl nil)) true
+++++
auto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
forall (x : BC) (_ : In x rl), eq (unary (sem x vnl nil)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary (sem x vnl nil)) true
+++++
apply H.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
In x rl
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.
trivial.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
rewrite forallb_forall in H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.
trivial.
rewrite forallb_forall in H1.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true)\n (forall (x : BC) (_ : In x rl), eq (unary_preserv x) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
decompose [and] H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.
trivial.
rewrite forallb_forall in H1.
decompose [and] H1.

*****
H8 : forall (x : BC) (_ : In x rl), eq (unary_preserv x) true
H7 : eq (unary_preserv e) true
H6 : eq (forallb unary_preserv tl) true
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true)\n (forall (x : BC) (_ : In x rl), eq (unary_preserv x) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
auto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H.

*****
H4 : In x rl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary nil) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary (map (fun se : BC => sem se vnl vsl) tl)) true
+++++
idtac.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary (map (fun se : BC => sem se vnl vsl) tl)) true
+++++
apply forallb_map.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
forall (x : BC) (_ : In x tl), eq (unary (sem x vnl vsl)) true
+++++
auto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.

*****
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
forall (x : BC) (_ : In x tl), eq (unary (sem x vnl vsl)) true
+++++
intros.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.

*****
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary (sem x vnl vsl)) true
+++++
apply H0.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.

*****
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
In x tl
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.

*****
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.
trivial.

*****
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
decompose [and] H1.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.
trivial.
decompose [and] H1.

*****
H8 : eq (forallb unary_preserv rl) true
H7 : eq (unary_preserv e) true
H6 : eq (forallb unary_preserv tl) true
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
rewrite forallb_forall in H6.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.
trivial.
decompose [and] H1.
rewrite forallb_forall in H6.

*****
H8 : eq (forallb unary_preserv rl) true
H7 : eq (unary_preserv e) true
H6 : forall (x : BC) (_ : In x tl), eq (unary_preserv x) true
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (unary_preserv x) true
+++++
auto.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.

*****
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary vnl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.
simpl.
intros.
trivial.
repeat rewrite andb_true_iff in H1.
apply IHe.
idtac.
apply forallb_map.
auto.
intros.
apply H0.

*****
H4 : In x tl
x : BC
H3 : eq (forallb unary vsl) true
H2 : eq (forallb unary vnl) true
H1 : and\n (and (eq (unary_preserv e) true) (eq (forallb unary_preserv rl) true))\n (eq (forallb unary_preserv tl) true)
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (_ : eq (unary_preserv e) true)\n (_ : eq (forallb unary vnl) true) (_ : eq (forallb unary vsl) true),\neq (unary (sem e vnl vsl)) true
H0 : forall (s : BC) (_ : In s tl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv s) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem s vnl vsl)) true
H : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (unary_preserv r) true) (_ : eq (forallb unary vnl) true)\n (_ : eq (forallb unary vsl) true), eq (unary (sem r vnl vsl)) true
rl,tl : list BC
e : BC
n,s : nat
*****
eq (forallb unary vsl) true
+++++
trivial.
-----
Lemma preservation : forall (e : BC) (vnl vsl : list bs), unary_preserv e = true -> forallb unary vnl = true -> forallb unary vsl = true -> unary (sem e vnl vsl) = true.
Proof.
induction e using BC_ind2.

*****

*****

+++++
Qed.
-----
Lemma zero_correct n s l1 l2: \n length (sem (zero_e n s) l1 l2) = 0.
-----
Lemma zero_correct n s l1 l2: length (sem (zero_e n s) l1 l2) = 0.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (length (sem (zero_e n s) l1 l2)) O
+++++
Proof.
-----
Lemma zero_correct n s l1 l2: length (sem (zero_e n s) l1 l2) = 0.
Proof.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (length (sem (zero_e n s) l1 l2)) O
+++++
intros.
-----
Lemma zero_correct n s l1 l2: length (sem (zero_e n s) l1 l2) = 0.
Proof.
intros.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (length (sem (zero_e n s) l1 l2)) O
+++++
simpl.
-----
Lemma zero_correct n s l1 l2: length (sem (zero_e n s) l1 l2) = 0.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq O O
+++++
trivial.
-----
Lemma zero_correct n s l1 l2: length (sem (zero_e n s) l1 l2) = 0.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Definition one_e (n s:nat) : BC :=\n  comp n s (comp 0 0 (succ true) nil (zero :: nil)) nil nil.
-----
Lemma one_correct n s l1 l2: \n length (sem (one_e n s) l1 l2) = 1.
-----
Lemma one_correct n s l1 l2: length (sem (one_e n s) l1 l2) = 1.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (length (sem (one_e n s) l1 l2)) (S O)
+++++
Proof.
-----
Lemma one_correct n s l1 l2: length (sem (one_e n s) l1 l2) = 1.
Proof.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (length (sem (one_e n s) l1 l2)) (S O)
+++++
intros.
-----
Lemma one_correct n s l1 l2: length (sem (one_e n s) l1 l2) = 1.
Proof.
intros.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (length (sem (one_e n s) l1 l2)) (S O)
+++++
simpl.
-----
Lemma one_correct n s l1 l2: length (sem (one_e n s) l1 l2) = 1.
Proof.
intros.
simpl.

*****
l1,l2 : list (list bool)
n,s : nat
*****
eq (S O) (S O)
+++++
trivial.
-----
Lemma one_correct n s l1 l2: length (sem (one_e n s) l1 l2) = 1.
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Definition succ_e : BC := succ true.
-----
Lemma succ_correct :\n  forall n, length (sem succ_e nil [n]) = S (length n).
-----
Lemma succ_correct : forall n, length (sem succ_e nil [n]) = S (length n).

*****

*****
forall n : list bool, eq (length (sem succ_e nil (cons n nil))) (S (length n))
+++++
Proof.
-----
Lemma succ_correct : forall n, length (sem succ_e nil [n]) = S (length n).
Proof.

*****

*****
forall n : list bool, eq (length (sem succ_e nil (cons n nil))) (S (length n))
+++++
intros.
-----
Lemma succ_correct : forall n, length (sem succ_e nil [n]) = S (length n).
Proof.
intros.

*****
n : list bool
*****
eq (length (sem succ_e nil (cons n nil))) (S (length n))
+++++
simpl.
-----
Lemma succ_correct : forall n, length (sem succ_e nil [n]) = S (length n).
Proof.
intros.
simpl.

*****
n : list bool
*****
eq (S (length n)) (S (length n))
+++++
trivial.
-----
Lemma succ_correct : forall n, length (sem succ_e nil [n]) = S (length n).
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Fixpoint nat2BC (n s x:nat) : BC :=\n  match x with\n    | 0 => zero_e n s\n    | S x' => comp n s succ_e nil [nat2BC n s x']\n  end.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.

*****

*****
forall n s x : nat, eq (arities (nat2BC n s x)) (ok_arities n s)
+++++
Proof.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.

*****

*****
forall n s x : nat, eq (arities (nat2BC n s x)) (ok_arities n s)
+++++
induction x as [ | x IH].
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].

*****
n,s : nat
*****
eq (arities (nat2BC n s O)) (ok_arities n s)
+++++
trivial.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
eq (arities (nat2BC n s (S x))) (ok_arities n s)
+++++
simpl nat2BC.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
eq (arities (comp n s succ_e nil (cons (nat2BC n s x) nil))) (ok_arities n s)
+++++
rewrite comp_arities.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.
rewrite comp_arities.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
eq (ok_arities n s) (ok_arities n s)
+++++
trivial.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.
rewrite comp_arities.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
eq (arities succ_e) (ok_arities (length nil) (length (cons (nat2BC n s x) nil)))
+++++
trivial.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.
rewrite comp_arities.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
andl (fun ne : BC => eq (arities ne) (ok_arities n O)) nil
+++++
simpl.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.
rewrite comp_arities.
simpl.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
True
+++++
trivial.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.
rewrite comp_arities.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
andl (fun se : BC => eq (arities se) (ok_arities n s)) (cons (nat2BC n s x) nil)
+++++
simpl.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].
simpl nat2BC.
rewrite comp_arities.
simpl.

*****
IH : eq (arities (nat2BC n s x)) (ok_arities n s)
n,s,x : nat
*****
and (eq (arities (nat2BC n s x)) (ok_arities n s)) True
+++++
tauto.
-----
Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.
Proof.
induction x as [ | x IH].

*****

*****

+++++
Qed.
-----
Lemma nat2BC_correct :\n  forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.

*****

*****
forall (n s x : nat) (nl sl : list (list bool)), eq (length (sem (nat2BC n s x) nl sl)) x
+++++
Proof.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.

*****

*****
forall (n s x : nat) (nl sl : list (list bool)), eq (length (sem (nat2BC n s x) nl sl)) x
+++++
induction x as [ | x IH].
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].

*****
n,s : nat
*****
forall nl sl : list (list bool), eq (length (sem (nat2BC n s O) nl sl)) O
+++++
trivial.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].

*****
IH : forall nl sl : list (list bool),\neq (length (sem (nat2BC n s x) nl sl)) x
n,s,x : nat
*****
forall nl sl : list (list bool), eq (length (sem (nat2BC n s (S x)) nl sl)) (S x)
+++++
intros nl sl.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].
intros nl sl.

*****
nl,sl : list (list bool)
IH : forall nl sl : list (list bool),\neq (length (sem (nat2BC n s x) nl sl)) x
n,s,x : nat
*****
eq (length (sem (nat2BC n s (S x)) nl sl)) (S x)
+++++
simpl nat2BC.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].
intros nl sl.
simpl nat2BC.

*****
nl,sl : list (list bool)
IH : forall nl sl : list (list bool),\neq (length (sem (nat2BC n s x) nl sl)) x
n,s,x : nat
*****
eq (length (sem (comp n s succ_e nil (cons (nat2BC n s x) nil)) nl sl)) (S x)
+++++
rewrite sem_comp.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].
intros nl sl.
simpl nat2BC.
rewrite sem_comp.

*****
nl,sl : list (list bool)
IH : forall nl sl : list (list bool),\neq (length (sem (nat2BC n s x) nl sl)) x
n,s,x : nat
*****
eq (length (sem succ_e (map (fun ne : BC => sem ne nl nil) nil) (map (fun se : BC => sem se nl sl) (cons (nat2BC n s x) nil)))) (S x)
+++++
simpl.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].
intros nl sl.
simpl nat2BC.
rewrite sem_comp.
simpl.

*****
nl,sl : list (list bool)
IH : forall nl sl : list (list bool),\neq (length (sem (nat2BC n s x) nl sl)) x
n,s,x : nat
*****
eq (S (length (sem (nat2BC n s x) nl sl))) (S x)
+++++
rewrite IH.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].
intros nl sl.
simpl nat2BC.
rewrite sem_comp.
simpl.
rewrite IH.

*****
nl,sl : list (list bool)
IH : forall nl sl : list (list bool),\neq (length (sem (nat2BC n s x) nl sl)) x
n,s,x : nat
*****
eq (S x) (S x)
+++++
trivial.
-----
Lemma nat2BC_correct : forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.
Proof.
induction x as [ | x IH].

*****

*****

+++++
Qed.
-----
Opaque succ_e.
-----
Definition plus_e : BC :=\n  rec (proj 0 1 0)\n      (comp 1 2 succ_e nil ((proj 1 2 1) :: nil))\n      (comp 1 2 succ_e nil ((proj 1 2 1) :: nil)).
-----
Lemma plus_correct :\n  forall m n, length (sem plus_e [m] [n]) = length m + length n.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.

*****

*****
forall m n : list bool, eq (length (sem plus_e (cons m nil) (cons n nil))) (Init.Nat.add (length m) (length n))
+++++
Proof.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.

*****

*****
forall m n : list bool, eq (length (sem plus_e (cons m nil) (cons n nil))) (Init.Nat.add (length m) (length n))
+++++
induction m.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.

*****

*****
forall n : list bool, eq (length (sem plus_e (cons nil nil) (cons n nil))) (Init.Nat.add (length nil) (length n))
+++++
simpl in *.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.

*****

*****
forall n : list bool, eq (length n) (length n)
+++++
intros.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.

*****
n : list bool
*****
eq (length n) (length n)
+++++
trivial.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.

*****
IHm : forall n : list bool,\neq (length (sem plus_e (cons m nil) (cons n nil)))\n (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
forall n : list bool, eq (length (sem plus_e (cons (cons a m) nil) (cons n nil))) (Init.Nat.add (length (cons a m)) (length n))
+++++
simpl in *.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.

*****
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
forall n : list bool, eq (length (if a then sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil) else sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
intros.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (length (if a then sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil) else sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
trivial.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (length (if a then sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil) else sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
case a.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.
case a.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
simpl.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.
case a.
simpl.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
rewrite succ_correct.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.
case a.
simpl.
rewrite succ_correct.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (S (length (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)))) (S (Init.Nat.add (length m) (length n)))
+++++
auto.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.
case a.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
simpl.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.
case a.
simpl.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem succ_e nil (cons (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)) nil))) (S (Init.Nat.add (length m) (length n)))
+++++
rewrite succ_correct.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.
simpl in *.
intros.
trivial.
case a.
simpl.
rewrite succ_correct.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil))\n (fun _ vsl : list (list bool) =>\n sem succ_e nil (cons (nth O vsl nil) nil)) m nil \n (cons n nil))) (Init.Nat.add (length m) (length n))
m : list bool
a : bool
*****
eq (S (length (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) (fun _ vsl : list (list bool) => sem succ_e nil (cons (nth O vsl nil) nil)) m nil (cons n nil)))) (S (Init.Nat.add (length m) (length n)))
+++++
auto.
-----
Lemma plus_correct : forall m n, length (sem plus_e [m] [n]) = length m + length n.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Opaque plus_e.
-----
Fixpoint plusl_e (n:nat)(el:list BC) : BC :=\n  match el with\n    | nil => zero_e n 0\n    | e' :: el' => comp n 0 plus_e [e'] [plusl_e n el']\n  end.
-----
Lemma plusl_arities n el : \n  andl (fun e => arities e = ok_arities n 0) el ->\n  arities (plusl_e n el) = ok_arities n 0.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.

*****
el : list BC
n : nat
*****
forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el, eq (arities (plusl_e n el)) (ok_arities n O)
+++++
Proof.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.

*****
el : list BC
n : nat
*****
forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el, eq (arities (plusl_e n el)) (ok_arities n O)
+++++
induction el as [ | e' el' IH].
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].

*****
n : nat
*****
forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) nil, eq (arities (plusl_e n nil)) (ok_arities n O)
+++++
trivial.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].

*****
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) (cons e' el'), eq (arities (plusl_e n (cons e' el'))) (ok_arities n O)
+++++
intro H.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.

*****
H : andl (fun e : BC => eq (arities e) (ok_arities n O)) (cons e' el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
eq (arities (plusl_e n (cons e' el'))) (ok_arities n O)
+++++
simpl in H.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
eq (arities (plusl_e n (cons e' el'))) (ok_arities n O)
+++++
simpl plusl_e.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
eq (arities (comp n O plus_e (cons e' nil) (cons (plusl_e n el') nil))) (ok_arities n O)
+++++
rewrite comp_arities.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.
rewrite comp_arities.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
eq (ok_arities n O) (ok_arities n O)
+++++
trivial.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.
rewrite comp_arities.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
eq (arities plus_e) (ok_arities (length (cons e' nil)) (length (cons (plusl_e n el') nil)))
+++++
trivial.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.
rewrite comp_arities.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
andl (fun ne : BC => eq (arities ne) (ok_arities n O)) (cons e' nil)
+++++
simpl.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.
rewrite comp_arities.
simpl.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
and (eq (arities e') (ok_arities n O)) True
+++++
tauto.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.
rewrite comp_arities.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
andl (fun se : BC => eq (arities se) (ok_arities n O)) (cons (plusl_e n el') nil)
+++++
simpl.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].
intro H.
simpl in H.
simpl plusl_e.
rewrite comp_arities.
simpl.

*****
H : and (eq (arities e') (ok_arities n O))\n (andl (fun e : BC => eq (arities e) (ok_arities n O)) el')
IH : forall _ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el',\neq (arities (plusl_e n el')) (ok_arities n O)
el' : list BC
e' : BC
n : nat
*****
and (eq (arities (plusl_e n el')) (ok_arities n O)) True
+++++
tauto.
-----
Lemma plusl_arities n el : andl (fun e => arities e = ok_arities n 0) el -> arities (plusl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e' el' IH].

*****

*****

+++++
Qed.
-----
Lemma plusl_correct :\n  forall n nl el,\n  length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).

*****

*****
forall (n : nat) (nl : list (list bool)) (el : list BC), eq (length (sem (plusl_e n el) nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) el))
+++++
Proof.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.

*****

*****
forall (n : nat) (nl : list (list bool)) (el : list BC), eq (length (sem (plusl_e n el) nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) el))
+++++
induction el as [ | e el IH].
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].

*****
nl : list (list bool)
n : nat
*****
eq (length (sem (plusl_e n nil) nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) nil))
+++++
simpl.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.

*****
nl : list (list bool)
n : nat
*****
eq O O
+++++
trivial.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].

*****
IH : eq (length (sem (plusl_e n el) nl nil))\n (plusl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (length (sem (plusl_e n (cons e el)) nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) (cons e el)))
+++++
simpl.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.

*****
IH : eq (length (sem (plusl_e n el) nl nil))\n (plusl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (length (sem plus_e (cons (sem e nl nil) nil) (cons (sem (plusl_e n el) nl nil) nil))) (Init.Nat.add (length (sem e nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) el)))
+++++
rewrite plus_correct.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.
rewrite plus_correct.

*****
IH : eq (length (sem (plusl_e n el) nl nil))\n (plusl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (Init.Nat.add (length (sem e nl nil)) (length (sem (plusl_e n el) nl nil))) (Init.Nat.add (length (sem e nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) el)))
+++++
rewrite IH.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.
rewrite plus_correct.
rewrite IH.

*****
IH : eq (length (sem (plusl_e n el) nl nil))\n (plusl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (Init.Nat.add (length (sem e nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) el))) (Init.Nat.add (length (sem e nl nil)) (plusl (map (fun e : BC => length (sem e nl nil)) el)))
+++++
trivial.
-----
Lemma plusl_correct : forall n nl el, length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].

*****

*****

+++++
Qed.
-----
Notation or_e := plus_e (only parsing).
-----
Lemma or_correct :\n  forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.

*****

*****
forall b1 b2 : bool, eq (bs2bool (sem plus_e (cons (bool2bs b1) nil) (cons (bool2bs b2) nil))) (orb b1 b2)
+++++
Proof.
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
Proof.

*****

*****
forall b1 b2 : bool, eq (bs2bool (sem plus_e (cons (bool2bs b1) nil) (cons (bool2bs b2) nil))) (orb b1 b2)
+++++
intros [ | ] [ | ].
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem plus_e (cons (bool2bs true) nil) (cons (bool2bs true) nil))) (orb true true)
+++++
reflexivity.
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem plus_e (cons (bool2bs true) nil) (cons (bool2bs false) nil))) (orb true false)
+++++
reflexivity.
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem plus_e (cons (bool2bs false) nil) (cons (bool2bs true) nil))) (orb false true)
+++++
reflexivity.
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem plus_e (cons (bool2bs false) nil) (cons (bool2bs false) nil))) (orb false false)
+++++
reflexivity.
-----
Lemma or_correct : forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.
Proof.
intros [ | ] [ | ].

*****

*****

+++++
Qed.
-----
Definition mult_e : BC :=\n  rec (zero_e 1 0)\n      (comp 2 1 plus_e ((proj 2 0 1) :: nil) ((proj 2 1 2) :: nil))\n      (comp 2 1 plus_e ((proj 2 0 1) :: nil) ((proj 2 1 2) :: nil)).
-----
Lemma mult_correct :\n  forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).

*****

*****
forall m n : list bool, eq (length (sem mult_e (cons m (cons n nil)) nil)) (Init.Nat.mul (length m) (length n))
+++++
Proof.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.

*****

*****
forall m n : list bool, eq (length (sem mult_e (cons m (cons n nil)) nil)) (Init.Nat.mul (length m) (length n))
+++++
induction m.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.

*****

*****
forall n : list bool, eq (length (sem mult_e (cons nil (cons n nil)) nil)) (Init.Nat.mul (length nil) (length n))
+++++
intro n.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.

*****
n : list bool
*****
eq (length (sem mult_e (cons nil (cons n nil)) nil)) (Init.Nat.mul (length nil) (length n))
+++++
trivial.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.

*****
IHm : forall n : list bool,\neq (length (sem mult_e (cons m (cons n nil)) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
forall n : list bool, eq (length (sem mult_e (cons (cons a m) (cons n nil)) nil)) (Init.Nat.mul (length (cons a m)) (length n))
+++++
intro n.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.

*****
n : list bool
IHm : forall n : list bool,\neq (length (sem mult_e (cons m (cons n nil)) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem mult_e (cons (cons a m) (cons n nil)) nil)) (Init.Nat.mul (length (cons a m)) (length n))
+++++
trivial.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.
trivial.

*****
n : list bool
IHm : forall n : list bool,\neq (length (sem mult_e (cons m (cons n nil)) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem mult_e (cons (cons a m) (cons n nil)) nil)) (Init.Nat.mul (length (cons a m)) (length n))
+++++
simpl in *.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.
trivial.
simpl in *.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil))\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil)) m (cons n nil) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (length (if a then sem plus_e (cons n nil) (cons (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) m (cons n nil) nil) nil) else sem plus_e (cons n nil) (cons (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) m (cons n nil) nil) nil))) (Init.Nat.add (length n) (Init.Nat.mul (length m) (length n)))
+++++
case a.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.
trivial.
simpl in *.
case a.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil))\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil)) m (cons n nil) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem plus_e (cons n nil) (cons (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) m (cons n nil) nil) nil))) (Init.Nat.add (length n) (Init.Nat.mul (length m) (length n)))
+++++
rewrite plus_correct.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.
trivial.
simpl in *.
case a.
rewrite plus_correct.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil))\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil)) m (cons n nil) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (Init.Nat.add (length n) (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) m (cons n nil) nil))) (Init.Nat.add (length n) (Init.Nat.mul (length m) (length n)))
+++++
auto.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.
trivial.
simpl in *.
case a.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil))\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil)) m (cons n nil) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (length (sem plus_e (cons n nil) (cons (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) m (cons n nil) nil) nil))) (Init.Nat.add (length n) (Init.Nat.mul (length m) (length n)))
+++++
rewrite plus_correct.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.
intro n.
trivial.
simpl in *.
case a.
rewrite plus_correct.

*****
n : list bool
IHm : forall n : list bool,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil))\n (fun vnl vsl : list (list bool) =>\n sem plus_e (cons (nth (S O) vnl nil) nil)\n (cons (nth O vsl nil) nil)) m (cons n nil) nil))\n (Init.Nat.mul (length m) (length n))
m : list bool
a : bool
*****
eq (Init.Nat.add (length n) (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) (fun vnl vsl : list (list bool) => sem plus_e (cons (nth (S O) vnl nil) nil) (cons (nth O vsl nil) nil)) m (cons n nil) nil))) (Init.Nat.add (length n) (Init.Nat.mul (length m) (length n)))
+++++
auto.
-----
Lemma mult_correct : forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Opaque mult_e.
-----
Notation and_e := mult_e (only parsing).
-----
Lemma and_correct :\n  forall b1 b2, bs2bool \n    (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.

*****

*****
forall b1 b2 : bool, eq (bs2bool (sem mult_e (cons (bool2bs b1) (cons (bool2bs b2) nil)) nil)) (andb b1 b2)
+++++
Proof.
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
Proof.

*****

*****
forall b1 b2 : bool, eq (bs2bool (sem mult_e (cons (bool2bs b1) (cons (bool2bs b2) nil)) nil)) (andb b1 b2)
+++++
intros [ | ] [ | ].
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem mult_e (cons (bool2bs true) (cons (bool2bs true) nil)) nil)) (andb true true)
+++++
reflexivity.
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem mult_e (cons (bool2bs true) (cons (bool2bs false) nil)) nil)) (andb true false)
+++++
reflexivity.
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem mult_e (cons (bool2bs false) (cons (bool2bs true) nil)) nil)) (andb false true)
+++++
reflexivity.
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
Proof.
intros [ | ] [ | ].

*****

*****
eq (bs2bool (sem mult_e (cons (bool2bs false) (cons (bool2bs false) nil)) nil)) (andb false false)
+++++
reflexivity.
-----
Lemma and_correct : forall b1 b2, bs2bool (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.
Proof.
intros [ | ] [ | ].

*****

*****

+++++
Qed.
-----
Definition minus_rev_e : BC :=\n  rec (proj 0 1 0)\n      (comp 1 2 pred nil ((proj 1 2 1) :: nil))\n      (comp 1 2 pred nil ((proj 1 2 1) :: nil)).
-----
Lemma minus_rev_correct :\n  forall m n, length (sem minus_rev_e [n] [m]) = (length m) - (length n).
-----
Lemma minus_rev_correct : forall m n, length (sem minus_rev_e [n] [m]) = (length m) - (length n).

*****

*****
forall m n : list bool, eq (length (sem minus_rev_e (cons n nil) (cons m nil))) (Init.Nat.sub (length m) (length n))
+++++
Proof.
-----
Lemma minus_rev_correct : forall m n, length (sem minus_rev_e [n] [m]) = (length m) - (length n).
Proof.

*****

*****
forall m n : list bool, eq (length (sem minus_rev_e (cons n nil) (cons m nil))) (Init.Nat.sub (length m) (length n))
+++++
induction n; simpl in *; [ omega | ].
-----
Lemma minus_rev_correct : forall m n, length (sem minus_rev_e [n] [m]) = (length m) - (length n).
Proof.
induction n; simpl in *; [ omega | ].

*****
IHn : eq\n (length\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) n nil\n (cons m nil))) (Init.Nat.sub (length m) (length n))
n : list bool
a : bool
m : list bool
*****
eq (length (if a then tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) n nil (cons m nil)) else tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) n nil (cons m nil)))) (Init.Nat.sub (length m) (S (length n)))
+++++
case a; rewrite length_tail, IHn; omega.
-----
Lemma minus_rev_correct : forall m n, length (sem minus_rev_e [n] [m]) = (length m) - (length n).
Proof.
induction n; simpl in *; [ omega | ].
case a; rewrite length_tail, IHn; omega.

*****

*****

+++++
Qed.
-----
Opaque minus_rev_e.
-----
Notation lt_e := minus_rev_e.
-----
Lemma lt_correct v1 v2:\n  bs2bool (sem lt_e [v1] [v2]) = true ->\n  length v1 < length v2.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.

*****
v1,v2 : list bool
*****
forall _ : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true, lt (length v1) (length v2)
+++++
Proof.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.
Proof.

*****
v1,v2 : list bool
*****
forall _ : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true, lt (length v1) (length v2)
+++++
intros.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.
Proof.
intros.

*****
H : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
v1,v2 : list bool
*****
lt (length v1) (length v2)
+++++
simpl in *.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.
Proof.
intros.
simpl in *.

*****
H : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
v1,v2 : list bool
*****
lt (length v1) (length v2)
+++++
apply bs_nat2bool_true in H.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true in H.

*****
H : not (eq (length (sem minus_rev_e (cons v1 nil) (cons v2 nil))) O)
v1,v2 : list bool
*****
lt (length v1) (length v2)
+++++
rewrite minus_rev_correct in H.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true in H.
rewrite minus_rev_correct in H.

*****
H : not (eq (Init.Nat.sub (length v2) (length v1)) O)
v1,v2 : list bool
*****
lt (length v1) (length v2)
+++++
omega.
-----
Lemma lt_correct v1 v2: bs2bool (sem lt_e [v1] [v2]) = true -> length v1 < length v2.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true in H.
rewrite minus_rev_correct in H.
omega.

*****

*****

+++++
Qed.
-----
Lemma unary_tl l :\n  unary l = true ->\n  unary (tl l) = true.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.

*****
l : list bool
*****
forall _ : eq (unary l) true, eq (unary (tl l)) true
+++++
Proof.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.

*****
l : list bool
*****
forall _ : eq (unary l) true, eq (unary (tl l)) true
+++++
intros.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.

*****
H : eq (unary l) true
l : list bool
*****
eq (unary (tl l)) true
+++++
destruct l.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.

*****
H : eq (unary nil) true
*****
eq (unary (tl nil)) true
+++++
simpl.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.
simpl.

*****
H : eq (unary nil) true
*****
eq true true
+++++
trivial.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.

*****
H : eq (unary (cons b l)) true
l : list bool
b : bool
*****
eq (unary (tl (cons b l))) true
+++++
simpl.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.
simpl.

*****
H : eq (unary (cons b l)) true
l : list bool
b : bool
*****
eq (unary l) true
+++++
trivial.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.
simpl.
trivial.

*****
H : eq (unary (cons b l)) true
l : list bool
b : bool
*****
eq (unary l) true
+++++
simpl in H.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.
simpl.
trivial.
simpl in H.

*****
H : eq (andb (id b) (unary l)) true
l : list bool
b : bool
*****
eq (unary l) true
+++++
rewrite andb_true_iff in H.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.
simpl.
trivial.
simpl in H.
rewrite andb_true_iff in H.

*****
H : and (eq (id b) true) (eq (unary l) true)
l : list bool
b : bool
*****
eq (unary l) true
+++++
tauto.
-----
Lemma unary_tl l : unary l = true -> unary (tl l) = true.
Proof.
intros.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma lt_correct_conv_bool v1 v2:\n  unary v2 = true ->\n  length v1 < length v2 ->\n  bs2bool (sem lt_e [v1] [v2]) = true.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v2) true) (_ : lt (length v1) (length v2)), eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
Proof.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v2) true) (_ : lt (length v1) (length v2)), eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
intros.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
simpl in *.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
apply bs_nat2bool_true_conv.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
eq (unary (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
Transparent lt_e.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
eq (unary (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
simpl.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
eq (unary (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil))) true
+++++
Opaque lt_e.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
eq (unary (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil))) true
+++++
induction v1.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.

*****
H0 : lt (length nil) (length v2)
H : eq (unary v2) true
v2 : list bool
*****
eq (unary (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) nil nil (cons v2 nil))) true
+++++
simpl.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.

*****
H0 : lt (length nil) (length v2)
H : eq (unary v2) true
v2 : list bool
*****
eq (unary v2) true
+++++
trivial.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (cons a v1) nil (cons v2 nil))) true
+++++
simpl.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (if a then tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil)) else tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil)))) true
+++++
trivial.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (if a then tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil)) else tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil)))) true
+++++
case a.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil)))) true
+++++
apply unary_tl.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.
apply unary_tl.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil))) true
+++++
apply IHv1.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.
apply unary_tl.
apply IHv1.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
lt (length v1) (length v2)
+++++
simpl in *.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.
apply unary_tl.
apply IHv1.
simpl in *.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (S (length v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
lt (length v1) (length v2)
+++++
omega.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (tl (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil)))) true
+++++
apply unary_tl.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.
apply unary_tl.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
eq (unary (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil (cons v2 nil))) true
+++++
apply IHv1.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.
apply unary_tl.
apply IHv1.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (length (cons a v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
lt (length v1) (length v2)
+++++
simpl in *.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
Transparent lt_e.
simpl.
Opaque lt_e.
induction v1.
simpl.
trivial.
case a.
apply unary_tl.
apply IHv1.
simpl in *.

*****
IHv1 : forall _ : lt (length v1) (length v2),\neq\n (unary\n (sem_rec (fun _ vsl : list (list bool) => nth O vsl nil)\n (fun _ vsl : list (list bool) => tl (nth O vsl nil))\n (fun _ vsl : list (list bool) => tl (nth O vsl nil)) v1 nil\n (cons v2 nil))) true
H0 : lt (S (length v1)) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
a : bool
*****
lt (length v1) (length v2)
+++++
omega.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
not (eq (length (sem minus_rev_e (cons v1 nil) (cons v2 nil))) O)
+++++
rewrite minus_rev_correct.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.
rewrite minus_rev_correct.

*****
H0 : lt (length v1) (length v2)
H : eq (unary v2) true
v1,v2 : list bool
*****
not (eq (Init.Nat.sub (length v2) (length v1)) O)
+++++
omega.
-----
Lemma lt_correct_conv_bool v1 v2: unary v2 = true -> length v1 < length v2 -> bs2bool (sem lt_e [v1] [v2]) = true.
Proof.
intros.
simpl in *.
apply bs_nat2bool_true_conv.

*****

*****

+++++
Qed.
-----
Lemma lt_correct_conv v1 v2 :\n  unary v1 = true ->\n  unary v2 = true ->\n  bs2bool (sem lt_e [v1] [v2]) = false ->\n  length v2 <= length v1.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false), le (length v2) (length v1)
+++++
Proof.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false), le (length v2) (length v1)
+++++
intros.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
trivial.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
apply bs_nat2bool_false in H1.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.

*****
H1 : eq (length (sem minus_rev_e (cons v1 nil) (cons v2 nil))) O
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
rewrite minus_rev_correct in H1.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
rewrite minus_rev_correct in H1.

*****
H1 : eq (Init.Nat.sub (length v2) (length v1)) O
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
omega.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
apply preservation.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv minus_rev_e) true
+++++
simpl.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv minus_rev_e) true
+++++
try reflexivity.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary (cons v1 nil)) true
+++++
simpl.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v1) true) true
+++++
try reflexivity.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.
try reflexivity.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v1) true) true
+++++
rewrite andb_true_iff.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.
try reflexivity.
rewrite andb_true_iff.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
and (eq (unary v1) true) (eq true true)
+++++
auto.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary (cons v2 nil)) true
+++++
simpl.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
try reflexivity.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.
try reflexivity.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
rewrite andb_true_iff.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.
apply preservation.
simpl.
try reflexivity.
rewrite andb_true_iff.

*****
H1 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
and (eq (unary v2) true) (eq true true)
+++++
auto.
-----
Lemma lt_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem lt_e [v1] [v2]) = false -> length v2 <= length v1.
Proof.
intros.
trivial.
apply bs_nat2bool_false in H1.

*****

*****

+++++
Qed.
-----
Lemma lt_correct_conv_nil v1 v2 :\n  unary v1 = true ->\n  unary v2 = true ->\n  sem lt_e [v1] [v2] = nil ->\n  length v2 <= length v1.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil), le (length v2) (length v1)
+++++
Proof.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil), le (length v2) (length v1)
+++++
intros.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.

*****
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
trivial.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.

*****
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
assert (bs2bool (sem lt_e [v1] [v2]) = false).
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).

*****
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
+++++
rewrite H1.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
rewrite H1.

*****
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (bs2bool nil) false
+++++
simpl.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
rewrite H1.
simpl.

*****
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq false false
+++++
trivial.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
apply bs_nat2bool_false in H2.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.

*****
H2 : eq (length (sem minus_rev_e (cons v1 nil) (cons v2 nil))) O
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
rewrite minus_rev_correct in H2.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
rewrite minus_rev_correct in H2.

*****
H2 : eq (Init.Nat.sub (length v2) (length v1)) O
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
omega.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary (sem minus_rev_e (cons v1 nil) (cons v2 nil))) true
+++++
apply preservation.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv minus_rev_e) true
+++++
simpl.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv minus_rev_e) true
+++++
try reflexivity.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary (cons v1 nil)) true
+++++
simpl.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v1) true) true
+++++
try reflexivity.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.
try reflexivity.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v1) true) true
+++++
rewrite andb_true_iff.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.
try reflexivity.
rewrite andb_true_iff.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
and (eq (unary v1) true) (eq true true)
+++++
auto.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary (cons v2 nil)) true
+++++
simpl.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
try reflexivity.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.
try reflexivity.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
rewrite andb_true_iff.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).
apply bs_nat2bool_false in H2.
apply preservation.
simpl.
try reflexivity.
rewrite andb_true_iff.

*****
H2 : eq (bs2bool (sem minus_rev_e (cons v1 nil) (cons v2 nil))) false
H1 : eq (sem minus_rev_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
and (eq (unary v2) true) (eq true true)
+++++
auto.
-----
Lemma lt_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem lt_e [v1] [v2] = nil -> length v2 <= length v1.
Proof.
intros.
trivial.
assert (bs2bool (sem lt_e [v1] [v2]) = false).

*****

*****

+++++
Qed.
-----
Definition le_e : BC :=\n  comp 1 1 lt_e (proj 1 0 0 :: nil) (comp 1 1 succ_e nil (proj 1 1 1 :: nil) :: nil).
-----
Lemma le_correct : forall v1 v2,\n  bs2bool (sem le_e [v1] [v2]) = true ->\n  length v1 <= length v2.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.

*****

*****
forall (v1 v2 : list bool) (_ : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) true), le (length v1) (length v2)
+++++
Proof.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.
Proof.

*****

*****
forall (v1 v2 : list bool) (_ : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) true), le (length v1) (length v2)
+++++
intros v1 v2 H.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.
Proof.
intros v1 v2 H.

*****
H : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) true
v1,v2 : list bool
*****
le (length v1) (length v2)
+++++
simpl in H.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.
Proof.
intros v1 v2 H.
simpl in H.

*****
H : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) true
v1,v2 : list bool
*****
le (length v1) (length v2)
+++++
apply lt_correct in H.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.
Proof.
intros v1 v2 H.
simpl in H.
apply lt_correct in H.

*****
H : lt (length v1) (length (sem succ_e nil (cons v2 nil)))
v1,v2 : list bool
*****
le (length v1) (length v2)
+++++
rewrite succ_correct in H.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.
Proof.
intros v1 v2 H.
simpl in H.
apply lt_correct in H.
rewrite succ_correct in H.

*****
H : lt (length v1) (S (length v2))
v1,v2 : list bool
*****
le (length v1) (length v2)
+++++
omega.
-----
Lemma le_correct : forall v1 v2, bs2bool (sem le_e [v1] [v2]) = true -> length v1 <= length v2.
Proof.
intros v1 v2 H.
simpl in H.
apply lt_correct in H.
rewrite succ_correct in H.
omega.

*****

*****

+++++
Qed.
-----
Lemma le_correct_conv v1 v2 :\n  unary v1 = true ->\n  unary v2 = true ->\n  bs2bool (sem le_e [v1] [v2]) = false ->\n  length v2 < length v1.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) false), lt (length v2) (length v1)
+++++
Proof.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) false), lt (length v2) (length v1)
+++++
intros.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.

*****
H1 : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
lt (length v2) (length v1)
+++++
trivial.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.

*****
H1 : eq (bs2bool (sem le_e (cons v1 nil) (cons v2 nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
lt (length v2) (length v1)
+++++
simpl in H1.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
lt (length v2) (length v1)
+++++
apply lt_correct_conv in H1.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.

*****
H1 : le (length (sem succ_e nil (cons v2 nil))) (length v1)
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
lt (length v2) (length v1)
+++++
rewrite succ_correct in H1.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
rewrite succ_correct in H1.

*****
H1 : le (S (length v2)) (length v1)
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
lt (length v2) (length v1)
+++++
omega.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary v1) true
+++++
trivial.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary (sem succ_e nil (cons v2 nil))) true
+++++
apply preservation.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv succ_e) true
+++++
simpl.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.
simpl.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv succ_e) true
+++++
try reflexivity.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary nil) true
+++++
simpl.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.
simpl.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq true true
+++++
try reflexivity.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary (cons v2 nil)) true
+++++
simpl.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.
simpl.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
try reflexivity.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.
simpl.
try reflexivity.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
rewrite andb_true_iff.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.
apply preservation.
simpl.
try reflexivity.
rewrite andb_true_iff.

*****
H1 : eq\n (bs2bool\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil))) false
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
and (eq (unary v2) true) (eq true true)
+++++
auto.
-----
Lemma le_correct_conv v1 v2 : unary v1 = true -> unary v2 = true -> bs2bool (sem le_e [v1] [v2]) = false -> length v2 < length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv in H1.

*****

*****

+++++
Qed.
-----
Lemma le_correct_conv_nil v1 v2 :\n  unary v1 = true ->\n  unary v2 = true ->\n  sem le_e [v1] [v2] = nil ->\n  S (length v2) <= length v1.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (sem le_e (cons v1 nil) (cons v2 nil)) nil), le (S (length v2)) (length v1)
+++++
Proof.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (sem le_e (cons v1 nil) (cons v2 nil)) nil), le (S (length v2)) (length v1)
+++++
intros.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.

*****
H1 : eq (sem le_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (S (length v2)) (length v1)
+++++
trivial.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.

*****
H1 : eq (sem le_e (cons v1 nil) (cons v2 nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (S (length v2)) (length v1)
+++++
simpl in H1.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (S (length v2)) (length v1)
+++++
apply lt_correct_conv_nil in H1.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.

*****
H1 : le (length (sem succ_e nil (cons v2 nil))) (length v1)
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (S (length v2)) (length v1)
+++++
rewrite succ_correct in H1.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
rewrite succ_correct in H1.

*****
H1 : le (S (length v2)) (length v1)
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
le (S (length v2)) (length v1)
+++++
omega.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary v1) true
+++++
trivial.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary (sem succ_e nil (cons v2 nil))) true
+++++
apply preservation.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv succ_e) true
+++++
simpl.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.
simpl.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary_preserv succ_e) true
+++++
try reflexivity.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary nil) true
+++++
simpl.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.
simpl.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq true true
+++++
try reflexivity.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (forallb unary (cons v2 nil)) true
+++++
simpl.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.
simpl.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
try reflexivity.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.
simpl.
try reflexivity.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (andb (unary v2) true) true
+++++
rewrite andb_true_iff.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.
apply preservation.
simpl.
try reflexivity.
rewrite andb_true_iff.

*****
H1 : eq\n (sem minus_rev_e (cons v1 nil)\n (cons (sem succ_e nil (cons v2 nil)) nil)) nil
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
and (eq (unary v2) true) (eq true true)
+++++
auto.
-----
Lemma le_correct_conv_nil v1 v2 : unary v1 = true -> unary v2 = true -> sem le_e [v1] [v2] = nil -> S (length v2) <= length v1.
Proof.
intros.
trivial.
simpl in H1.
apply lt_correct_conv_nil in H1.

*****

*****

+++++
Qed.
-----
Opaque le_e.
-----
Notation minus_e := (inv_e (from_11_to_20 minus_rev_e)) (only parsing).
-----
Lemma minus_correct :\n  forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).
-----
Lemma minus_correct : forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).

*****

*****
forall m n : list bool, eq (length (sem (inv_e (from_11_to_20 minus_rev_e)) (cons n (cons m nil)) nil)) (Init.Nat.sub (length n) (length m))
+++++
Proof.
-----
Lemma minus_correct : forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).
Proof.

*****

*****
forall m n : list bool, eq (length (sem (inv_e (from_11_to_20 minus_rev_e)) (cons n (cons m nil)) nil)) (Init.Nat.sub (length n) (length m))
+++++
intros.
-----
Lemma minus_correct : forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).
Proof.
intros.

*****
m,n : list bool
*****
eq (length (sem (inv_e (from_11_to_20 minus_rev_e)) (cons n (cons m nil)) nil)) (Init.Nat.sub (length n) (length m))
+++++
simpl.
-----
Lemma minus_correct : forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).
Proof.
intros.
simpl.

*****
m,n : list bool
*****
eq (length (sem minus_rev_e (cons m nil) (cons n nil))) (Init.Nat.sub (length n) (length m))
+++++
rewrite minus_rev_correct.
-----
Lemma minus_correct : forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).
Proof.
intros.
simpl.
rewrite minus_rev_correct.

*****
m,n : list bool
*****
eq (Init.Nat.sub (length n) (length m)) (Init.Nat.sub (length n) (length m))
+++++
trivial.
-----
Lemma minus_correct : forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).
Proof.
intros.
simpl.
rewrite minus_rev_correct.
trivial.

*****

*****

+++++
Qed.
-----
Definition max_e : BC :=\n  comp 2 0 (rec (proj 2 0 0) (proj 3 1 2) (proj 3 1 2) )\n  [ P'_e; proj 2 0 0; proj 2 0 1] nil.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 ->\n  sem max_e [v1; v2] nil = v1.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.

*****
v1,v2 : list bool
*****
forall _ : le (length v2) (length v1), eq (sem max_e (cons v1 (cons v2 nil)) nil) v1
+++++
Proof.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.

*****
v1,v2 : list bool
*****
forall _ : le (length v2) (length v1), eq (sem max_e (cons v1 (cons v2 nil)) nil) v1
+++++
simpl.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.

*****
v1,v2 : list bool
*****
forall _ : le (length v2) (length v1), eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (sem P_e (cons v1 nil) (cons v2 nil)) (cons v1 (cons v2 nil)) nil) v1
+++++
intros.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (sem P_e (cons v1 nil) (cons v2 nil)) (cons v1 (cons v2 nil)) nil) v1
+++++
rewrite P_correct.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (P v1 v2) (cons v1 (cons v2 nil)) nil) v1
+++++
unfold P.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (skipn (length v1) v2) (cons v1 (cons v2 nil)) nil) v1
+++++
rewrite skipn_nil.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
rewrite skipn_nil.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) nil (cons v1 (cons v2 nil)) nil) v1
+++++
simpl.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
rewrite skipn_nil.
simpl.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
eq v1 v1
+++++
trivial.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
rewrite skipn_nil.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
simpl.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
rewrite skipn_nil.
simpl.

*****
H : le (length v2) (length v1)
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
trivial.
-----
Lemma max_correct_l v1 v2 : length v2 <= length v1 -> sem max_e [v1; v2] nil = v1.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
rewrite skipn_nil.

*****

*****

+++++
Qed.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 ->\n  sem max_e [v1; v2] nil = v2.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.

*****
v1,v2 : list bool
*****
forall _ : lt (length v1) (length v2), eq (sem max_e (cons v1 (cons v2 nil)) nil) v2
+++++
Proof.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.

*****
v1,v2 : list bool
*****
forall _ : lt (length v1) (length v2), eq (sem max_e (cons v1 (cons v2 nil)) nil) v2
+++++
simpl.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.

*****
v1,v2 : list bool
*****
forall _ : lt (length v1) (length v2), eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (sem P_e (cons v1 nil) (cons v2 nil)) (cons v1 (cons v2 nil)) nil) v2
+++++
intros.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (sem P_e (cons v1 nil) (cons v2 nil)) (cons v1 (cons v2 nil)) nil) v2
+++++
rewrite P_correct.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (P v1 v2) (cons v1 (cons v2 nil)) nil) v2
+++++
unfold P.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (skipn (length v1) v2) (cons v1 (cons v2 nil)) nil) v2
+++++
case_eq ( (skipn (length v1) v2) ).
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
forall _ : eq (skipn (length v1) v2) nil, eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) nil (cons v1 (cons v2 nil)) nil) v2
+++++
simpl.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
forall _ : eq (skipn (length v1) v2) nil, eq v1 v2
+++++
intros.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.

*****
H0 : eq (skipn (length v1) v2) nil
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq v1 v2
+++++
contradict H.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.
contradict H.

*****
H0 : eq (skipn (length v1) v2) nil
v1,v2 : list bool
*****
not (lt (length v1) (length v2))
+++++
apply le_not_lt.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.
contradict H.
apply le_not_lt.

*****
H0 : eq (skipn (length v1) v2) nil
v1,v2 : list bool
*****
le (length v2) (length v1)
+++++
apply skipn_nil_length.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.
contradict H.
apply le_not_lt.
apply skipn_nil_length.

*****
H0 : eq (skipn (length v1) v2) nil
v1,v2 : list bool
*****
eq (skipn (length v1) v2) nil
+++++
trivial.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
forall (b : bool) (l : list bool) (_ : eq (skipn (length v1) v2) (cons b l)), eq (sem_rec (fun vnl _ : list (list bool) => nth O vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (fun vnl _ : list (list bool) => nth (S (S O)) vnl nil) (cons b l) (cons v1 (cons v2 nil)) nil) v2
+++++
simpl.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.

*****
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
forall (b : bool) (l : list bool) (_ : eq (skipn (length v1) v2) (cons b l)), eq (if b then v2 else v2) v2
+++++
intros.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.

*****
H0 : eq (skipn (length v1) v2) (cons b l)
l : list bool
b : bool
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq (if b then v2 else v2) v2
+++++
case b.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.
case b.

*****
H0 : eq (skipn (length v1) v2) (cons b l)
l : list bool
b : bool
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq v2 v2
+++++
trivial.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).
simpl.
intros.
case b.

*****
H0 : eq (skipn (length v1) v2) (cons b l)
l : list bool
b : bool
H : lt (length v1) (length v2)
v1,v2 : list bool
*****
eq v2 v2
+++++
trivial.
-----
Lemma max_correct_r v1 v2 : length v1 < length v2 -> sem max_e [v1; v2] nil = v2.
Proof.
simpl.
intros.
rewrite P_correct.
unfold P.
case_eq ( (skipn (length v1) v2) ).

*****

*****

+++++
Qed.
-----
Fixpoint div' (q y:nat)(x:nat) : nat :=\n  match q with\n  | 0 => 0\n  | S q' => if leb (q' * y) x then q' else div' q' y x\n  end.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0),\n  (q > proj1_sig (quotient y Hy x) -> \n    div' q y x = proj1_sig (quotient y Hy x)) /\\n  (q <= proj1_sig (quotient y Hy x) -> \n    div' q y x = Peano.pred q).
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).

*****

*****
forall (q x y : nat) (Hy : gt y O), and (forall _ : gt q (proj1_sig (quotient y Hy x)), eq (div' q y x) (proj1_sig (quotient y Hy x))) (forall _ : le q (proj1_sig (quotient y Hy x)), eq (div' q y x) (Init.Nat.pred q))
+++++
Proof.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.

*****

*****
forall (q x y : nat) (Hy : gt y O), and (forall _ : gt q (proj1_sig (quotient y Hy x)), eq (div' q y x) (proj1_sig (quotient y Hy x))) (forall _ : le q (proj1_sig (quotient y Hy x)), eq (div' q y x) (Init.Nat.pred q))
+++++
intros q x y Hy.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.

*****
Hy : gt y O
q,x,y : nat
*****
and (forall _ : gt q (proj1_sig (quotient y Hy x)), eq (div' q y x) (proj1_sig (quotient y Hy x))) (forall _ : le q (proj1_sig (quotient y Hy x)), eq (div' q y x) (Init.Nat.pred q))
+++++
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.

*****
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul qu y) r)
qu,r : nat
Hy : gt y O
q,x,y : nat
*****
and (forall _ : gt q qu, eq (div' q y x) qu) (forall _ : le q qu, eq (div' q y x) (Init.Nat.pred q))
+++++
induction q as [ | q' IH]; simpl; [ omega | ].
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].

*****
IH : and (forall _ : gt q' qu, eq (div' q' y x) qu)\n (forall _ : le q' qu, eq (div' q' y x) (Init.Nat.pred q'))
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul qu y) r)
qu,r : nat
Hy : gt y O
q',x,y : nat
*****
and (forall _ : gt (S q') qu, eq (if Nat.leb (Init.Nat.mul q' y) x then q' else div' q' y x) qu) (forall _ : le (S q') qu, eq (if Nat.leb (Init.Nat.mul q' y) x then q' else div' q' y x) q')
+++++
case_eq (leb (q' * y) x); intro H.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.

*****
H : eq (Nat.leb (Init.Nat.mul q' y) x) true
IH : and (forall _ : gt q' qu, eq (div' q' y x) qu)\n (forall _ : le q' qu, eq (div' q' y x) (Init.Nat.pred q'))
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul qu y) r)
qu,r : nat
Hy : gt y O
q',x,y : nat
*****
and (forall _ : gt (S q') qu, eq q' qu) (forall _ : le (S q') qu, eq q' q')
+++++
clear IH.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.

*****
H : eq (Nat.leb (Init.Nat.mul q' y) x) true
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul qu y) r)
qu,r : nat
Hy : gt y O
q',x,y : nat
*****
and (forall _ : gt (S q') qu, eq q' qu) (forall _ : le (S q') qu, eq q' q')
+++++
apply leb_complete in H; split; subst x; intros; trivial.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.

*****
H0 : gt (S q') qu
H : le (Init.Nat.mul q' y) (Init.Nat.add (Init.Nat.mul qu y) r)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq q' qu
+++++
assert (qu <= q') as H1 by omega; clear H0.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.

*****
H1 : le qu q'
H : le (Init.Nat.mul q' y) (Init.Nat.add (Init.Nat.mul qu y) r)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq q' qu
+++++
apply le_lt_or_eq in H1.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.

*****
H1 : or (lt qu q') (eq qu q')
H : le (Init.Nat.mul q' y) (Init.Nat.add (Init.Nat.mul qu y) r)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq q' qu
+++++
destruct H1; auto.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.

*****
H0 : lt qu q'
H : le (Init.Nat.mul q' y) (Init.Nat.add (Init.Nat.mul qu y) r)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq q' qu
+++++
contradict H.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.

*****
H0 : lt qu q'
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
not (le (Init.Nat.mul q' y) (Init.Nat.add (Init.Nat.mul qu y) r))
+++++
apply lt_not_le.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.

*****
H0 : lt qu q'
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
+++++
apply lt_le_trans with (qu * y + y); [ omega | ].
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].

*****
H0 : lt qu q'
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
le (Init.Nat.add (Init.Nat.mul qu y) y) (Init.Nat.mul q' y)
+++++
rewrite <- mult_succ_l.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.

*****
H0 : lt qu q'
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
le (Init.Nat.mul (S qu) y) (Init.Nat.mul q' y)
+++++
apply mult_le_compat_r; omega.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.

*****
H : eq (Nat.leb (Init.Nat.mul q' y) x) false
IH : and (forall _ : gt q' qu, eq (div' q' y x) qu)\n (forall _ : le q' qu, eq (div' q' y x) (Init.Nat.pred q'))
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul qu y) r)
qu,r : nat
Hy : gt y O
q',x,y : nat
*****
and (forall _ : gt (S q') qu, eq (div' q' y x) qu) (forall _ : le (S q') qu, eq (div' q' y x) q')
+++++
apply leb_complete_conv in H; split; intros; subst.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.

*****
H0 : gt (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu
+++++
assert (q'=qu \/ q'>qu) as [H3 | H3]; subst; omega.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.

*****
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) q'
+++++
assert (S q' = qu \/ S q' < qu) as [H4 | H4] by omega; subst.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.

*****
H : lt (Init.Nat.add (Init.Nat.mul (S q') y) r) (Init.Nat.mul q' y)
IH : and\n (forall _ : gt q' (S q'),\n eq (div' q' y (Init.Nat.add (Init.Nat.mul (S q') y) r)) (S q'))\n (forall _ : le q' (S q'),\n eq (div' q' y (Init.Nat.add (Init.Nat.mul (S q') y) r))\n (Init.Nat.pred q'))
H0 : le (S q') (S q')
H2 : gt y r
r : nat
Hy : gt y O
q',y : nat
*****
eq (div' q' y (Init.Nat.add (Init.Nat.mul (S q') y) r)) q'
+++++
contradict H.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.

*****
IH : and\n (forall _ : gt q' (S q'),\n eq (div' q' y (Init.Nat.add (Init.Nat.mul (S q') y) r)) (S q'))\n (forall _ : le q' (S q'),\n eq (div' q' y (Init.Nat.add (Init.Nat.mul (S q') y) r))\n (Init.Nat.pred q'))
H0 : le (S q') (S q')
H2 : gt y r
r : nat
Hy : gt y O
q',y : nat
*****
not (lt (Init.Nat.add (Init.Nat.mul (S q') y) r) (Init.Nat.mul q' y))
+++++
apply le_not_lt; simpl; omega.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.

*****
H4 : lt (S q') qu
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) q'
+++++
contradict H4.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.
contradict H4.

*****
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
not (lt (S q') qu)
+++++
apply le_not_lt.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.
contradict H4.
apply le_not_lt.

*****
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
le qu (S q')
+++++
apply mult_S_le_reg_l with (Peano.pred y).
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.
contradict H4.
apply le_not_lt.
apply mult_S_le_reg_l with (Peano.pred y).

*****
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
le (Init.Nat.mul (S (Init.Nat.pred y)) qu) (Init.Nat.mul (S (Init.Nat.pred y)) (S q'))
+++++
rewrite <- S_pred with (m:=0), mult_comm, (mult_comm y (S q')).
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.
contradict H4.
apply le_not_lt.
apply mult_S_le_reg_l with (Peano.pred y).
rewrite <- S_pred with (m:=0), mult_comm, (mult_comm y (S q')).

*****
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
le (Nat.mul qu y) (Nat.mul (S q') y)
+++++
simpl; omega.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.
contradict H4.
apply le_not_lt.
apply mult_S_le_reg_l with (Peano.pred y).
rewrite <- S_pred with (m:=0), mult_comm, (mult_comm y (S q')).
simpl; omega.

*****
H0 : le (S q') qu
IH : and\n (forall _ : gt q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r)) qu)\n (forall _ : le q' qu,\n eq (div' q' y (Init.Nat.add (Init.Nat.mul qu y) r))\n (Init.Nat.pred q'))
H : lt (Init.Nat.add (Init.Nat.mul qu y) r) (Init.Nat.mul q' y)
H2 : gt y r
qu,r : nat
Hy : gt y O
q',y : nat
*****
lt O y
+++++
omega.
-----
Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0), (q > proj1_sig (quotient y Hy x) -> div' q y x = proj1_sig (quotient y Hy x)) /\\ (q <= proj1_sig (quotient y Hy x) -> div' q y x = Peano.pred q).
Proof.
intros q x y Hy.
destruct (quotient y Hy x) as (qu & r & H1 & H2); simpl.
induction q as [ | q' IH]; simpl; [ omega | ].
case_eq (leb (q' * y) x); intro H.
clear IH.
apply leb_complete in H; split; subst x; intros; trivial.
assert (qu <= q') as H1 by omega; clear H0.
apply le_lt_or_eq in H1.
destruct H1; auto.
contradict H.
apply lt_not_le.
apply lt_le_trans with (qu * y + y); [ omega | ].
rewrite <- mult_succ_l.
apply mult_le_compat_r; omega.
apply leb_complete_conv in H; split; intros; subst.
assert (q'=qu \\/ q'>qu) as [H3 | H3]; subst; omega.
assert (S q' = qu \\/ S q' < qu) as [H4 | H4] by omega; subst.
contradict H.
apply le_not_lt; simpl; omega.
contradict H4.
apply le_not_lt.
apply mult_S_le_reg_l with (Peano.pred y).
rewrite <- S_pred with (m:=0), mult_comm, (mult_comm y (S q')).
simpl; omega.
omega.

*****

*****

+++++
Qed.
-----
Definition div (x y:nat) : nat := div' (S x) y x.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0),\n  div x y = proj1_sig (quotient y Hy x).
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).

*****

*****
forall (x y : nat) (Hy : gt y O), eq (div x y) (proj1_sig (quotient y Hy x))
+++++
Proof.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.

*****

*****
forall (x y : nat) (Hy : gt y O), eq (div x y) (proj1_sig (quotient y Hy x))
+++++
unfold div.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.

*****

*****
forall (x y : nat) (Hy : gt y O), eq (div' (S x) y x) (proj1_sig (quotient y Hy x))
+++++
intros x y Hy.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.

*****
Hy : gt y O
x,y : nat
*****
eq (div' (S x) y x) (proj1_sig (quotient y Hy x))
+++++
generalize (div'_coq_correct (S x) x y Hy).
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).

*****
Hy : gt y O
x,y : nat
*****
forall _ : and (forall _ : gt (S x) (proj1_sig (quotient y Hy x)), eq (div' (S x) y x) (proj1_sig (quotient y Hy x))) (forall _ : le (S x) (proj1_sig (quotient y Hy x)), eq (div' (S x) y x) (Init.Nat.pred (S x))), eq (div' (S x) y x) (proj1_sig (quotient y Hy x))
+++++
destruct (quotient y Hy x) as (q & r & H1 & H2).
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).

*****
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul q y) r)
q,r : nat
Hy : gt y O
x,y : nat
*****
forall _ : and (forall _ : gt (S x) (proj1_sig (exist (fun q : nat => ex (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r))) q (ex_intro (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r)) r (conj H1 H2)))), eq (div' (S x) y x) (proj1_sig (exist (fun q : nat => ex (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r))) q (ex_intro (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r)) r (conj H1 H2))))) (forall _ : le (S x) (proj1_sig (exist (fun q : nat => ex (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r))) q (ex_intro (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r)) r (conj H1 H2)))), eq (div' (S x) y x) (Init.Nat.pred (S x))), eq (div' (S x) y x) (proj1_sig (exist (fun q : nat => ex (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r))) q (ex_intro (fun r : nat => and (eq x (Init.Nat.add (Init.Nat.mul q y) r)) (gt y r)) r (conj H1 H2))))
+++++
simpl.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.

*****
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul q y) r)
q,r : nat
Hy : gt y O
x,y : nat
*****
forall _ : and (forall _ : gt (S x) q, eq (if Nat.leb (Init.Nat.mul x y) x then x else div' x y x) q) (forall _ : le (S x) q, eq (if Nat.leb (Init.Nat.mul x y) x then x else div' x y x) x), eq (if Nat.leb (Init.Nat.mul x y) x then x else div' x y x) q
+++++
intros [H3 _].
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].

*****
H3 : forall _ : gt (S x) q,\neq (if Nat.leb (Init.Nat.mul x y) x then x else div' x y x) q
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul q y) r)
q,r : nat
Hy : gt y O
x,y : nat
*****
eq (if Nat.leb (Init.Nat.mul x y) x then x else div' x y x) q
+++++
apply H3.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.

*****
H3 : forall _ : gt (S x) q,\neq (if Nat.leb (Init.Nat.mul x y) x then x else div' x y x) q
H2 : gt y r
H1 : eq x (Init.Nat.add (Init.Nat.mul q y) r)
q,r : nat
Hy : gt y O
x,y : nat
*****
gt (S x) q
+++++
subst x.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q
+++++
apply le_gt_S.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
le q (Init.Nat.add (Init.Nat.mul q y) r)
+++++
apply le_trans with (q*y).
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.
apply le_trans with (q*y).

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
le q (Init.Nat.mul q y)
+++++
idtac.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.
apply le_trans with (q*y).
idtac.

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
le q (Init.Nat.mul q y)
+++++
rewrite <- (mult_1_r q) at 1.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.
apply le_trans with (q*y).
idtac.
rewrite <- (mult_1_r q) at 1.

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
le (Nat.mul q (S O)) (Init.Nat.mul q y)
+++++
apply mult_le_compat_l.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.
apply le_trans with (q*y).
idtac.
rewrite <- (mult_1_r q) at 1.
apply mult_le_compat_l.

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
le (S O) y
+++++
omega.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.
apply le_trans with (q*y).

*****
H3 : forall _ : gt (S (Init.Nat.add (Init.Nat.mul q y) r)) q,\neq\n (if\n Nat.leb (Init.Nat.mul (Init.Nat.add (Init.Nat.mul q y) r) y)\n (Init.Nat.add (Init.Nat.mul q y) r)\n then Init.Nat.add (Init.Nat.mul q y) r\n else\n div' (Init.Nat.add (Init.Nat.mul q y) r) y\n (Init.Nat.add (Init.Nat.mul q y) r)) q
H2 : gt y r
q,r : nat
Hy : gt y O
y : nat
*****
le (Init.Nat.mul q y) (Init.Nat.add (Init.Nat.mul q y) r)
+++++
omega.
-----
Lemma div_coq_correct : forall (x y:nat) (Hy:y>0), div x y = proj1_sig (quotient y Hy x).
Proof.
unfold div.
intros x y Hy.
generalize (div'_coq_correct (S x) x y Hy).
destruct (quotient y Hy x) as (q & r & H1 & H2).
simpl.
intros [H3 _].
apply H3.
subst x.
apply le_gt_S.
apply le_trans with (q*y).

*****

*****

+++++
Qed.
-----
Definition div'_e : BC :=\n  rec (zero_e 1 1)\n  (comp 2 2 cond nil\n    [comp 2 2 le_e [comp 2 0 mult_e [proj 2 0 0; proj 2 0 1] nil]\n      [proj 2 2 3]; proj 2 2 2; proj 2 2 0; proj 2 2 2])\n  (comp 2 2 cond nil\n    [comp 2 2 le_e [comp 2 0 mult_e [proj 2 0 0; proj 2 0 1] nil]\n      [proj 2 2 3]; proj 2 2 2; proj 2 2 0; proj 2 2 2]).
-----
Lemma hd_cons l a l' :\n  l = a :: l' ->\n  bs2bool l = a.
-----
Lemma hd_cons l a l' : l = a :: l' -> bs2bool l = a.

*****
l' : list bool
a : bool
l : list bool
*****
forall _ : eq l (cons a l'), eq (bs2bool l) a
+++++
Proof.
-----
Lemma hd_cons l a l' : l = a :: l' -> bs2bool l = a.
Proof.

*****
l' : list bool
a : bool
l : list bool
*****
forall _ : eq l (cons a l'), eq (bs2bool l) a
+++++
intros.
-----
Lemma hd_cons l a l' : l = a :: l' -> bs2bool l = a.
Proof.
intros.

*****
H : eq l (cons a l')
l' : list bool
a : bool
l : list bool
*****
eq (bs2bool l) a
+++++
subst.
-----
Lemma hd_cons l a l' : l = a :: l' -> bs2bool l = a.
Proof.
intros.
subst.

*****
l' : list bool
a : bool
*****
eq (bs2bool (cons a l')) a
+++++
trivial.
-----
Lemma hd_cons l a l' : l = a :: l' -> bs2bool l = a.
Proof.
intros.
subst.
trivial.

*****

*****

+++++
Qed.
-----
Ltac elim_if :=  match goal with \n   | |- context [if ?c then ?c1 else ?c2]  => case_eq c\n end.
-----
Lemma div'_correct v1 v2 v3 :\n  unary v1 = true -> unary v2 = true -> unary v3 = true ->\n  length (sem div'_e [v1;v2] [v3]) = \n  div' (length v1) (length v2) (length v3).
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).

*****
v1,v2,v3 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (unary v3) true), eq (length (sem div'_e (cons v1 (cons v2 nil)) (cons v3 nil))) (div' (length v1) (length v2) (length v3))
+++++
Proof.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.

*****
v1,v2,v3 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true) (_ : eq (unary v3) true), eq (length (sem div'_e (cons v1 (cons v2 nil)) (cons v3 nil))) (div' (length v1) (length v2) (length v3))
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.

*****
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2,v3 : list bool
*****
eq (length (sem div'_e (cons v1 (cons v2 nil)) (cons v3 nil))) (div' (length v1) (length v2) (length v3))
+++++
induction v1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.

*****
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq (unary nil) true
v2,v3 : list bool
*****
eq (length (sem div'_e (cons nil (cons v2 nil)) (cons v3 nil))) (div' (length nil) (length v2) (length v3))
+++++
simpl in *.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.

*****
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq true true
v2,v3 : list bool
*****
eq O O
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.

*****
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq true true
v2,v3 : list bool
*****
eq O O
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.

*****
IHv1 : forall _ : eq (unary v1) true,\neq (length (sem div'_e (cons v1 (cons v2 nil)) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq (unary (cons a v1)) true
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem div'_e (cons (cons a v1) (cons v2 nil)) (cons v3 nil))) (div' (length (cons a v1)) (length v2) (length v3))
+++++
simpl in *.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq (andb (id a) (unary v1)) true
v1,v2,v3 : list bool
a : bool
*****
eq (length (if a then match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end else match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq (andb (id a) (unary v1)) true
v1,v2,v3 : list bool
a : bool
*****
eq (length (if a then match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end else match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : eq (andb (id a) (unary v1)) true
v1,v2,v3 : list bool
a : bool
*****
eq (length (if a then match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end else match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite andb_true_iff in H.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (if a then match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end else match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
case a.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
simpl.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
forall _ : eq (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil)) nil, eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply le_correct_conv_nil in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.

*****
H2 : le (S (length v3)) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite mult_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
rewrite mult_correct in H2.

*****
H2 : le (S (length v3)) (Init.Nat.mul (length v1) (length v2))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite leb_correct_conv.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
rewrite mult_correct in H2.
rewrite leb_correct_conv.

*****
H2 : le (S (length v3)) (Init.Nat.mul (length v1) (length v2))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
rewrite mult_correct in H2.
rewrite leb_correct_conv.

*****
H2 : le (S (length v3)) (Init.Nat.mul (length v1) (length v2))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary (sem mult_e (cons v1 (cons v2 nil)) nil)) true
+++++
apply preservation.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary_preserv mult_e) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.
trivial.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
simpl.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.
trivial.
simpl.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (andb (unary v1) (andb (unary v2) true)) true
+++++
repeat rewrite andb_true_iff.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.
trivial.
simpl.
repeat rewrite andb_true_iff.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
and (eq (unary v1) true) (and (eq (unary v2) true) (eq true true))
+++++
tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary nil) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v3) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
forall (b : bool) (l : list bool) (_ : eq (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil)) (cons b l)), eq (length (if b then v1 else sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) (cons b l)
l : list bool
b : bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (if b then v1 else sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply hd_cons in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) b
l : list bool
b : bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (if b then v1 else sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
destruct b.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) true
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply le_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.

*****
H2 : le (length (sem mult_e (cons v1 (cons v2 nil)) nil)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite mult_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.
rewrite mult_correct in H2.

*****
H2 : le (Init.Nat.mul (length v1) (length v2)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite leb_correct.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.
rewrite mult_correct in H2.
rewrite leb_correct.

*****
H2 : le (Init.Nat.mul (length v1) (length v2)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (length v1)
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.
rewrite mult_correct in H2.
rewrite leb_correct.

*****
H2 : le (Init.Nat.mul (length v1) (length v2)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
le (Init.Nat.mul (length v1) (length v2)) (length v3)
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply le_correct_conv in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
simpl in IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
clear IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
try tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite leb_correct_conv.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.
trivial.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
rewrite mult_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.
trivial.
rewrite mult_correct in H2.

*****
H2 : lt (length v3) (Init.Nat.mul (length v1) (length v2))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
clear IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
try tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary (sem mult_e (cons v1 (cons v2 nil)) nil)) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary (sem mult_e (cons v1 (cons v2 nil)) nil)) true
+++++
apply preservation.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary_preserv mult_e) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.
trivial.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
simpl.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.
trivial.
simpl.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (andb (unary v1) (andb (unary v2) true)) true
+++++
do 2 rewrite andb_true_iff.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.
trivial.
simpl.
do 2 rewrite andb_true_iff.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
and (eq (unary v1) true) (and (eq (unary v2) true) (eq true true))
+++++
tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary nil) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v3) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
simpl.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length match sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil) with | cons true _ => v1 | _ => sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil) end) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
forall _ : eq (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil)) nil, eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply le_correct_conv_nil in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.

*****
H2 : le (S (length v3)) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite mult_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
rewrite mult_correct in H2.

*****
H2 : le (S (length v3)) (Init.Nat.mul (length v1) (length v2))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite leb_correct_conv.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
rewrite mult_correct in H2.
rewrite leb_correct_conv.

*****
H2 : le (S (length v3)) (Init.Nat.mul (length v1) (length v2))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
rewrite mult_correct in H2.
rewrite leb_correct_conv.

*****
H2 : le (S (length v3)) (Init.Nat.mul (length v1) (length v2))
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary (sem mult_e (cons v1 (cons v2 nil)) nil)) true
+++++
apply preservation.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary_preserv mult_e) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.
trivial.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
simpl.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.
trivial.
simpl.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (andb (unary v1) (andb (unary v2) true)) true
+++++
repeat rewrite andb_true_iff.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.
trivial.
simpl.
repeat rewrite andb_true_iff.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
and (eq (unary v1) true) (and (eq (unary v2) true) (eq true true))
+++++
tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.
apply preservation.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary nil) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.
apply le_correct_conv_nil in H2.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v3) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
rewrite IHv1.
trivial.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) nil
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).

*****
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
forall (b : bool) (l : list bool) (_ : eq (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil) (cons v3 nil)) (cons b l)), eq (length (if b then v1 else sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
intros.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.

*****
H2 : eq\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil)) (cons b l)
l : list bool
b : bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (if b then v1 else sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply hd_cons in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) b
l : list bool
b : bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (if b then v1 else sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
destruct b.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) true
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply le_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.

*****
H2 : le (length (sem mult_e (cons v1 (cons v2 nil)) nil)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite mult_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.
rewrite mult_correct in H2.

*****
H2 : le (Init.Nat.mul (length v1) (length v2)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite leb_correct.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.
rewrite mult_correct in H2.
rewrite leb_correct.

*****
H2 : le (Init.Nat.mul (length v1) (length v2)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length v1) (length v1)
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct in H2.
rewrite mult_correct in H2.
rewrite leb_correct.

*****
H2 : le (Init.Nat.mul (length v1) (length v2)) (length v3)
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
le (Init.Nat.mul (length v1) (length v2)) (length v3)
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
apply le_correct_conv in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
simpl in IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (length (sem_rec (fun _ _ : list (list bool) => nil) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) (fun vnl vsl : list (list bool) => match sem le_e (cons (sem mult_e (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil)) nil) nil) (cons (nth (S O) vsl nil) nil) with | cons true _ => nth O vnl nil | _ => nth O vsl nil end) v1 (cons v2 nil) (cons v3 nil))) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
clear IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
try tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (if Nat.leb (Init.Nat.mul (length v1) (length v2)) (length v3) then length v1 else div' (length v1) (length v2) (length v3))
+++++
rewrite leb_correct_conv.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (div' (length v1) (length v2) (length v3)) (div' (length v1) (length v2) (length v3))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.
trivial.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
rewrite mult_correct in H2.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.
try tauto.
rewrite leb_correct_conv.
trivial.
rewrite mult_correct in H2.

*****
H2 : lt (length v3) (Init.Nat.mul (length v1) (length v2))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
lt (length v3) (Init.Nat.mul (length v1) (length v2))
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
clear IHv1.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
simpl in IHv1.
rewrite IHv1.
clear IHv1.

*****
H2 : lt (length v3) (length (sem mult_e (cons v1 (cons v2 nil)) nil))
l : list bool
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v1) true
+++++
try tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary (sem mult_e (cons v1 (cons v2 nil)) nil)) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary (sem mult_e (cons v1 (cons v2 nil)) nil)) true
+++++
apply preservation.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary_preserv mult_e) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.
trivial.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary (cons v1 (cons v2 nil))) true
+++++
simpl.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.
trivial.
simpl.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (andb (unary v1) (andb (unary v2) true)) true
+++++
do 2 rewrite andb_true_iff.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.
trivial.
simpl.
do 2 rewrite andb_true_iff.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
and (eq (unary v1) true) (and (eq (unary v2) true) (eq true true))
+++++
tauto.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.
trivial.
apply preservation.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (forallb unary nil) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.
simpl in *.
intros.
trivial.
rewrite andb_true_iff in H.
case a.
simpl.
case_eq ( sem le_e [sem mult_e [v1; v2] nil] [v3] ).
intros.
apply hd_cons in H2.
destruct b.
apply le_correct_conv in H2.

*****
H2 : eq\n (bs2bool\n (sem le_e (cons (sem mult_e (cons v1 (cons v2 nil)) nil) nil)\n (cons v3 nil))) false
l : list bool
IHv1 : forall _ : eq (unary v1) true,\neq\n (length\n (sem_rec (fun _ _ : list (list bool) => nil)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end)\n (fun vnl vsl : list (list bool) =>\n match\n sem le_e\n (cons\n (sem mult_e\n (cons (nth O vnl nil) (cons (nth (S O) vnl nil) nil))\n nil) nil) (cons (nth (S O) vsl nil) nil)\n with\n | cons true _ => nth O vnl nil\n | _ => nth O vsl nil\n end) v1 (cons v2 nil) (cons v3 nil)))\n (div' (length v1) (length v2) (length v3))
H1 : eq (unary v3) true
H0 : eq (unary v2) true
H : and (eq (id a) true) (eq (unary v1) true)
v1,v2,v3 : list bool
a : bool
*****
eq (unary v3) true
+++++
trivial.
-----
Lemma div'_correct v1 v2 v3 : unary v1 = true -> unary v2 = true -> unary v3 = true -> length (sem div'_e [v1;v2] [v3]) = div' (length v1) (length v2) (length v3).
Proof.
intros.
induction v1.

*****

*****

+++++
Qed.
-----
Opaque div'_e.
-----
Definition div_e : BC :=\n  comp 2 0 div'_e [comp 2 0 succ_e nil [proj 2 0 0]; proj 2 0 1] [proj 2 0 0].
-----
Lemma div_correct v1 v2 :\n  unary v1 = true -> unary v2 = true -> \n  length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true), eq (length (sem div_e (cons v1 (cons v2 nil)) nil)) (div (length v1) (length v2))
+++++
Proof.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.

*****
v1,v2 : list bool
*****
forall (_ : eq (unary v1) true) (_ : eq (unary v2) true), eq (length (sem div_e (cons v1 (cons v2 nil)) nil)) (div (length v1) (length v2))
+++++
intros.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.

*****
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (length (sem div_e (cons v1 (cons v2 nil)) nil)) (div (length v1) (length v2))
+++++
simpl sem.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.
simpl sem.

*****
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (length (sem div'_e (cons (sem succ_e nil (cons v1 nil)) (cons v2 nil)) (cons v1 nil))) (div (length v1) (length v2))
+++++
rewrite div'_correct.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.
simpl sem.
rewrite div'_correct.

*****
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (div' (length (sem succ_e nil (cons v1 nil))) (length v2) (length v1)) (div (length v1) (length v2))
+++++
trivial.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.
simpl sem.
rewrite div'_correct.

*****
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary (sem succ_e nil (cons v1 nil))) true
+++++
trivial.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.
simpl sem.
rewrite div'_correct.

*****
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary v2) true
+++++
trivial.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.
simpl sem.
rewrite div'_correct.

*****
H0 : eq (unary v2) true
H : eq (unary v1) true
v1,v2 : list bool
*****
eq (unary v1) true
+++++
trivial.
-----
Lemma div_correct v1 v2 : unary v1 = true -> unary v2 = true -> length (sem div_e [v1; v2] nil) = div (length v1) (length v2).
Proof.
intros.
simpl sem.
rewrite div'_correct.

*****

*****

+++++
Qed.
-----
Fixpoint scalar_e (a:nat)(n:nat)(e:BC) : BC :=\n  match a with\n  | 0 => zero_e n 0\n  | S a' => comp n 0 plus_e [e] [scalar_e a' n e]\n  end.
-----
Lemma scalar_arities :\n  forall a n e,\n  arities e = ok_arities n 0 ->\n  arities (scalar_e a n e) = ok_arities n 0.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.

*****

*****
forall (a n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)), eq (arities (scalar_e a n e)) (ok_arities n O)
+++++
Proof.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.

*****

*****
forall (a n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)), eq (arities (scalar_e a n e)) (ok_arities n O)
+++++
induction a as [ | a IH].
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].

*****

*****
forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)), eq (arities (scalar_e O n e)) (ok_arities n O)
+++++
simpl.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.

*****

*****
forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)), eq (ok_arities n O) (ok_arities n O)
+++++
trivial.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].

*****
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)), eq (arities (scalar_e (S a) n e)) (ok_arities n O)
+++++
simpl.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.

*****
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)), eq match arities plus_e with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) | error_comp a0 l l0 => error_comp (error_comp a0 l l0) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S O)) (Nat.eqb hs (S O))) (andb (aeq (arities e) (ok_arities n O)) true)) (andb (aeq (arities (scalar_e a n e)) (ok_arities n O)) true) then ok_arities n O else error_comp (ok_arities hn hs) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) end (ok_arities n O)
+++++
intros n e H.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.
intros n e H.

*****
H : eq (arities e) (ok_arities n O)
e : BC
n : nat
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
eq match arities plus_e with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) | error_comp a0 l l0 => error_comp (error_comp a0 l l0) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S O)) (Nat.eqb hs (S O))) (andb (aeq (arities e) (ok_arities n O)) true)) (andb (aeq (arities (scalar_e a n e)) (ok_arities n O)) true) then ok_arities n O else error_comp (ok_arities hn hs) (cons (arities e) nil) (cons (arities (scalar_e a n e)) nil) end (ok_arities n O)
+++++
rewrite H.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.
intros n e H.
rewrite H.

*****
H : eq (arities e) (ok_arities n O)
e : BC
n : nat
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
eq match arities plus_e with | error_rec a0 a1 a2 => error_comp (error_rec a0 a1 a2) (cons (ok_arities n O) nil) (cons (arities (scalar_e a n e)) nil) | error_comp a0 l l0 => error_comp (error_comp a0 l l0) (cons (ok_arities n O) nil) (cons (arities (scalar_e a n e)) nil) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) nil) (cons (arities (scalar_e a n e)) nil) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S O)) (Nat.eqb hs (S O))) (andb (aeq (ok_arities n O) (ok_arities n O)) true)) (andb (aeq (arities (scalar_e a n e)) (ok_arities n O)) true) then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) nil) (cons (arities (scalar_e a n e)) nil) end (ok_arities n O)
+++++
rewrite (IH _ _ H).
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.
intros n e H.
rewrite H.
rewrite (IH _ _ H).

*****
H : eq (arities e) (ok_arities n O)
e : BC
n : nat
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
eq match arities plus_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S O)) (Nat.eqb hs (S O))) (andb (aeq (ok_arities n O) (ok_arities n O)) true)) (andb (aeq (ok_arities n O) (ok_arities n O)) true) then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) end (ok_arities n O)
+++++
simpl.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.
intros n e H.
rewrite H.
rewrite (IH _ _ H).
simpl.

*****
H : eq (arities e) (ok_arities n O)
e : BC
n : nat
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
eq match arities plus_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S O)) (Nat.eqb hs (S O))) (andb (andb (Nat.eqb n n) true) true)) (andb (andb (Nat.eqb n n) true) true) then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) end (ok_arities n O)
+++++
rewrite <- beq_nat_refl.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].
simpl.
intros n e H.
rewrite H.
rewrite (IH _ _ H).
simpl.
rewrite <- beq_nat_refl.

*****
H : eq (arities e) (ok_arities n O)
e : BC
n : nat
IH : forall (n : nat) (e : BC) (_ : eq (arities e) (ok_arities n O)),\neq (arities (scalar_e a n e)) (ok_arities n O)
a : nat
*****
eq match arities plus_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S O)) (Nat.eqb hs (S O))) (andb (andb true true) true)) (andb (andb true true) true) then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) nil) (cons (ok_arities n O) nil) end (ok_arities n O)
+++++
trivial.
-----
Lemma scalar_arities : forall a n e, arities e = ok_arities n 0 -> arities (scalar_e a n e) = ok_arities n 0.
Proof.
induction a as [ | a IH].

*****

*****

+++++
Qed.
-----
Opaque plus_e.
-----
Lemma scalar_correct :\n  forall a n nl e,\n  length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).

*****

*****
forall (a n : nat) (nl : list (list bool)) (e : BC), eq (length (sem (scalar_e a n e) nl nil)) (Init.Nat.mul a (length (sem e nl nil)))
+++++
Proof.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.

*****

*****
forall (a n : nat) (nl : list (list bool)) (e : BC), eq (length (sem (scalar_e a n e) nl nil)) (Init.Nat.mul a (length (sem e nl nil)))
+++++
induction a as [ | a IH].
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].

*****

*****
forall (n : nat) (nl : list (list bool)) (e : BC), eq (length (sem (scalar_e O n e) nl nil)) (Init.Nat.mul O (length (sem e nl nil)))
+++++
simpl.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].
simpl.

*****

*****
forall (_ : nat) (_ : list (list bool)) (_ : BC), eq O O
+++++
trivial.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].

*****
IH : forall (n : nat) (nl : list (list bool)) (e : BC),\neq (length (sem (scalar_e a n e) nl nil))\n (Init.Nat.mul a (length (sem e nl nil)))
a : nat
*****
forall (n : nat) (nl : list (list bool)) (e : BC), eq (length (sem (scalar_e (S a) n e) nl nil)) (Init.Nat.mul (S a) (length (sem e nl nil)))
+++++
simpl.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].
simpl.

*****
IH : forall (n : nat) (nl : list (list bool)) (e : BC),\neq (length (sem (scalar_e a n e) nl nil))\n (Init.Nat.mul a (length (sem e nl nil)))
a : nat
*****
forall (n : nat) (nl : list (list bool)) (e : BC), eq (length (sem plus_e (cons (sem e nl nil) nil) (cons (sem (scalar_e a n e) nl nil) nil))) (Init.Nat.add (length (sem e nl nil)) (Init.Nat.mul a (length (sem e nl nil))))
+++++
intros n nl e.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].
simpl.
intros n nl e.

*****
e : BC
nl : list (list bool)
n : nat
IH : forall (n : nat) (nl : list (list bool)) (e : BC),\neq (length (sem (scalar_e a n e) nl nil))\n (Init.Nat.mul a (length (sem e nl nil)))
a : nat
*****
eq (length (sem plus_e (cons (sem e nl nil) nil) (cons (sem (scalar_e a n e) nl nil) nil))) (Init.Nat.add (length (sem e nl nil)) (Init.Nat.mul a (length (sem e nl nil))))
+++++
rewrite plus_correct.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].
simpl.
intros n nl e.
rewrite plus_correct.

*****
e : BC
nl : list (list bool)
n : nat
IH : forall (n : nat) (nl : list (list bool)) (e : BC),\neq (length (sem (scalar_e a n e) nl nil))\n (Init.Nat.mul a (length (sem e nl nil)))
a : nat
*****
eq (Init.Nat.add (length (sem e nl nil)) (length (sem (scalar_e a n e) nl nil))) (Init.Nat.add (length (sem e nl nil)) (Init.Nat.mul a (length (sem e nl nil))))
+++++
rewrite IH.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].
simpl.
intros n nl e.
rewrite plus_correct.
rewrite IH.

*****
e : BC
nl : list (list bool)
n : nat
IH : forall (n : nat) (nl : list (list bool)) (e : BC),\neq (length (sem (scalar_e a n e) nl nil))\n (Init.Nat.mul a (length (sem e nl nil)))
a : nat
*****
eq (Init.Nat.add (length (sem e nl nil)) (Init.Nat.mul a (length (sem e nl nil)))) (Init.Nat.add (length (sem e nl nil)) (Init.Nat.mul a (length (sem e nl nil))))
+++++
trivial.
-----
Lemma scalar_correct : forall a n nl e, length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).
Proof.
induction a as [ | a IH].

*****

*****

+++++
Qed.
-----
Fixpoint multl_e (n:nat)(el:list BC) : BC :=\n  match el with\n    | nil => one_e n 0\n    | e' :: el' => comp n 0 mult_e [e'; multl_e n el'] nil\n  end.
-----
Lemma multl_arities :\n  forall el n,\n  andl (fun e => arities e = ok_arities n 0) el ->\n  arities (multl_e n el) = ok_arities n 0.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.

*****

*****
forall (el : list BC) (n : nat) (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el), eq (arities (multl_e n el)) (ok_arities n O)
+++++
Proof.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.

*****

*****
forall (el : list BC) (n : nat) (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el), eq (arities (multl_e n el)) (ok_arities n O)
+++++
induction el as [ | e el IH].
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].

*****

*****
forall (n : nat) (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) nil), eq (arities (multl_e n nil)) (ok_arities n O)
+++++
simpl.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.

*****

*****
forall (n : nat) (_ : True), eq (ok_arities n O) (ok_arities n O)
+++++
trivial.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].

*****
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
forall (n : nat) (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) (cons e el)), eq (arities (multl_e n (cons e el))) (ok_arities n O)
+++++
simpl.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.

*****
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
forall (n : nat) (_ : and (eq (arities e) (ok_arities n O)) (andl (fun e : BC => eq (arities e) (ok_arities n O)) el)), eq match arities mult_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil | error_comp a l l0 => error_comp (error_comp a l l0) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (S O))) (Nat.eqb hs O)) (andb (aeq (arities e) (ok_arities n O)) (andb (aeq (arities (multl_e n el)) (ok_arities n O)) true))) true then ok_arities n O else error_comp (ok_arities hn hs) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil end (ok_arities n O)
+++++
intros n [H1 H2].
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.
intros n [H1 H2].

*****
H2 : andl (fun e : BC => eq (arities e) (ok_arities n O)) el
H1 : eq (arities e) (ok_arities n O)
n : nat
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
eq match arities mult_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil | error_comp a l l0 => error_comp (error_comp a l l0) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (S O))) (Nat.eqb hs O)) (andb (aeq (arities e) (ok_arities n O)) (andb (aeq (arities (multl_e n el)) (ok_arities n O)) true))) true then ok_arities n O else error_comp (ok_arities hn hs) (cons (arities e) (cons (arities (multl_e n el)) nil)) nil end (ok_arities n O)
+++++
rewrite H1.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.
intros n [H1 H2].
rewrite H1.

*****
H2 : andl (fun e : BC => eq (arities e) (ok_arities n O)) el
H1 : eq (arities e) (ok_arities n O)
n : nat
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
eq match arities mult_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (cons (arities (multl_e n el)) nil)) nil | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (cons (arities (multl_e n el)) nil)) nil | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (cons (arities (multl_e n el)) nil)) nil | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (S O))) (Nat.eqb hs O)) (andb (aeq (ok_arities n O) (ok_arities n O)) (andb (aeq (arities (multl_e n el)) (ok_arities n O)) true))) true then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) (cons (arities (multl_e n el)) nil)) nil end (ok_arities n O)
+++++
rewrite (IH _ H2).
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.
intros n [H1 H2].
rewrite H1.
rewrite (IH _ H2).

*****
H2 : andl (fun e : BC => eq (arities e) (ok_arities n O)) el
H1 : eq (arities e) (ok_arities n O)
n : nat
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
eq match arities mult_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (S O))) (Nat.eqb hs O)) (andb (aeq (ok_arities n O) (ok_arities n O)) (andb (aeq (ok_arities n O) (ok_arities n O)) true))) true then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil end (ok_arities n O)
+++++
simpl.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.
intros n [H1 H2].
rewrite H1.
rewrite (IH _ H2).
simpl.

*****
H2 : andl (fun e : BC => eq (arities e) (ok_arities n O)) el
H1 : eq (arities e) (ok_arities n O)
n : nat
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
eq match arities mult_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (S O))) (Nat.eqb hs O)) (andb (andb (Nat.eqb n n) true) (andb (andb (Nat.eqb n n) true) true))) true then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil end (ok_arities n O)
+++++
rewrite <- beq_nat_refl.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].
simpl.
intros n [H1 H2].
rewrite H1.
rewrite (IH _ H2).
simpl.
rewrite <- beq_nat_refl.

*****
H2 : andl (fun e : BC => eq (arities e) (ok_arities n O)) el
H1 : eq (arities e) (ok_arities n O)
n : nat
IH : forall (n : nat)\n (_ : andl (fun e : BC => eq (arities e) (ok_arities n O)) el),\neq (arities (multl_e n el)) (ok_arities n O)
el : list BC
e : BC
*****
eq match arities mult_e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | error_comp a l l0 => error_comp (error_comp a l l0) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (S (S O))) (Nat.eqb hs O)) (andb (andb true true) (andb (andb true true) true))) true then ok_arities n O else error_comp (ok_arities hn hs) (cons (ok_arities n O) (cons (ok_arities n O) nil)) nil end (ok_arities n O)
+++++
trivial.
-----
Lemma multl_arities : forall el n, andl (fun e => arities e = ok_arities n 0) el -> arities (multl_e n el) = ok_arities n 0.
Proof.
induction el as [ | e el IH].

*****

*****

+++++
Qed.
-----
Opaque mult_e.
-----
Lemma multl_correct :\n  forall n nl el,\n  length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).

*****

*****
forall (n : nat) (nl : list (list bool)) (el : list BC), eq (length (sem (multl_e n el) nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) el))
+++++
Proof.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.

*****

*****
forall (n : nat) (nl : list (list bool)) (el : list BC), eq (length (sem (multl_e n el) nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) el))
+++++
induction el as [ | e el IH].
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].

*****
nl : list (list bool)
n : nat
*****
eq (length (sem (multl_e n nil) nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) nil))
+++++
simpl.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.

*****
nl : list (list bool)
n : nat
*****
eq (S O) (S O)
+++++
trivial.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].

*****
IH : eq (length (sem (multl_e n el) nl nil))\n (multl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (length (sem (multl_e n (cons e el)) nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) (cons e el)))
+++++
simpl.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.

*****
IH : eq (length (sem (multl_e n el) nl nil))\n (multl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (length (sem mult_e (cons (sem e nl nil) (cons (sem (multl_e n el) nl nil) nil)) nil)) (Init.Nat.mul (length (sem e nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) el)))
+++++
rewrite mult_correct.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.
rewrite mult_correct.

*****
IH : eq (length (sem (multl_e n el) nl nil))\n (multl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (Init.Nat.mul (length (sem e nl nil)) (length (sem (multl_e n el) nl nil))) (Init.Nat.mul (length (sem e nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) el)))
+++++
rewrite IH.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].
simpl.
rewrite mult_correct.
rewrite IH.

*****
IH : eq (length (sem (multl_e n el) nl nil))\n (multl (map (fun e : BC => length (sem e nl nil)) el))
el : list BC
e : BC
nl : list (list bool)
n : nat
*****
eq (Init.Nat.mul (length (sem e nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) el))) (Init.Nat.mul (length (sem e nl nil)) (multl (map (fun e : BC => length (sem e nl nil)) el)))
+++++
trivial.
-----
Lemma multl_correct : forall n nl el, length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el).
Proof.
induction el as [ | e el IH].

*****

*****

+++++
Qed.
-----
