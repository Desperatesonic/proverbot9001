From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Require Import Mapaxioms.
-----
Require Import Fset.
-----
From Coq Require Import List.
-----
Section MapIter.
-----
Variable A : Type.
-----
Section MapSweepDef.
-----
Variable f : ad -> A -> bool.
-----
Definition MapSweep2 (a0:ad) (y:A) :=\n    if f a0 y then Some (a0, y) else None.
-----
Fixpoint MapSweep1 (pf:ad -> ad) (m:Map A) {struct m} : \n   option (ad * A) :=\n    match m with\n    | M0 => None\n    | M1 a y => MapSweep2 (pf a) y\n    | M2 m m' =>\n        match MapSweep1 (fun a:ad => pf (Ndouble a)) m with\n        | Some r => Some r\n        | None => MapSweep1 (fun a:ad => pf (Ndouble_plus_one a)) m'\n        end\n    end.
-----
Definition MapSweep (m:Map A) := MapSweep1 (fun a:ad => a) m.
-----
Lemma MapSweep_semantics_1_1 :\n   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),\n     MapSweep1 pf m = Some (a, y) -> f a y = true.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (f a y) true
+++++
Proof.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (f a y) true
+++++
simple induction m.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf (M0 A)) (Some (pair a y))), eq (f a y) true
+++++
intros.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
intros.

*****
H : eq (MapSweep1 pf (M0 A)) (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
discriminate H.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (MapSweep1 pf (M1 A a a0)) (Some (pair a1 y))), eq (f a1 y) true
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (MapSweep2 (pf a) a0) (Some (pair a1 y))), eq (f a1 y) true
+++++
intros a y pf a0 y0.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep2 (pf a) y) (Some (pair a0 y0)), eq (f a0 y0) true
+++++
elim (sumbool_of_bool (f (pf a) y)).
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (f (pf a) y) true) (_ : eq (MapSweep2 (pf a) y) (Some (pair a0 y0))), eq (f a0 y0) true
+++++
intro H.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.

*****
H : eq (f (pf a) y) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep2 (pf a) y) (Some (pair a0 y0)), eq (f a0 y0) true
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.

*****
H : eq (f (pf a) y) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0)), eq (f a0 y0) true
+++++
rewrite H.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.
rewrite H.

*****
H : eq (f (pf a) y) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (Some (pair (pf a) y)) (Some (pair a0 y0)), eq (f a0 y0) true
+++++
intro H0.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.
rewrite H.
intro H0.

*****
H0 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H : eq (f (pf a) y) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a0 y0) true
+++++
inversion H0.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.
rewrite H.
intro H0.
inversion H0.

*****
H3 : eq y y0
H2 : eq (pf a) a0
H0 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H : eq (f (pf a) y) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y0) true
+++++
rewrite <- H3.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.
rewrite H.
intro H0.
inversion H0.
rewrite <- H3.

*****
H3 : eq y y0
H2 : eq (pf a) a0
H0 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H : eq (f (pf a) y) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) true
+++++
assumption.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (f (pf a) y) false) (_ : eq (MapSweep2 (pf a) y) (Some (pair a0 y0))), eq (f a0 y0) true
+++++
intro H.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.

*****
H : eq (f (pf a) y) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep2 (pf a) y) (Some (pair a0 y0)), eq (f a0 y0) true
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.

*****
H : eq (f (pf a) y) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0)), eq (f a0 y0) true
+++++
rewrite H.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.
rewrite H.

*****
H : eq (f (pf a) y) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq None (Some (pair a0 y0)), eq (f a0 y0) true
+++++
intro H0.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
unfold MapSweep2 in |- *.
rewrite H.
intro H0.

*****
H0 : eq None (Some (pair a0 y0))
H : eq (f (pf a) y) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a0 y0) true
+++++
discriminate H0.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (f a y) true) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf (M2 A m m0)) (Some (pair a y))), eq (f a y) true
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (f a y) true) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq match MapSweep1 (fun a0 : ad => pf (N.double a0)) m with | Some r => Some r | None => MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m0 end (Some (pair a y))), eq (f a y) true
+++++
intros.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y)), eq (f a y) true
+++++
intro H2.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.

*****
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
elim H2.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.
elim H2.

*****
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some x)), eq (f a y) true
+++++
intros r H3.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.
elim H2.
intros r H3.

*****
H3 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
rewrite H3 in H1.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.
elim H2.
intros r H3.
rewrite H3 in H1.

*****
H3 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H1 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
inversion H1.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.
elim H2.
intros r H3.
rewrite H3 in H1.
inversion H1.

*****
H5 : eq r (pair a y)
H3 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H1 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
rewrite H5 in H3.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.
elim H2.
intros r H3.
rewrite H3 in H1.
inversion H1.
rewrite H5 in H3.

*****
H5 : eq r (pair a y)
H3 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H1 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
exact (H (fun a0:ad => pf (Ndouble a0)) a y H3).
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None, eq (f a y) true
+++++
intro H2.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.

*****
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
rewrite H2 in H1.
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H2.
rewrite H2 in H1.

*****
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))), eq (f a y) true
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (f a y) true
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
exact (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H1).
-----
Lemma MapSweep_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> f a y = true.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_1 :\n   forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.
-----
Lemma MapSweep_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapSweep m) (Some (pair a y))), eq (f a y) true
+++++
Proof.
-----
Lemma MapSweep_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapSweep m) (Some (pair a y))), eq (f a y) true
+++++
intros.
-----
Lemma MapSweep_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.
Proof.
intros.

*****
H : eq (MapSweep m) (Some (pair a y))
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) true
+++++
exact (MapSweep_semantics_1_1 m (fun a:ad => a) a y H).
-----
Lemma MapSweep_semantics_1 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.
Proof.
intros.
exact (MapSweep_semantics_1_1 m (fun a:ad => a) a y H).

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_2_1 :\n   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),\n     MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
Proof.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
simple induction m.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf (M0 A)) (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
intros.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.

*****
H : eq (MapSweep1 pf (M0 A)) (Some (pair a y))
y : A
a : ad
pf : forall _ : ad, ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
discriminate H.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (MapSweep1 pf (M1 A a a0)) (Some (pair a1 y))), sig (fun a' : ad => eq a1 (pf a'))
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (MapSweep2 (pf a) a0) (Some (pair a1 y))), sig (fun a' : ad => eq a1 (pf a'))
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (if f (pf a) a0 then Some (pair (pf a) a0) else None) (Some (pair a1 y))), sig (fun a' : ad => eq a1 (pf a'))
+++++
intros a y pf a0 y0.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0)), sig (fun a' : ad => eq a0 (pf a'))
+++++
case (f (pf a) y).
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.
case (f (pf a) y).

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (Some (pair (pf a) y)) (Some (pair a0 y0)), sig (fun a' : ad => eq a0 (pf a'))
+++++
intros.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.
case (f (pf a) y).
intros.

*****
H : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a0 (pf a'))
+++++
split with a.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.
case (f (pf a) y).
intros.
split with a.

*****
H : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq a0 (pf a)
+++++
inversion H.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.
case (f (pf a) y).
intros.
split with a.
inversion H.

*****
H2 : eq y y0
H1 : eq (pf a) a0
H : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (pf a) (pf a)
+++++
reflexivity.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.
case (f (pf a) y).

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq None (Some (pair a0 y0)), sig (fun a' : ad => eq a0 (pf a'))
+++++
intro.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf a0 y0.
case (f (pf a) y).
intro.

*****
H : eq None (Some (pair a0 y0))
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a0 (pf a'))
+++++
discriminate H.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapSweep1 pf (M2 A m m0)) (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
intros m0 H m1 H0 pf a y.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.

*****
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.

*****
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : sig (fun y : prod ad A => eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))) (_ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
intro H1.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.

*****
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
elim H1.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.

*****
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some x)) (_ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
intros r H2.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.

*****
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
rewrite H2.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.

*****
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (Some r) (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
intro H3.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.
intro H3.

*****
H3 : eq (Some r) (Some (pair a y))
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
inversion H3.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.
intro H3.
inversion H3.

*****
H5 : eq r (pair a y)
H3 : eq (Some r) (Some (pair a y))
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
rewrite H5 in H2.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.
intro H3.
inversion H3.
rewrite H5 in H2.

*****
H5 : eq r (pair a y)
H3 : eq (Some r) (Some (pair a y))
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
elim (H (fun a0:ad => pf (Ndouble a0)) a y H2).
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.
intro H3.
inversion H3.
rewrite H5 in H2.
elim (H (fun a0:ad => pf (Ndouble a0)) a y H2).

*****
H5 : eq r (pair a y)
H3 : eq (Some r) (Some (pair a y))
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : ad) (_ : eq a (pf (N.double x))), sig (fun a' : ad => eq a (pf a'))
+++++
intros a0 H6.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.
intro H3.
inversion H3.
rewrite H5 in H2.
elim (H (fun a0:ad => pf (Ndouble a0)) a y H2).
intros a0 H6.

*****
H6 : eq a (pf (N.double a0))
a0 : ad
H5 : eq r (pair a y)
H3 : eq (Some r) (Some (pair a y))
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
split with (Ndouble a0).
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
elim H1.
intros r H2.
rewrite H2.
intro H3.
inversion H3.
rewrite H5 in H2.
elim (H (fun a0:ad => pf (Ndouble a0)) a y H2).
intros a0 H6.
split with (Ndouble a0).

*****
H6 : eq a (pf (N.double a0))
a0 : ad
H5 : eq r (pair a y)
H3 : eq (Some r) (Some (pair a y))
H2 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
r : prod ad A
H1 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq a (pf (N.double a0))
+++++
assumption.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None) (_ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y))), sig (fun a' : ad => eq a (pf a'))
+++++
intro H1.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.

*****
H1 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
rewrite H1.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
rewrite H1.

*****
H1 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) (Some (pair a y)), sig (fun a' : ad => eq a (pf a'))
+++++
intro H2.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
rewrite H1.
intro H2.

*****
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
H1 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
elim (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
rewrite H1.
intro H2.
elim (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).

*****
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
H1 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : ad) (_ : eq a (pf (N.succ_double x))), sig (fun a' : ad => eq a (pf a'))
+++++
intros a0 H3.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
rewrite H1.
intro H2.
elim (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
intros a0 H3.

*****
H3 : eq a (pf (N.succ_double a0))
a0 : ad
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
H1 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
split with (Ndouble_plus_one a0).
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros m0 H m1 H0 pf a y.
simpl in |- *.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H1.
rewrite H1.
intro H2.
elim (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
intros a0 H3.
split with (Ndouble_plus_one a0).

*****
H3 : eq a (pf (N.succ_double a0))
a0 : ad
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
H1 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
y : A
a : ad
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\nsig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq a (pf (N.succ_double a0))
+++++
assumption.
-----
Lemma MapSweep_semantics_2_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_2_2 :\n   forall (m:Map A) (pf fp:ad -> ad),\n     (forall a0:ad, fp (pf a0) = a0) ->\n     forall (a:ad) (y:A),\n       MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf fp : forall _ : ad, ad) (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (MapGet A m (fp a)) (Some y)
+++++
Proof.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf fp : forall _ : ad, ad) (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (MapGet A m (fp a)) (Some y)
+++++
simple induction m.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (pf fp : forall _ : ad, ad) (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) (y : A) (_ : eq (MapSweep1 pf (M0 A)) (Some (pair a y))), eq (MapGet A (M0 A) (fp a)) (Some y)
+++++
intros.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.

*****
H0 : eq (MapSweep1 pf (M0 A)) (Some (pair a y))
y : A
a : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A (M0 A) (fp a)) (Some y)
+++++
discriminate H0.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf fp : forall _ : ad, ad) (_ : forall a1 : ad, eq (fp (pf a1)) a1) (a1 : ad) (y : A) (_ : eq (MapSweep1 pf (M1 A a a0)) (Some (pair a1 y))), eq (MapGet A (M1 A a a0) (fp a1)) (Some y)
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf fp : forall _ : ad, ad) (_ : forall a1 : ad, eq (fp (pf a1)) a1) (a1 : ad) (y : A) (_ : eq (MapSweep2 (pf a) a0) (Some (pair a1 y))), eq (if N.eqb a (fp a1) then Some a0 else None) (Some y)
+++++
intros a y pf fp H a0 y0.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.

*****
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep2 (pf a) y) (Some (pair a0 y0)), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.

*****
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0)), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
elim (sumbool_of_bool (f (pf a) y)).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).

*****
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (f (pf a) y) true) (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0))), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
intro H0.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.

*****
H0 : eq (f (pf a) y) true
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0)), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
rewrite H0.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.

*****
H0 : eq (f (pf a) y) true
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (Some (pair (pf a) y)) (Some (pair a0 y0)), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
intro H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.
intro H1.

*****
H1 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H0 : eq (f (pf a) y) true
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
inversion H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.
intro H1.
inversion H1.

*****
H4 : eq y y0
H3 : eq (pf a) a0
H1 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H0 : eq (f (pf a) y) true
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.eqb a (fp (pf a)) then Some y0 else None) (Some y0)
+++++
rewrite (H a).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.
intro H1.
inversion H1.
rewrite (H a).

*****
H4 : eq y y0
H3 : eq (pf a) a0
H1 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H0 : eq (f (pf a) y) true
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.eqb a a then Some y0 else None) (Some y0)
+++++
rewrite (Neqb_correct a).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.
intro H1.
inversion H1.
rewrite (H a).
rewrite (Neqb_correct a).

*****
H4 : eq y y0
H3 : eq (pf a) a0
H1 : eq (Some (pair (pf a) y)) (Some (pair a0 y0))
H0 : eq (f (pf a) y) true
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (Some y0) (Some y0)
+++++
reflexivity.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).

*****
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (f (pf a) y) false) (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0))), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
intro H0.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.

*****
H0 : eq (f (pf a) y) false
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if f (pf a) y then Some (pair (pf a) y) else None) (Some (pair a0 y0)), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
rewrite H0.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.

*****
H0 : eq (f (pf a) y) false
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq None (Some (pair a0 y0)), eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
intro H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
simpl in |- *.
intros a y pf fp H a0 y0.
unfold MapSweep2 in |- *.
elim (sumbool_of_bool (f (pf a) y)).
intro H0.
rewrite H0.
intro H1.

*****
H1 : eq None (Some (pair a0 y0))
H0 : eq (f (pf a) y) false
y0 : A
a0 : ad
H : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.eqb a (fp a0) then Some y else None) (Some y0)
+++++
discriminate H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall (pf fp : forall _ : ad, ad) (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) (y : A) (_ : eq (MapSweep1 pf m) (Some (pair a y))), eq (MapGet A m (fp a)) (Some y)) (m0 : Map A) (_ : forall (pf fp : forall _ : ad, ad) (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))), eq (MapGet A m0 (fp a)) (Some y)) (pf fp : forall _ : ad, ad) (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) (y : A) (_ : eq (MapSweep1 pf (M2 A m m0)) (Some (pair a y))), eq (MapGet A (M2 A m m0) (fp a)) (Some y)
+++++
intros.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.

*****
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A (M2 A m0 m1) (fp a)) (Some y)
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).

*****
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.odd (fp a) then MapGet A m1 (N.div2 (fp a)) else MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
elim (sumbool_of_bool (Nbit0 (fp a))).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).

*****
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.odd (fp a)) true, eq (if N.odd (fp a) then MapGet A m1 (N.div2 (fp a)) else MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
intro H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.

*****
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.odd (fp a) then MapGet A m1 (N.div2 (fp a)) else MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.

*****
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y)), eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
intro H4.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
simpl in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall a0 : ad, eq (N.div2 (fp (pf (N.succ_double a0)))) a0
+++++
intro.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
intro.

*****
a0 : ad
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (N.div2 (fp (pf (N.succ_double a0)))) a0
+++++
rewrite H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
intro.
rewrite H1.

*****
a0 : ad
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (N.div2 (N.succ_double a0)) a0
+++++
apply Ndouble_plus_one_div2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y)), eq (MapSweep1 (fun a1 : ad => pf (N.succ_double a1)) m1) (Some (pair a y))
+++++
intro H5.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.

*****
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
elim H5.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.

*****
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some x)), eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
intros r H6.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.

*****
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
rewrite H6 in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.

*****
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
inversion H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.

*****
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
rewrite H8 in H6.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.
rewrite H8 in H6.

*****
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.
rewrite H8 in H6.
elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6).

*****
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : ad) (_ : eq a (pf (N.double x))), eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
intros a0 H9.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.
rewrite H8 in H6.
elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6).
intros a0 H9.

*****
H9 : eq a (pf (N.double a0))
a0 : ad
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
rewrite H9 in H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.
rewrite H8 in H6.
elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6).
intros a0 H9.
rewrite H9 in H3.

*****
H9 : eq a (pf (N.double a0))
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp (pf (N.double a0)))) true
a0 : ad
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
rewrite (H1 (Ndouble a0)) in H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.
rewrite H8 in H6.
elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6).
intros a0 H9.
rewrite H9 in H3.
rewrite (H1 (Ndouble a0)) in H3.

*****
H9 : eq a (pf (N.double a0))
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (N.double a0)) true
a0 : ad
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
rewrite (Ndouble_bit0 a0) in H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
elim H5.
intros r H6.
rewrite H6 in H2.
inversion H2.
rewrite H8 in H6.
elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6).
intros a0 H9.
rewrite H9 in H3.
rewrite (H1 (Ndouble a0)) in H3.
rewrite (Ndouble_bit0 a0) in H3.

*****
H9 : eq a (pf (N.double a0))
H8 : eq r (pair a y)
H6 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4,H5 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq false true
a0 : ad
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
discriminate H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None, eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
intro H5.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
rewrite H5 in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H5.
rewrite H5 in H2.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
assumption.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None, eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
intro H4.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
simpl in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
rewrite H4 in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
rewrite H4 in H2.

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m1 (N.div2 (fp a))) (Some y)
+++++
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
rewrite H4 in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall a0 : ad, eq (N.div2 (fp (pf (N.succ_double a0)))) a0
+++++
intro.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
rewrite H4 in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
intro.

*****
a0 : ad
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (N.div2 (fp (pf (N.succ_double a0)))) a0
+++++
rewrite H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
rewrite H4 in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).
intro.
rewrite H1.

*****
a0 : ad
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (N.div2 (N.succ_double a0)) a0
+++++
apply Ndouble_plus_one_div2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
simpl in H2.
rewrite H4 in H2.
apply (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => Ndiv2 (fp a0))).

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) true
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a y))
+++++
assumption.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).

*****
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.odd (fp a)) false, eq (if N.odd (fp a) then MapGet A m1 (N.div2 (fp a)) else MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
intro H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.

*****
H3 : eq (N.odd (fp a)) false
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if N.odd (fp a) then MapGet A m1 (N.div2 (fp a)) else MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.

*****
H3 : eq (N.odd (fp a)) false
H2 : eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
simpl in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.

*****
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y)), eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
intro H4.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
elim H4.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.

*****
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some x)), eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
intros r H5.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
r : prod ad A
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite H5 in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
inversion H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.
inversion H2.

*****
H7 : eq r (pair a y)
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some r)
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite H7 in H5.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.
inversion H2.
rewrite H7 in H5.

*****
H7 : eq r (pair a y)
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
apply (H (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => Ndiv2 (fp a0))).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.
inversion H2.
rewrite H7 in H5.
apply (H (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => Ndiv2 (fp a0))).

*****
H7 : eq r (pair a y)
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall a0 : ad, eq (N.div2 (fp (pf (N.double a0)))) a0
+++++
intro.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.
inversion H2.
rewrite H7 in H5.
apply (H (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => Ndiv2 (fp a0))).
intro.

*****
a0 : ad
H7 : eq r (pair a y)
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (N.div2 (fp (pf (N.double a0)))) a0
+++++
rewrite H1.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.
inversion H2.
rewrite H7 in H5.
apply (H (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => Ndiv2 (fp a0))).
intro.
rewrite H1.

*****
a0 : ad
H7 : eq r (pair a y)
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (N.div2 (N.double a0)) a0
+++++
apply Ndouble_div2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
elim H4.
intros r H5.
rewrite H5 in H2.
inversion H2.
rewrite H7 in H5.
apply (H (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => Ndiv2 (fp a0))).

*****
H7 : eq r (pair a y)
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
H4 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some y))
H3 : eq (N.odd (fp a)) false
H2 : eq (Some r) (Some (pair a y))
r : prod ad A
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a y))
+++++
assumption.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).

*****
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None, eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
intro H4.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) false
H2 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite H4 in H2.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
rewrite H4 in H2.

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) false
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
elim (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
rewrite H4 in H2.
elim (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).

*****
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) false
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : ad) (_ : eq a (pf (N.succ_double x))), eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
intros a0 H5.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
rewrite H4 in H2.
elim (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
intros a0 H5.

*****
H5 : eq a (pf (N.succ_double a0))
a0 : ad
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp a)) false
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite H5 in H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
rewrite H4 in H2.
elim (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
intros a0 H5.
rewrite H5 in H3.

*****
H5 : eq a (pf (N.succ_double a0))
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (fp (pf (N.succ_double a0)))) false
a0 : ad
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite (H1 (Ndouble_plus_one a0)) in H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
rewrite H4 in H2.
elim (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
intros a0 H5.
rewrite H5 in H3.
rewrite (H1 (Ndouble_plus_one a0)) in H3.

*****
H5 : eq a (pf (N.succ_double a0))
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq (N.odd (N.succ_double a0)) false
a0 : ad
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
rewrite (Ndouble_plus_one_bit0 a0) in H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)).
elim (sumbool_of_bool (Nbit0 (fp a))).
intro H3.
rewrite H3.
simpl in H2.
elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
intro H4.
rewrite H4 in H2.
elim (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
intros a0 H5.
rewrite H5 in H3.
rewrite (H1 (Ndouble_plus_one a0)) in H3.
rewrite (Ndouble_plus_one_bit0 a0) in H3.

*****
H5 : eq a (pf (N.succ_double a0))
H4 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) None
H3 : eq true false
a0 : ad
H2 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1)\n (Some (pair a y))
y : A
a : ad
H1 : forall a0 : ad, eq (fp (pf a0)) a0
pf,fp : forall _ : ad, ad
H0 : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m1) (Some (pair a y))),\neq (MapGet A m1 (fp a)) (Some y)
m1 : Map A
H : forall (pf fp : forall _ : ad, ad)\n (_ : forall a0 : ad, eq (fp (pf a0)) a0) (a : ad) \n (y : A) (_ : eq (MapSweep1 pf m0) (Some (pair a y))),\neq (MapGet A m0 (fp a)) (Some y)
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m0 (N.div2 (fp a))) (Some y)
+++++
discriminate H3.
-----
Lemma MapSweep_semantics_2_2 : forall (m:Map A) (pf fp:ad -> ad), (forall a0:ad, fp (pf a0) = a0) -> forall (a:ad) (y:A), MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_2 :\n   forall (m:Map A) (a:ad) (y:A),\n     MapSweep m = Some (a, y) -> MapGet A m a = Some y.
-----
Lemma MapSweep_semantics_2 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> MapGet A m a = Some y.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapSweep m) (Some (pair a y))), eq (MapGet A m a) (Some y)
+++++
Proof.
-----
Lemma MapSweep_semantics_2 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> MapGet A m a = Some y.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapSweep m) (Some (pair a y))), eq (MapGet A m a) (Some y)
+++++
intros.
-----
Lemma MapSweep_semantics_2 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> MapGet A m a = Some y.
Proof.
intros.

*****
H : eq (MapSweep m) (Some (pair a y))
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapGet A m a) (Some y)
+++++
exact (MapSweep_semantics_2_2 m (fun a0:ad => a0) (fun a0:ad => a0) (fun a0:ad => refl_equal a0) a y H).
-----
Lemma MapSweep_semantics_2 : forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> MapGet A m a = Some y.
Proof.
intros.
exact (MapSweep_semantics_2_2 m (fun a0:ad => a0) (fun a0:ad => a0) (fun a0:ad => refl_equal a0) a y H).

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_3_1 :\n   forall (m:Map A) (pf:ad -> ad),\n     MapSweep1 pf m = None ->\n     forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m) None) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f (pf a) y) false
+++++
Proof.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m) None) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f (pf a) y) false
+++++
simple induction m.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf (M0 A)) None) (a : ad) (y : A) (_ : eq (MapGet A (M0 A) a) (Some y)), eq (f (pf a) y) false
+++++
intros.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.

*****
H0 : eq (MapGet A (M0 A) a) (Some y)
y : A
a : ad
H : eq (MapSweep1 pf (M0 A)) None
pf : forall _ : ad, ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
discriminate H0.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf (M1 A a a0)) None) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), eq (f (pf a1) y) false
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : eq (MapSweep2 (pf a) a0) None) (a1 : ad) (y : A) (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)), eq (f (pf a1) y) false
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : eq (if f (pf a) a0 then Some (pair (pf a) a0) else None) None) (a1 : ad) (y : A) (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)), eq (f (pf a1) y) false
+++++
intros a y pf.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) None) (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
elim (sumbool_of_bool (f (pf a) y)).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (f (pf a) y) true) (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) None) (a1 : ad) (y0 : A) (_ : eq (if N.eqb a a1 then Some y else None) (Some y0)), eq (f (pf a1) y0) false
+++++
intro H.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.

*****
H : eq (f (pf a) y) true
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) None) (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
rewrite H.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.

*****
H : eq (f (pf a) y) true
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (Some (pair (pf a) y)) None) (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
intro.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intro.

*****
H0 : eq (Some (pair (pf a) y)) None
H : eq (f (pf a) y) true
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
discriminate H0.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (f (pf a) y) false) (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) None) (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
intro H.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.

*****
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (if f (pf a) y then Some (pair (pf a) y) else None) None) (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
rewrite H.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.

*****
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq None None) (a0 : ad) (y0 : A) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
intros H0 a0 y0.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.

*****
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if N.eqb a a0 then Some y else None) (Some y0), eq (f (pf a0) y0) false
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).

*****
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (N.eqb a a0) true) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
intro H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) true
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if N.eqb a a0 then Some y else None) (Some y0), eq (f (pf a0) y0) false
+++++
rewrite H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a a0) true
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (Some y) (Some y0), eq (f (pf a0) y0) false
+++++
intro H2.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.
intro H2.

*****
H2 : eq (Some y) (Some y0)
H1 : eq (N.eqb a a0) true
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a0) y0) false
+++++
inversion H2.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.
intro H2.
inversion H2.

*****
H4 : eq y y0
H2 : eq (Some y) (Some y0)
H1 : eq (N.eqb a a0) true
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a0) y0) false
+++++
rewrite <- H4.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.
intro H2.
inversion H2.
rewrite <- H4.

*****
H4 : eq y y0
H2 : eq (Some y) (Some y0)
H1 : eq (N.eqb a a0) true
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a0) y) false
+++++
rewrite <- (Neqb_complete _ _ H1).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.
intro H2.
inversion H2.
rewrite <- H4.
rewrite <- (Neqb_complete _ _ H1).

*****
H4 : eq y y0
H2 : eq (Some y) (Some y0)
H1 : eq (N.eqb a a0) true
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
assumption.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).

*****
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (_ : eq (N.eqb a a0) false) (_ : eq (if N.eqb a a0 then Some y else None) (Some y0)), eq (f (pf a0) y0) false
+++++
intro H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) false
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (if N.eqb a a0 then Some y else None) (Some y0), eq (f (pf a0) y0) false
+++++
rewrite H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a a0) false
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq None (Some y0), eq (f (pf a0) y0) false
+++++
intro.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
simpl in |- *.
unfold MapSweep2 in |- *.
intros a y pf.
elim (sumbool_of_bool (f (pf a) y)).
intro H.
rewrite H.
intros H0 a0 y0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1.
intro.

*****
H2 : eq None (Some y0)
H1 : eq (N.eqb a a0) false
y0 : A
a0 : ad
H0 : eq None None
H : eq (f (pf a) y) false
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a0) y0) false
+++++
discriminate H2.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m) None) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f (pf a) y) false) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None) (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)), eq (f (pf a) y) false) (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf (M2 A m m0)) None) (a : ad) (y : A) (_ : eq (MapGet A (M2 A m m0) a) (Some y)), eq (f (pf a) y) false
+++++
intros.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 pf (M2 A m0 m1)) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
simpl in H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y)), eq (f (pf a) y) false
+++++
intro H3.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.

*****
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
elim H3.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
elim H3.

*****
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some x)), eq (f (pf a) y) false
+++++
intros r H4.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
elim H3.
intros r H4.

*****
H4 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some r)
r : prod ad A
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
rewrite H4 in H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
elim H3.
intros r H4.
rewrite H4 in H1.

*****
H4 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some r)
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (Some r) None
r : prod ad A
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
discriminate H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None, eq (f (pf a) y) false
+++++
intro H3.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.

*****
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq\n match MapSweep1 (fun a : ad => pf (N.double a)) m0 with\n | Some r => Some r\n | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1\n end None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
rewrite H3 in H1.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.

*****
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).

*****
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.odd a) true, eq (f (pf a) y) false
+++++
intro H4.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.

*****
H4 : eq (N.odd a) true
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
rewrite (MapGet_M2_bit_0_1 A a H4 m0 m1) in H2.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite (MapGet_M2_bit_0_1 A a H4 m0 m1) in H2.

*****
H4 : eq (N.odd a) true
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
rewrite <- (Ndiv2_double_plus_one a H4).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite (MapGet_M2_bit_0_1 A a H4 m0 m1) in H2.
rewrite <- (Ndiv2_double_plus_one a H4).

*****
H4 : eq (N.odd a) true
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf (N.succ_double (N.div2 a))) y) false
+++++
exact (H0 (fun a:ad => pf (Ndouble_plus_one a)) H1 (Ndiv2 a) y H2).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).

*****
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.odd a) false, eq (f (pf a) y) false
+++++
intro H4.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.

*****
H4 : eq (N.odd a) false
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
rewrite (MapGet_M2_bit_0_0 A a H4 m0 m1) in H2.
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite (MapGet_M2_bit_0_0 A a H4 m0 m1) in H2.

*****
H4 : eq (N.odd a) false
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) false
+++++
rewrite <- (Ndiv2_double a H4).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.
intros.
simpl in H1.
elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H3.
rewrite H3 in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite (MapGet_M2_bit_0_0 A a H4 m0 m1) in H2.
rewrite <- (Ndiv2_double a H4).

*****
H4 : eq (N.odd a) false
H3 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
H1 : eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) None
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m1) None)\n (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\neq (f (pf a) y) false
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : eq (MapSweep1 pf m0) None)\n (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\neq (f (pf a) y) false
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf (N.double (N.div2 a))) y) false
+++++
exact (H (fun a:ad => pf (Ndouble a)) H3 (Ndiv2 a) y H2).
-----
Lemma MapSweep_semantics_3_1 : forall (m:Map A) (pf:ad -> ad), MapSweep1 pf m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_3 :\n   forall m:Map A,\n     MapSweep m = None ->\n     forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.
-----
Lemma MapSweep_semantics_3 : forall m:Map A, MapSweep m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : eq (MapSweep m) None) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f a y) false
+++++
Proof.
-----
Lemma MapSweep_semantics_3 : forall m:Map A, MapSweep m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : eq (MapSweep m) None) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f a y) false
+++++
intros.
-----
Lemma MapSweep_semantics_3 : forall m:Map A, MapSweep m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.
Proof.
intros.

*****
H0 : eq (MapGet A m a) (Some y)
y : A
a : ad
H : eq (MapSweep m) None
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f a y) false
+++++
exact (MapSweep_semantics_3_1 m (fun a0:ad => a0) H a y H0).
-----
Lemma MapSweep_semantics_3 : forall m:Map A, MapSweep m = None -> forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.
Proof.
intros.
exact (MapSweep_semantics_3_1 m (fun a0:ad => a0) H a y H0).

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_4_1 :\n   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),\n     MapGet A m a = Some y ->\n     f (pf a) y = true ->\n     {a' : ad &  {y' : A | MapSweep1 pf m = Some (a', y')}}.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (f (pf a) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf m) (Some (pair a' y'))))
+++++
Proof.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (f (pf a) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf m) (Some (pair a' y'))))
+++++
simple induction m.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapGet A (M0 A) a) (Some y)) (_ : eq (f (pf a) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M0 A)) (Some (pair a' y'))))
+++++
intros.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.

*****
H0 : eq (f (pf a) y) true
H : eq (MapGet A (M0 A) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M0 A)) (Some (pair a' y'))))
+++++
discriminate H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)) (_ : eq (f (pf a1) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
intros.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.

*****
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.eqb a a1) true, sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
intro H1.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
split with (pf a1).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair (pf a1) y')))
+++++
split with y.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 pf (M1 A a a0)) (Some (pair (pf a1) y))
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 pf (M1 A a1 a0)) (Some (pair (pf a1) y))
+++++
unfold MapSweep1 in |- *.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).
unfold MapSweep1 in |- *.

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep2 (pf a1) a0) (Some (pair (pf a1) y))
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).
unfold MapSweep1 in |- *.
unfold MapSweep2 in |- *.

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if f (pf a1) a0 then Some (pair (pf a1) a0) else None) (Some (pair (pf a1) y))
+++++
rewrite (Neqb_complete _ _ H1) in H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).
unfold MapSweep1 in |- *.
unfold MapSweep2 in |- *.
rewrite (Neqb_complete _ _ H1) in H.

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a1 a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if f (pf a1) a0 then Some (pair (pf a1) a0) else None) (Some (pair (pf a1) y))
+++++
rewrite (M1_semantics_1 _ a1 a0) in H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).
unfold MapSweep1 in |- *.
unfold MapSweep2 in |- *.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (M1_semantics_1 _ a1 a0) in H.

*****
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (Some a0) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if f (pf a1) a0 then Some (pair (pf a1) a0) else None) (Some (pair (pf a1) y))
+++++
inversion H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).
unfold MapSweep1 in |- *.
unfold MapSweep2 in |- *.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (M1_semantics_1 _ a1 a0) in H.
inversion H.

*****
H3 : eq a0 y
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (Some a0) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (if f (pf a1) y then Some (pair (pf a1) y) else None) (Some (pair (pf a1) y))
+++++
rewrite H0.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
split with (pf a1).
split with y.
rewrite (Neqb_complete _ _ H1).
unfold MapSweep1 in |- *.
unfold MapSweep2 in |- *.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (M1_semantics_1 _ a1 a0) in H.
inversion H.
rewrite H0.

*****
H3 : eq a0 y
H1 : eq (N.eqb a a1) true
H0 : eq (f (pf a1) y) true
H : eq (Some a0) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (Some (pair (pf a1) y)) (Some (pair (pf a1) y))
+++++
reflexivity.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.eqb a a1) false, sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
intro H1.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.

*****
H1 : eq (N.eqb a a1) false
H0 : eq (f (pf a1) y) true
H : eq (MapGet A (M1 A a a0) a1) (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
rewrite (M1_semantics_2 _ a a1 a0 H1) in H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H1.
rewrite (M1_semantics_2 _ a a1 a0 H1) in H.

*****
H1 : eq (N.eqb a a1) false
H0 : eq (f (pf a1) y) true
H : eq None (Some y)
y : A
a1 : ad
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M1 A a a0)) (Some (pair a' y'))))
+++++
discriminate H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (f (pf a) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf m) (Some (pair a' y'))))) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (MapGet A (M2 A m m0) a) (Some y)) (_ : eq (f (pf a) y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m m0)) (Some (pair a' y'))))
+++++
intros.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.

*****
H0 : eq (f (pf a) y) true
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H0 : eq (f (pf a) y) true
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.odd a) true, sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
intro H3.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.

*****
H3 : eq (N.odd a) true
H0 : eq (f (pf a) y) true
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.

*****
H3 : eq (N.odd a) true
H0 : eq (f (pf a) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.

*****
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).

*****
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : ad) (_ : sig (fun y' : A => eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair x y')))), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
intros a'' H4.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.

*****
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
elim H4.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.

*****
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1) (Some (pair a'' x))), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
intros y'' H5.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y)), sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a0 : ad => pf (N.double a0)) m0 with | Some r => Some r | None => MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1 end (Some (pair a' y'))))
+++++
intro H6.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.

*****
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
elim H6.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.

*****
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some x)), sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
intro r.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.
intro r.

*****
r : prod ad A
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some r), sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
elim r.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.
intro r.
elim r.

*****
r : prod ad A
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (b : A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a b))), sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a0 : ad => pf (N.double a0)) m0 with | Some r => Some r | None => MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1 end (Some (pair a' y'))))
+++++
intros a''' y''' H7.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.
intro r.
elim r.
intros a''' y''' H7.

*****
H7 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0)\n (Some (pair a''' y'''))
y''' : A
a''' : ad
r : prod ad A
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
rewrite H7.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.
intro r.
elim r.
intros a''' y''' H7.
rewrite H7.

*****
H7 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0)\n (Some (pair a''' y'''))
y''' : A
a''' : ad
r : prod ad A
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (Some (pair a''' y''')) (Some (pair a' y'))))
+++++
split with a'''.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.
intro r.
elim r.
intros a''' y''' H7.
rewrite H7.
split with a'''.

*****
H7 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0)\n (Some (pair a''' y'''))
y''' : A
a''' : ad
r : prod ad A
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun y' : A => eq (Some (pair a''' y''')) (Some (pair a''' y')))
+++++
split with y'''.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
elim H6.
intro r.
elim r.
intros a''' y''' H7.
rewrite H7.
split with a'''.
split with y'''.

*****
H7 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0)\n (Some (pair a''' y'''))
y''' : A
a''' : ad
r : prod ad A
H6 : sig\n (fun y : prod ad A =>\n eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) (Some y))
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (Some (pair a''' y''')) (Some (pair a''' y'''))
+++++
reflexivity.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None, sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
intro H6.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.

*****
H6 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a' y'))))
+++++
rewrite H6.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
rewrite H6.

*****
H6 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) (Some (pair a' y'))))
+++++
split with a''.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
rewrite H6.
split with a''.

*****
H6 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun y' : A => eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) (Some (pair a'' y')))
+++++
split with y''.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double_plus_one a H3) in H0.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
simpl in |- *.
elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
intro H6.
rewrite H6.
split with a''.
split with y''.

*****
H6 : eq (MapSweep1 (fun a : ad => pf (N.double a)) m0) None
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.succ_double a0)) m1)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) true
H0 : eq (f (pf (N.succ_double (N.div2 a))) y) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 (fun a : ad => pf (N.succ_double a)) m1) (Some (pair a'' y''))
+++++
assumption.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H0 : eq (f (pf a) y) true
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : eq (N.odd a) false, sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
intro H3.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.

*****
H3 : eq (N.odd a) false
H0 : eq (f (pf a) y) true
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.

*****
H3 : eq (N.odd a) false
H0 : eq (f (pf a) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
rewrite <- (Ndiv2_double a H3) in H0.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.

*****
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).

*****
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : ad) (_ : sig (fun y' : A => eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair x y')))), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
intros a'' H4.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.

*****
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
elim H4.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.

*****
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (x : A) (_ : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0) (Some (pair a'' x))), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
intros y'' H5.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a' y'))))
+++++
split with a''.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
split with a''.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sig (fun y' : A => eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a'' y')))
+++++
split with y''.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
split with a''.
split with y''.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapSweep1 pf (M2 A m0 m1)) (Some (pair a'' y''))
+++++
simpl in |- *.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
split with a''.
split with y''.
simpl in |- *.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq match MapSweep1 (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 (fun a : ad => pf (N.succ_double a)) m1 end (Some (pair a'' y''))
+++++
rewrite H5.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
rewrite <- (Ndiv2_double a H3) in H0.
elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0).
intros a'' H4.
elim H4.
intros y'' H5.
split with a''.
split with y''.
simpl in |- *.
rewrite H5.

*****
H5 : eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y''))
y'' : A
H4 : sig\n (fun y' : A =>\n eq (MapSweep1 (fun a0 : ad => pf (N.double a0)) m0)\n (Some (pair a'' y')))
a'' : ad
H3 : eq (N.odd a) false
H0 : eq (f (pf (N.double (N.div2 a))) y) true
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m1) (Some (pair a' y'))))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (f (pf a) y) true),\nsigT\n (fun a' : ad =>\n sig (fun y' : A => eq (MapSweep1 pf m0) (Some (pair a' y'))))
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (Some (pair a'' y'')) (Some (pair a'' y''))
+++++
reflexivity.
-----
Lemma MapSweep_semantics_4_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = true -> {a' : ad & {y' : A | MapSweep1 pf m = Some (a', y')}}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapSweep_semantics_4 :\n   forall (m:Map A) (a:ad) (y:A),\n     MapGet A m a = Some y ->\n     f a y = true -> {a' : ad &  {y' : A | MapSweep m = Some (a', y')}}.
-----
Lemma MapSweep_semantics_4 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> f a y = true -> {a' : ad & {y' : A | MapSweep m = Some (a', y')}}.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (f a y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep m) (Some (pair a' y'))))
+++++
Proof.
-----
Lemma MapSweep_semantics_4 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> f a y = true -> {a' : ad & {y' : A | MapSweep m = Some (a', y')}}.
Proof.

*****
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (f a y) true), sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep m) (Some (pair a' y'))))
+++++
intros.
-----
Lemma MapSweep_semantics_4 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> f a y = true -> {a' : ad & {y' : A | MapSweep m = Some (a', y')}}.
Proof.
intros.

*****
H0 : eq (f a y) true
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
sigT (fun a' : ad => sig (fun y' : A => eq (MapSweep m) (Some (pair a' y'))))
+++++
exact (MapSweep_semantics_4_1 m (fun a0:ad => a0) a y H H0).
-----
Lemma MapSweep_semantics_4 : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> f a y = true -> {a' : ad & {y' : A | MapSweep m = Some (a', y')}}.
Proof.
intros.
exact (MapSweep_semantics_4_1 m (fun a0:ad => a0) a y H H0).

*****

*****

+++++
Qed.
-----
End MapSweepDef.
-----
Variable B : Type.
-----
Fixpoint MapCollect1 (f:ad -> A -> Map B) (pf:ad -> ad) \n   (m:Map A) {struct m} : Map B :=\n    match m with\n    | M0 => M0 B\n    | M1 a y => f (pf a) y\n    | M2 m1 m2 =>\n        MapMerge B (MapCollect1 f (fun a0:ad => pf (Ndouble a0)) m1)\n          (MapCollect1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)\n    end.
-----
Definition MapCollect (f:ad -> A -> Map B) (m:Map A) :=\n    MapCollect1 f (fun a:ad => a) m.
-----
Section MapFoldDef.
-----
Variable M : Type.
-----
Variable neutral : M.
-----
Variable op : M -> M -> M.
-----
Fixpoint MapFold1 (f:ad -> A -> M) (pf:ad -> ad) \n     (m:Map A) {struct m} : M :=\n      match m with\n      | M0 => neutral\n      | M1 a y => f (pf a) y\n      | M2 m1 m2 =>\n          op (MapFold1 f (fun a0:ad => pf (Ndouble a0)) m1)\n            (MapFold1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)\n      end.
-----
Definition MapFold (f:ad -> A -> M) (m:Map A) :=\n      MapFold1 f (fun a:ad => a) m.
-----
Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.
-----
Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.

*****
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall f : forall (_ : ad) (_ : A), M, eq (MapFold f (M0 A)) neutral
+++++
Proof.
-----
Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.
Proof.

*****
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall f : forall (_ : ad) (_ : A), M, eq (MapFold f (M0 A)) neutral
+++++
trivial.
-----
Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapFold_M1 :\n     forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.
-----
Lemma MapFold_M1 : forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.

*****
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (a : ad) (y : A), eq (MapFold f (M1 A a y)) (f a y)
+++++
Proof.
-----
Lemma MapFold_M1 : forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.
Proof.

*****
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (a : ad) (y : A), eq (MapFold f (M1 A a y)) (f a y)
+++++
trivial.
-----
Lemma MapFold_M1 : forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Variable State : Type.
-----
Variable f : State -> ad -> A -> State * M.
-----
Fixpoint MapFold1_state (state:State) (pf:ad -> ad) \n     (m:Map A) {struct m} : State * M :=\n      match m with\n      | M0 => (state, neutral)\n      | M1 a y => f state (pf a) y\n      | M2 m1 m2 =>\n          match MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m1 with\n          | (state1, x1) =>\n              match\n                MapFold1_state state1\n                  (fun a0:ad => pf (Ndouble_plus_one a0)) m2\n              with\n              | (state2, x2) => (state2, op x1 x2)\n              end\n          end\n      end.
-----
Definition MapFold_state (state:State) :=\n      MapFold1_state state (fun a:ad => a).
-----
Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).
-----
Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).

*****
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (B C : Type) (x : prod B C), eq x (pair (fst x) (snd x))
+++++
Proof.
-----
Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).
Proof.

*****
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (B C : Type) (x : prod B C), eq x (pair (fst x) (snd x))
+++++
simple induction x.
-----
Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).
Proof.
simple induction x.

*****
x : prod B0 C
C : Type
B0 : Type
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (a : B0) (b : C), eq (pair a b) (pair (fst (pair a b)) (snd (pair a b)))
+++++
trivial.
-----
Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).
Proof.
simple induction x.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapFold_state_stateless_1 :\n     forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad),\n       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->\n       forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.

*****
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (m : Map A) (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State), eq (snd (MapFold1_state state pf m)) (MapFold1 g pf m)
+++++
Proof.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.

*****
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (m : Map A) (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State), eq (snd (MapFold1_state state pf m)) (MapFold1 g pf m)
+++++
simple induction m.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State), eq (snd (MapFold1_state state pf (M0 A))) (MapFold1 g pf (M0 A))
+++++
trivial.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a1 : ad) (y : A), eq (snd (f state a1 y)) (g a1 y)) (state : State), eq (snd (MapFold1_state state pf (M1 A a a0))) (MapFold1 g pf (M1 A a a0))
+++++
intros.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.

*****
state : State
H : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (MapFold1_state state pf (M1 A a a0))) (MapFold1 g pf (M1 A a a0))
+++++
simpl in |- *.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
state : State
H : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (f state (pf a) a0)) (g (pf a) a0)
+++++
apply H.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (m : Map A) (_ : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State), eq (snd (MapFold1_state state pf m)) (MapFold1 g pf m)) (m0 : Map A) (_ : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State), eq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)) (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State), eq (snd (MapFold1_state state pf (M2 A m m0))) (MapFold1 g pf (M2 A m m0))
+++++
intros.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (MapFold1_state state pf (M2 A m0 m1))) (MapFold1 g pf (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (let (state1, x1) := MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0 in let (state2, x2) := MapFold1_state state1 (fun a0 : ad => pf (N.succ_double a0)) m1 in pair state2 (op x1 x2))) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)).
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)).

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (let (state2, x2) := MapFold1_state (fst (MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0)) (fun a0 : ad => pf (N.succ_double a0)) m1 in pair state2 (op (snd (MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0)) x2))) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite (H g (fun a0:ad => pf (Ndouble a0)) H1 state).
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)).
rewrite (H g (fun a0:ad => pf (Ndouble a0)) H1 state).

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (let (state2, x2) := MapFold1_state (fst (MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0)) (fun a0 : ad => pf (N.succ_double a0)) m1 in pair state2 (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) x2))) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite (pair_sp _ _ (MapFold1_state (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)).
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)).
rewrite (H g (fun a0:ad => pf (Ndouble a0)) H1 state).
rewrite (pair_sp _ _ (MapFold1_state (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)).

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (pair (fst (MapFold1_state (fst (MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0)) (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (snd (MapFold1_state (fst (MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0)) (fun a0 : ad => pf (N.succ_double a0)) m1))))) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
simpl in |- *.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)).
rewrite (H g (fun a0:ad => pf (Ndouble a0)) H1 state).
rewrite (pair_sp _ _ (MapFold1_state (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)).
simpl in |- *.

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (snd (MapFold1_state (fst (MapFold1_state state (fun a0 : ad => pf (N.double a0)) m0)) (fun a0 : ad => pf (N.succ_double a0)) m1))) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite (H0 g (fun a0:ad => pf (Ndouble_plus_one a0)) H1 (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0))).
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)).
rewrite (H g (fun a0:ad => pf (Ndouble a0)) H1 state).
rewrite (pair_sp _ _ (MapFold1_state (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)).
simpl in |- *.
rewrite (H0 g (fun a0:ad => pf (Ndouble_plus_one a0)) H1 (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0))).

*****
state : State
H1 : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
pf : forall _ : ad, ad
g : forall (_ : ad) (_ : A), M
H0 : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m1)) (MapFold1 g pf m1)
m1 : Map A
H : forall (g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (state : State) (a : ad) (y : A),\n eq (snd (f state a y)) (g a y)) (state : State),\neq (snd (MapFold1_state state pf m0)) (MapFold1 g pf m0)
m,m0 : Map A
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
reflexivity.
-----
Lemma MapFold_state_stateless_1 : forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad), (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_state_stateless :\n     forall g:ad -> A -> M,\n       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->\n       forall (state:State) (m:Map A),\n         snd (MapFold_state state m) = MapFold g m.
-----
Lemma MapFold_state_stateless : forall g:ad -> A -> M, (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall (state:State) (m:Map A), snd (MapFold_state state m) = MapFold g m.

*****
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (g : forall (_ : ad) (_ : A), M) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State) (m : Map A), eq (snd (MapFold_state state m)) (MapFold g m)
+++++
Proof.
-----
Lemma MapFold_state_stateless : forall g:ad -> A -> M, (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall (state:State) (m:Map A), snd (MapFold_state state m) = MapFold g m.
Proof.

*****
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (g : forall (_ : ad) (_ : A), M) (_ : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)) (state : State) (m : Map A), eq (snd (MapFold_state state m)) (MapFold g m)
+++++
intros.
-----
Lemma MapFold_state_stateless : forall g:ad -> A -> M, (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall (state:State) (m:Map A), snd (MapFold_state state m) = MapFold g m.
Proof.
intros.

*****
m : Map A
state : State
H : forall (state : State) (a : ad) (y : A), eq (snd (f state a y)) (g a y)
g : forall (_ : ad) (_ : A), M
f : forall (_ : State) (_ : ad) (_ : A), prod State M
State : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (snd (MapFold_state state m)) (MapFold g m)
+++++
exact (MapFold_state_stateless_1 m g (fun a0:ad => a0) H state).
-----
Lemma MapFold_state_stateless : forall g:ad -> A -> M, (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) -> forall (state:State) (m:Map A), snd (MapFold_state state m) = MapFold g m.
Proof.
intros.
exact (MapFold_state_stateless_1 m g (fun a0:ad => a0) H state).

*****

*****

+++++
Qed.
-----
End MapFoldDef.
-----
Lemma MapCollect_as_Fold :\n   forall (f:ad -> A -> Map B) (m:Map A),\n     MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
-----
Lemma MapCollect_as_Fold : forall (f:ad -> A -> Map B) (m:Map A), MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.

*****
B : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), Map B) (m : Map A), eq (MapCollect f m) (MapFold (Map B) (M0 B) (MapMerge B) f m)
+++++
Proof.
-----
Lemma MapCollect_as_Fold : forall (f:ad -> A -> Map B) (m:Map A), MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
Proof.

*****
B : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), Map B) (m : Map A), eq (MapCollect f m) (MapFold (Map B) (M0 B) (MapMerge B) f m)
+++++
simple induction m.
-----
Lemma MapCollect_as_Fold : forall (f:ad -> A -> Map B) (m:Map A), MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), Map B
B : Type
A : Type
*****
eq (MapCollect f (M0 A)) (MapFold (Map B) (M0 B) (MapMerge B) f (M0 A))
+++++
trivial.
-----
Lemma MapCollect_as_Fold : forall (f:ad -> A -> Map B) (m:Map A), MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), Map B
B : Type
A : Type
*****
forall (a : ad) (a0 : A), eq (MapCollect f (M1 A a a0)) (MapFold (Map B) (M0 B) (MapMerge B) f (M1 A a a0))
+++++
trivial.
-----
Lemma MapCollect_as_Fold : forall (f:ad -> A -> Map B) (m:Map A), MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), Map B
B : Type
A : Type
*****
forall (m : Map A) (_ : eq (MapCollect f m) (MapFold (Map B) (M0 B) (MapMerge B) f m)) (m0 : Map A) (_ : eq (MapCollect f m0) (MapFold (Map B) (M0 B) (MapMerge B) f m0)), eq (MapCollect f (M2 A m m0)) (MapFold (Map B) (M0 B) (MapMerge B) f (M2 A m m0))
+++++
trivial.
-----
Lemma MapCollect_as_Fold : forall (f:ad -> A -> Map B) (m:Map A), MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Definition alist := list (ad * A).
-----
Definition anil := nil (A:=(ad * A)).
-----
Definition acons := cons (A:=(ad * A)).
-----
Definition aapp := app (A:=(ad * A)).
-----
Definition alist_of_Map :=\n    MapFold alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil).
-----
Fixpoint alist_semantics (l:alist) : ad -> option A :=\n    match l with\n    | nil => fun _:ad => None\n    | (a, y) :: l' =>\n        fun a0:ad => if Neqb a a0 then Some y else alist_semantics l' a0\n    end.
-----
Lemma alist_semantics_app :\n   forall (l l':alist) (a:ad),\n     alist_semantics (aapp l l') a =\n     match alist_semantics l a with\n     | None => alist_semantics l' a\n     | Some y => Some y\n     end.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.

*****
B : Type
A : Type
*****
forall (l l' : alist) (a : ad), eq (alist_semantics (aapp l l') a) match alist_semantics l a with | Some y => Some y | None => alist_semantics l' a end
+++++
Proof.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.

*****
B : Type
A : Type
*****
forall (l l' : alist) (a : ad), eq (alist_semantics (aapp l l') a) match alist_semantics l a with | Some y => Some y | None => alist_semantics l' a end
+++++
unfold aapp in |- *.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.

*****
B : Type
A : Type
*****
forall (l l' : alist) (a : ad), eq (alist_semantics (app l l') a) match alist_semantics l a with | Some y => Some y | None => alist_semantics l' a end
+++++
simple induction l.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.

*****
l : alist
B : Type
A : Type
*****
forall (l' : alist) (a : ad), eq (alist_semantics (app nil l') a) match alist_semantics nil a with | Some y => Some y | None => alist_semantics l' a end
+++++
trivial.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.

*****
l : alist
B : Type
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (l' : alist) (a0 : ad), eq (alist_semantics (app l l') a0) match alist_semantics l a0 with | Some y => Some y | None => alist_semantics l' a0 end) (l' : alist) (a0 : ad), eq (alist_semantics (app (cons a l) l') a0) match alist_semantics (cons a l) a0 with | Some y => Some y | None => alist_semantics l' a0 end
+++++
intros.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.
intros.

*****
a0 : ad
l' : alist
H : forall (l' : alist) (a : ad),\neq (alist_semantics (app l0 l') a)\n match alist_semantics l0 a with\n | Some y => Some y\n | None => alist_semantics l' a\n end
l0 : list (prod ad A)
a : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics (app (cons a l0) l') a0) match alist_semantics (cons a l0) a0 with | Some y => Some y | None => alist_semantics l' a0 end
+++++
elim a.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.
intros.
elim a.

*****
a0 : ad
l' : alist
H : forall (l' : alist) (a : ad),\neq (alist_semantics (app l0 l') a)\n match alist_semantics l0 a with\n | Some y => Some y\n | None => alist_semantics l' a\n end
l0 : list (prod ad A)
a : prod ad A
l : alist
B : Type
A : Type
*****
forall (a : ad) (b : A), eq (alist_semantics (app (cons (pair a b) l0) l') a0) match alist_semantics (cons (pair a b) l0) a0 with | Some y => Some y | None => alist_semantics l' a0 end
+++++
intros a1 y1.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.
intros.
elim a.
intros a1 y1.

*****
y1 : A
a0,a1 : ad
l' : alist
H : forall (l' : alist) (a : ad),\neq (alist_semantics (app l0 l') a)\n match alist_semantics l0 a with\n | Some y => Some y\n | None => alist_semantics l' a\n end
l0 : list (prod ad A)
a : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics (app (cons (pair a1 y1) l0) l') a0) match alist_semantics (cons (pair a1 y1) l0) a0 with | Some y => Some y | None => alist_semantics l' a0 end
+++++
simpl in |- *.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.
intros.
elim a.
intros a1 y1.
simpl in |- *.

*****
y1 : A
a0,a1 : ad
l' : alist
H : forall (l' : alist) (a : ad),\neq (alist_semantics (app l0 l') a)\n match alist_semantics l0 a with\n | Some y => Some y\n | None => alist_semantics l' a\n end
l0 : list (prod ad A)
a : prod ad A
l : alist
B : Type
A : Type
*****
eq (if N.eqb a1 a0 then Some y1 else alist_semantics (app l0 l') a0) match (if N.eqb a1 a0 then Some y1 else alist_semantics l0 a0) with | Some y => Some y | None => alist_semantics l' a0 end
+++++
case (Neqb a1 a0).
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.
intros.
elim a.
intros a1 y1.
simpl in |- *.
case (Neqb a1 a0).

*****
y1 : A
a0,a1 : ad
l' : alist
H : forall (l' : alist) (a : ad),\neq (alist_semantics (app l0 l') a)\n match alist_semantics l0 a with\n | Some y => Some y\n | None => alist_semantics l' a\n end
l0 : list (prod ad A)
a : prod ad A
l : alist
B : Type
A : Type
*****
eq (Some y1) (Some y1)
+++++
reflexivity.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.
intros.
elim a.
intros a1 y1.
simpl in |- *.
case (Neqb a1 a0).

*****
y1 : A
a0,a1 : ad
l' : alist
H : forall (l' : alist) (a : ad),\neq (alist_semantics (app l0 l') a)\n match alist_semantics l0 a with\n | Some y => Some y\n | None => alist_semantics l' a\n end
l0 : list (prod ad A)
a : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics (app l0 l') a0) match alist_semantics l0 a0 with | Some y => Some y | None => alist_semantics l' a0 end
+++++
apply H.
-----
Lemma alist_semantics_app : forall (l l':alist) (a:ad), alist_semantics (aapp l l') a = match alist_semantics l a with | None => alist_semantics l' a | Some y => Some y end.
Proof.
unfold aapp in |- *.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_semantics_1_1 :\n   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),\n     alist_semantics\n       (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf\n          m) a = Some y -> {a' : ad | a = pf a'}.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.

*****
B : Type
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf m) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
+++++
Proof.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.

*****
B : Type
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf m) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
+++++
simple induction m.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf (M0 A)) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
+++++
simpl in |- *.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq None (Some y)), sig (fun a' : ad => eq a (pf a'))
+++++
intros.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H : eq None (Some y)
y : A
a : ad
pf : forall _ : ad, ad
m : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
discriminate H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a2 : ad) (y0 : A) => acons (pair a2 y0) anil) pf (M1 A a a0)) a1) (Some y)), sig (fun a' : ad => eq a1 (pf a'))
+++++
simpl in |- *.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (a1 : ad) (y : A) (_ : eq (if N.eqb (pf a) a1 then Some a0 else None) (Some y)), sig (fun a' : ad => eq a1 (pf a'))
+++++
intros a y pf a0 y0.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (if N.eqb (pf a) a0 then Some y else None) (Some y0), sig (fun a' : ad => eq a0 (pf a'))
+++++
elim (sumbool_of_bool (Neqb (pf a) a0)).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall (_ : eq (N.eqb (pf a) a0) true) (_ : eq (if N.eqb (pf a) a0 then Some y else None) (Some y0)), sig (fun a' : ad => eq a0 (pf a'))
+++++
intro H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.

*****
H : eq (N.eqb (pf a) a0) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (if N.eqb (pf a) a0 then Some y else None) (Some y0), sig (fun a' : ad => eq a0 (pf a'))
+++++
rewrite H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb (pf a) a0) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (Some y) (Some y0), sig (fun a' : ad => eq a0 (pf a'))
+++++
intro H0.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.
rewrite H.
intro H0.

*****
H0 : eq (Some y) (Some y0)
H : eq (N.eqb (pf a) a0) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a0 (pf a'))
+++++
split with a.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.
rewrite H.
intro H0.
split with a.

*****
H0 : eq (Some y) (Some y0)
H : eq (N.eqb (pf a) a0) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
eq a0 (pf a)
+++++
rewrite (Neqb_complete _ _ H).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.
rewrite H.
intro H0.
split with a.
rewrite (Neqb_complete _ _ H).

*****
H0 : eq (Some y) (Some y0)
H : eq (N.eqb (pf a) a0) true
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
eq a0 a0
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).

*****
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall (_ : eq (N.eqb (pf a) a0) false) (_ : eq (if N.eqb (pf a) a0 then Some y else None) (Some y0)), sig (fun a' : ad => eq a0 (pf a'))
+++++
intro H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.

*****
H : eq (N.eqb (pf a) a0) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (if N.eqb (pf a) a0 then Some y else None) (Some y0), sig (fun a' : ad => eq a0 (pf a'))
+++++
rewrite H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.
rewrite H.

*****
H : eq (N.eqb (pf a) a0) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq None (Some y0), sig (fun a' : ad => eq a0 (pf a'))
+++++
intro H0.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
simpl in |- *.
intros a y pf a0 y0.
elim (sumbool_of_bool (Neqb (pf a) a0)).
intro H.
rewrite H.
intro H0.

*****
H0 : eq None (Some y0)
H : eq (N.eqb (pf a) a0) false
y0 : A
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a0 (pf a'))
+++++
discriminate H0.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf m) a) (Some y)), sig (fun a' : ad => eq a (pf a'))) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))) (pf : forall _ : ad, ad) (a : ad) (y : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf (M2 A m m0)) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
+++++
intros.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.

*****
H : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf\n (M2 A m0 m1)) a) (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.

*****
H : eq\n (alist_semantics\n (aapp\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil)\n (fun a0 : ad => pf (N.double a0)) m0)\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1)) a) \n (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.

*****
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).

*****
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : sig (fun y : A => eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) (fun a0 : ad => pf (N.double a0)) m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
+++++
intro H2.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.

*****
H2 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) \n (Some y))
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
elim H2.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
elim H2.

*****
H2 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) \n (Some y))
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) (fun a0 : ad => pf (N.double a0)) m0) a) (Some x)), sig (fun a' : ad => eq a (pf a'))
+++++
intros y0 H3.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
elim H2.
intros y0 H3.

*****
H3 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) (Some y0)
y0 : A
H2 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) \n (Some y))
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
elim (X (fun a0:ad => pf (Ndouble a0)) a y0 H3).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
elim H2.
intros y0 H3.
elim (X (fun a0:ad => pf (Ndouble a0)) a y0 H3).

*****
H3 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) (Some y0)
y0 : A
H2 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) \n (Some y))
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : ad) (_ : eq a (pf (N.double x))), sig (fun a' : ad => eq a (pf a'))
+++++
intros a0 H4.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
elim H2.
intros y0 H3.
elim (X (fun a0:ad => pf (Ndouble a0)) a y0 H3).
intros a0 H4.

*****
H4 : eq a (pf (N.double a0))
a0 : ad
H3 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) (Some y0)
y0 : A
H2 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) \n (Some y))
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
split with (Ndouble a0).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
elim H2.
intros y0 H3.
elim (X (fun a0:ad => pf (Ndouble a0)) a y0 H3).
intros a0 H4.
split with (Ndouble a0).

*****
H4 : eq a (pf (N.double a0))
a0 : ad
H3 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) (Some y0)
y0 : A
H2 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) \n (Some y))
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
eq a (pf (N.double a0))
+++++
assumption.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).

*****
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) (fun a0 : ad => pf (N.double a0)) m0) a) None, sig (fun a' : ad => eq a (pf a'))
+++++
intro H2.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.

*****
H2 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) None
H : eq\n match\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a\n with\n | Some y => Some y\n | None =>\n alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a\n end (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
rewrite H2 in H.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
rewrite H2 in H.

*****
H2 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) None
H : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a) \n (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
rewrite H2 in H.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H).

*****
H2 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) None
H : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a) \n (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : ad) (_ : eq a (pf (N.succ_double x))), sig (fun a' : ad => eq a (pf a'))
+++++
intros a0 H3.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
rewrite H2 in H.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H).
intros a0 H3.

*****
H3 : eq a (pf (N.succ_double a0))
a0 : ad
H2 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) None
H : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a) \n (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
sig (fun a' : ad => eq a (pf a'))
+++++
split with (Ndouble_plus_one a0).
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.
intros.
change (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = Some y) in H.
rewrite (alist_semantics_app (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a) in H.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil) (fun a0:ad => pf (Ndouble a0)) m0) a)).
intro H2.
rewrite H2 in H.
elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H).
intros a0 H3.
split with (Ndouble_plus_one a0).

*****
H3 : eq a (pf (N.succ_double a0))
a0 : ad
H2 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.double a0)) m0) a) None
H : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil)\n (fun a0 : ad => pf (N.succ_double a0)) m1) a) \n (Some y)
y : A
a : ad
pf : forall _ : ad, ad
X0 : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m1) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m1 : Map A
X : forall (pf : forall _ : ad, ad) (a : ad) (y : A)\n (_ : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y0 : A) => acons (pair a0 y0) anil) pf\n m0) a) (Some y)), sig (fun a' : ad => eq a (pf a'))
m,m0 : Map A
B : Type
A : Type
*****
eq a (pf (N.succ_double a0))
+++++
assumption.
-----
Lemma alist_of_Map_semantics_1_1 : forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A), alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) a = Some y -> {a' : ad | a = pf a'}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Definition ad_inj (pf:ad -> ad) :=\n    forall a0 a1:ad, pf a0 = pf a1 -> a0 = a1.
-----
Lemma ad_comp_double_inj :\n   forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
-----
Lemma ad_comp_double_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).

*****
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_inj pf), ad_inj (fun a0 : ad => pf (N.double a0))
+++++
Proof.
-----
Lemma ad_comp_double_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
Proof.

*****
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_inj pf), ad_inj (fun a0 : ad => pf (N.double a0))
+++++
unfold ad_inj in |- *.
-----
Lemma ad_comp_double_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
Proof.
unfold ad_inj in |- *.

*****
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : forall (a0 a1 : ad) (_ : eq (pf a0) (pf a1)), eq a0 a1) (a0 a1 : ad) (_ : eq (pf (N.double a0)) (pf (N.double a1))), eq a0 a1
+++++
intros.
-----
Lemma ad_comp_double_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
Proof.
unfold ad_inj in |- *.
intros.

*****
H0 : eq (pf (N.double a0)) (pf (N.double a1))
a0,a1 : ad
H : forall (a0 a1 : ad) (_ : eq (pf a0) (pf a1)), eq a0 a1
pf : forall _ : ad, ad
B : Type
A : Type
*****
eq a0 a1
+++++
apply Ndouble_inj.
-----
Lemma ad_comp_double_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
Proof.
unfold ad_inj in |- *.
intros.
apply Ndouble_inj.

*****
H0 : eq (pf (N.double a0)) (pf (N.double a1))
a0,a1 : ad
H : forall (a0 a1 : ad) (_ : eq (pf a0) (pf a1)), eq a0 a1
pf : forall _ : ad, ad
B : Type
A : Type
*****
eq (N.double a0) (N.double a1)
+++++
exact (H _ _ H0).
-----
Lemma ad_comp_double_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
Proof.
unfold ad_inj in |- *.
intros.
apply Ndouble_inj.
exact (H _ _ H0).

*****

*****

+++++
Qed.
-----
Lemma ad_comp_double_plus_un_inj :\n   forall pf:ad -> ad,\n     ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
-----
Lemma ad_comp_double_plus_un_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).

*****
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_inj pf), ad_inj (fun a0 : ad => pf (N.succ_double a0))
+++++
Proof.
-----
Lemma ad_comp_double_plus_un_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.

*****
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_inj pf), ad_inj (fun a0 : ad => pf (N.succ_double a0))
+++++
unfold ad_inj in |- *.
-----
Lemma ad_comp_double_plus_un_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
unfold ad_inj in |- *.

*****
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : forall (a0 a1 : ad) (_ : eq (pf a0) (pf a1)), eq a0 a1) (a0 a1 : ad) (_ : eq (pf (N.succ_double a0)) (pf (N.succ_double a1))), eq a0 a1
+++++
intros.
-----
Lemma ad_comp_double_plus_un_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
unfold ad_inj in |- *.
intros.

*****
H0 : eq (pf (N.succ_double a0)) (pf (N.succ_double a1))
a0,a1 : ad
H : forall (a0 a1 : ad) (_ : eq (pf a0) (pf a1)), eq a0 a1
pf : forall _ : ad, ad
B : Type
A : Type
*****
eq a0 a1
+++++
apply Ndouble_plus_one_inj.
-----
Lemma ad_comp_double_plus_un_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
unfold ad_inj in |- *.
intros.
apply Ndouble_plus_one_inj.

*****
H0 : eq (pf (N.succ_double a0)) (pf (N.succ_double a1))
a0,a1 : ad
H : forall (a0 a1 : ad) (_ : eq (pf a0) (pf a1)), eq a0 a1
pf : forall _ : ad, ad
B : Type
A : Type
*****
eq (N.succ_double a0) (N.succ_double a1)
+++++
exact (H _ _ H0).
-----
Lemma ad_comp_double_plus_un_inj : forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
unfold ad_inj in |- *.
intros.
apply Ndouble_plus_one_inj.
exact (H _ _ H0).

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_semantics_1 :\n   forall (m:Map A) (pf:ad -> ad),\n     ad_inj pf ->\n     forall a:ad,\n       MapGet A m a =\n       alist_semantics\n         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)\n            pf m) (pf a).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).

*****
B : Type
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad), eq (MapGet A m a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m) (pf a))
+++++
Proof.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.

*****
B : Type
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad), eq (MapGet A m a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m) (pf a))
+++++
simple induction m.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad), eq (MapGet A (M0 A) a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf (M0 A)) (pf a))
+++++
trivial.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : ad_inj pf) (a1 : ad), eq (MapGet A (M1 A a a0) a1) (alist_semantics (MapFold1 alist anil aapp (fun (a2 : ad) (y : A) => acons (pair a2 y) anil) pf (M1 A a a0)) (pf a1))
+++++
simpl in |- *.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : ad_inj pf) (a1 : ad), eq (if N.eqb a a1 then Some a0 else None) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
intros.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.

*****
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq (if N.eqb a a1 then Some a0 else None) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (N.eqb a a1) true, eq (if N.eqb a a1 then Some a0 else None) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
intro H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) true
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq (if N.eqb a a1 then Some a0 else None) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
rewrite H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a1) true
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq (Some a0) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
rewrite (Neqb_complete _ _ H0).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a a1) true
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq (Some a0) (if N.eqb (pf a1) (pf a1) then Some a0 else None)
+++++
rewrite (Neqb_correct (pf a1)).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (Neqb_correct (pf a1)).

*****
H0 : eq (N.eqb a a1) true
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq (Some a0) (Some a0)
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (N.eqb a a1) false, eq (if N.eqb a a1 then Some a0 else None) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
intro H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq (if N.eqb a a1 then Some a0 else None) (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
rewrite H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).

*****
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (N.eqb (pf a) (pf a1)) true, eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
intro H1.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).
intro H1.

*****
H1 : eq (N.eqb (pf a) (pf a1)) true
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
rewrite (H a a1 (Neqb_complete _ _ H1)) in H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).
intro H1.
rewrite (H a a1 (Neqb_complete _ _ H1)) in H0.

*****
H1 : eq (N.eqb (pf a) (pf a1)) true
H0 : eq (N.eqb a1 a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
rewrite (Neqb_correct a1) in H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).
intro H1.
rewrite (H a a1 (Neqb_complete _ _ H1)) in H0.
rewrite (Neqb_correct a1) in H0.

*****
H1 : eq (N.eqb (pf a) (pf a1)) true
H0 : eq true false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
discriminate H0.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).

*****
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
forall _ : eq (N.eqb (pf a) (pf a1)) false, eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
intro H1.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).
intro H1.

*****
H1 : eq (N.eqb (pf a) (pf a1)) false
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq None (if N.eqb (pf a) (pf a1) then Some a0 else None)
+++++
rewrite H1.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (Neqb (pf a) (pf a1))).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb (pf a) (pf a1)) false
H0 : eq (N.eqb a a1) false
a1 : ad
H : ad_inj pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
B : Type
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.

*****
m : Map A
B : Type
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad), eq (MapGet A m a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m) (pf a))) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad), eq (MapGet A m0 a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) (pf a))) (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad), eq (MapGet A (M2 A m m0) a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf (M2 A m m0)) (pf a))
+++++
intros.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.

*****
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A (M2 A m0 m1) a) (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf (M2 A m0 m1)) (pf a))
+++++
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.

*****
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A (M2 A m0 m1) a) (alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1)) (pf a))
+++++
rewrite alist_semantics_app.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.

*****
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A (M2 A m0 m1) a) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).

*****
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
elim (Ndouble_or_double_plus_un a).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).

*****
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : sig (fun a0 : N => eq a (N.double a0)), eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) (fun a1 : ad => pf (N.double a1)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) (fun a1 : ad => pf (N.succ_double a1)) m1) (pf a) end
+++++
intro H2.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.

*****
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
elim H2.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.

*****
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : N) (_ : eq a (N.double x)), eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
intros a0 H3.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
rewrite H3.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd (N.double a0) then MapGet A m1 (N.div2 (N.double a0)) else MapGet A m0 (N.div2 (N.double a0))) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.double a0)) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)) end
+++++
rewrite (Ndouble_bit0 a0).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m0 (N.div2 (N.double a0))) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.double a0)) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)) end
+++++
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m0 (N.div2 (N.double a0))) match MapGet A m0 a0 with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)) end
+++++
rewrite Ndouble_div2.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m0 a0) match MapGet A m0 a0 with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)) end
+++++
case (MapGet A m0 a0).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall a : A, eq (Some a) (Some a)
+++++
trivial.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
trivial.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : sig (fun y : A => eq (alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil) (fun a1 : ad => pf (N.succ_double a1)) m1) (pf (N.double a0))) (Some y)), eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
intro H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.

*****
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
elim H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.

*****
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) (fun a1 : ad => pf (N.succ_double a1)) m1) (pf (N.double a0))) (Some x)), eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
intros y H5.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.

*****
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).

*****
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : ad) (_ : eq (pf (N.double a0)) (pf (N.succ_double x))), eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
intros a1 H6.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.

*****
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).

*****
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : eq (N.odd (N.double a0)) (N.odd (N.succ_double a1)), eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
intro.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).
intro.

*****
H7 : eq (N.odd (N.double a0)) (N.odd (N.succ_double a1))
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
rewrite (Ndouble_bit0 a0) in H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).
intro.
rewrite (Ndouble_bit0 a0) in H7.

*****
H7 : eq false (N.odd (N.succ_double a1))
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
rewrite (Ndouble_plus_one_bit0 a1) in H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).
intro.
rewrite (Ndouble_bit0 a0) in H7.
rewrite (Ndouble_plus_one_bit0 a1) in H7.

*****
H7 : eq false true
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
discriminate H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).

*****
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (N.odd (N.double a0)) (N.odd (N.succ_double a1))
+++++
rewrite (H1 (Ndouble a0) (Ndouble_plus_one a1) H6).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1)) (pf (Ndouble a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).
rewrite (H1 (Ndouble a0) (Ndouble_plus_one a1) H6).

*****
H6 : eq (pf (N.double a0)) (pf (N.succ_double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1)\n (pf (N.double a0))) (Some y))
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (N.odd (N.succ_double a1)) (N.odd (N.succ_double a1))
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).

*****
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) (fun a1 : ad => pf (N.succ_double a1)) m1) (pf (N.double a0))) None, eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
intro H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.

*****
H4 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) None
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None (alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.double a0)))
+++++
rewrite H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_bit0 a0).
rewrite <- (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0).
rewrite Ndouble_div2.
case (MapGet A m0 a0).
trivial.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble_plus_one a1)) m1) (pf (Ndouble a0)))).
intro H4.
rewrite H4.

*****
H4 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.succ_double a1)) m1) \n (pf (N.double a0))) None
H3 : eq a (N.double a0)
a0 : N
H2 : sig (fun a0 : N => eq a (N.double a0))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).

*****
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : sig (fun a1 : N => eq a (N.succ_double a1)), eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
intro H2.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.

*****
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
elim H2.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.

*****
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : N) (_ : eq a (N.succ_double x)), eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
intros a0 H3.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf a) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf a) end
+++++
rewrite H3.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (if N.odd (N.succ_double a0) then MapGet A m1 (N.div2 (N.succ_double a0)) else MapGet A m0 (N.div2 (N.succ_double a0))) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.succ_double a0)) end
+++++
rewrite (Ndouble_plus_one_bit0 a0).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 (N.div2 (N.succ_double a0))) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1) (pf (N.succ_double a0)) end
+++++
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 (N.div2 (N.succ_double a0))) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
rewrite Ndouble_plus_one_div2.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : sig (fun y : A => eq (alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil) (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0))) (Some y)), eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
intro H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.

*****
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
elim H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.

*****
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : A) (_ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0))) (Some x)), eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
intros y H5.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.

*****
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).

*****
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall (x : ad) (_ : eq (pf (N.succ_double a0)) (pf (N.double x))), eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
intros a1 H6.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.

*****
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).

*****
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : eq (N.odd (N.succ_double a0)) (N.odd (N.double a1)), eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
intro H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).
intro H7.

*****
H7 : eq (N.odd (N.succ_double a0)) (N.odd (N.double a1))
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
rewrite (Ndouble_plus_one_bit0 a0) in H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).
intro H7.
rewrite (Ndouble_plus_one_bit0 a0) in H7.

*****
H7 : eq true (N.odd (N.double a1))
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
rewrite (Ndouble_bit0 a1) in H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).
intro H7.
rewrite (Ndouble_plus_one_bit0 a0) in H7.
rewrite (Ndouble_bit0 a1) in H7.

*****
H7 : eq true false
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
discriminate H7.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).

*****
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (N.odd (N.succ_double a0)) (N.odd (N.double a1))
+++++
rewrite (H1 (Ndouble_plus_one a0) (Ndouble a1) H6).
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
elim H4.
intros y H5.
elim (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1)) (pf (Ndouble_plus_one a0)) y H5).
intros a1 H6.
cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).
rewrite (H1 (Ndouble_plus_one a0) (Ndouble a1) H6).

*****
H6 : eq (pf (N.succ_double a0)) (pf (N.double a1))
a1 : ad
H5 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n (Some y)
y : A
H4 : sig\n (fun y : A =>\n eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y0 : A) => acons (pair a1 y0) anil)\n (fun a1 : ad => pf (N.double a1)) m0)\n (pf (N.succ_double a0))) (Some y))
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (N.odd (N.double a1)) (N.odd (N.double a1))
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).

*****
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
forall _ : eq (alist_semantics (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0))) None, eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
intro H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.

*****
H4 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n None
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) match alist_semantics (MapFold1 alist anil aapp (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) (fun a0 : ad => pf (N.double a0)) m0) (pf (N.succ_double a0)) with | Some y => Some y | None => MapGet A m1 a0 end
+++++
rewrite H4.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.
intros.
change (MapGet A (M2 A m0 m1) a = alist_semantics (aapp (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble a0)) m0) (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) ( pf a)) in |- *.
rewrite alist_semantics_app.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
elim (Ndouble_or_double_plus_un a).
intro H2.
elim H2.
intros a0 H3.
rewrite H3.
rewrite (Ndouble_plus_one_bit0 a0).
rewrite <- (H0 (fun a1:ad => pf (Ndouble_plus_one a1)) (ad_comp_double_plus_un_inj pf H1) a0).
rewrite Ndouble_plus_one_div2.
elim (option_sum A (alist_semantics (MapFold1 alist anil aapp (fun (a1:ad) (y:A) => acons (a1, y) anil) (fun a1:ad => pf (Ndouble a1)) m0) (pf (Ndouble_plus_one a0)))).
intro H4.
rewrite H4.

*****
H4 : eq\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a1 : ad) (y : A) => acons (pair a1 y) anil)\n (fun a1 : ad => pf (N.double a1)) m0) (pf (N.succ_double a0)))\n None
H3 : eq a (N.succ_double a0)
a0 : N
H2 : sig (fun a1 : N => eq a (N.succ_double a1))
a : ad
H1 : ad_inj pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m1 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m1) \n (pf a))
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_inj pf) (a : ad),\neq (MapGet A m0 a)\n (alist_semantics\n (MapFold1 alist anil aapp\n (fun (a0 : ad) (y : A) => acons (pair a0 y) anil) pf m0) \n (pf a))
m,m0 : Map A
B : Type
A : Type
*****
eq (MapGet A m1 a0) (MapGet A m1 a0)
+++++
reflexivity.
-----
Lemma alist_of_Map_semantics_1 : forall (m:Map A) (pf:ad -> ad), ad_inj pf -> forall a:ad, MapGet A m a = alist_semantics (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf m) (pf a).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_semantics :\n   forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).
-----
Lemma alist_of_Map_semantics : forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).

*****
B : Type
A : Type
*****
forall m : Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m))
+++++
Proof.
-----
Lemma alist_of_Map_semantics : forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).
Proof.

*****
B : Type
A : Type
*****
forall m : Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m))
+++++
unfold eqm in |- *.
-----
Lemma alist_of_Map_semantics : forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).
Proof.
unfold eqm in |- *.

*****
B : Type
A : Type
*****
forall (m : Map A) (a : ad), eq (MapGet A m a) (alist_semantics (alist_of_Map m) a)
+++++
intros.
-----
Lemma alist_of_Map_semantics : forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
m : Map A
B : Type
A : Type
*****
eq (MapGet A m a) (alist_semantics (alist_of_Map m) a)
+++++
exact (alist_of_Map_semantics_1 m (fun a0:ad => a0) (fun (a0 a1:ad) (p:a0 = a1) => p) a).
-----
Lemma alist_of_Map_semantics : forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).
Proof.
unfold eqm in |- *.
intros.
exact (alist_of_Map_semantics_1 m (fun a0:ad => a0) (fun (a0 a1:ad) (p:a0 = a1) => p) a).

*****

*****

+++++
Qed.
-----
Fixpoint Map_of_alist (l:alist) : Map A :=\n    match l with\n    | nil => M0 A\n    | (a, y) :: l' => MapPut A (Map_of_alist l') a y\n    end.
-----
Lemma Map_of_alist_semantics :\n   forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).

*****
B : Type
A : Type
*****
forall l : alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l))
+++++
Proof.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.

*****
B : Type
A : Type
*****
forall l : alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l))
+++++
unfold eqm in |- *.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.

*****
B : Type
A : Type
*****
forall (l : alist) (a : ad), eq (alist_semantics l a) (MapGet A (Map_of_alist l) a)
+++++
simple induction l.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.

*****
l : alist
B : Type
A : Type
*****
forall a : ad, eq (alist_semantics nil a) (MapGet A (Map_of_alist nil) a)
+++++
trivial.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.

*****
l : alist
B : Type
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall a0 : ad, eq (alist_semantics l a0) (MapGet A (Map_of_alist l) a0)) (a0 : ad), eq (alist_semantics (cons a l) a0) (MapGet A (Map_of_alist (cons a l)) a0)
+++++
intros r l0 H a.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.

*****
a : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics (cons r l0) a) (MapGet A (Map_of_alist (cons r l0)) a)
+++++
elim r.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.

*****
a : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
forall (a0 : ad) (b : A), eq (alist_semantics (cons (pair a0 b) l0) a) (MapGet A (Map_of_alist (cons (pair a0 b) l0)) a)
+++++
intros a0 y0.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.

*****
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics (cons (pair a0 y0) l0) a) (MapGet A (Map_of_alist (cons (pair a0 y0) l0)) a)
+++++
simpl in |- *.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.

*****
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (if N.eqb a0 a then Some y0 else alist_semantics l0 a) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
elim (sumbool_of_bool (Neqb a0 a)).
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).

*****
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
forall _ : eq (N.eqb a0 a) true, eq (if N.eqb a0 a then Some y0 else alist_semantics l0 a) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
intro H0.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.

*****
H0 : eq (N.eqb a0 a) true
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (if N.eqb a0 a then Some y0 else alist_semantics l0 a) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
rewrite H0.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a0 a) true
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (Some y0) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
rewrite (Neqb_complete _ _ H0).
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a0 a) true
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (Some y0) (MapGet A (MapPut A (Map_of_alist l0) a y0) a)
+++++
rewrite (MapPut_semantics A (Map_of_alist l0) a y0 a).
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (MapPut_semantics A (Map_of_alist l0) a y0 a).

*****
H0 : eq (N.eqb a0 a) true
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (Some y0) (if N.eqb a a then Some y0 else MapGet A (Map_of_alist l0) a)
+++++
rewrite (Neqb_correct a).
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.
rewrite (Neqb_complete _ _ H0).
rewrite (MapPut_semantics A (Map_of_alist l0) a y0 a).
rewrite (Neqb_correct a).

*****
H0 : eq (N.eqb a0 a) true
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (Some y0) (Some y0)
+++++
reflexivity.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).

*****
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
forall _ : eq (N.eqb a0 a) false, eq (if N.eqb a0 a then Some y0 else alist_semantics l0 a) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
intro H0.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.

*****
H0 : eq (N.eqb a0 a) false
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (if N.eqb a0 a then Some y0 else alist_semantics l0 a) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
rewrite H0.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a0 a) false
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics l0 a) (MapGet A (MapPut A (Map_of_alist l0) a0 y0) a)
+++++
rewrite (MapPut_semantics A (Map_of_alist l0) a0 y0 a).
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.
rewrite (MapPut_semantics A (Map_of_alist l0) a0 y0 a).

*****
H0 : eq (N.eqb a0 a) false
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics l0 a) (if N.eqb a0 a then Some y0 else MapGet A (Map_of_alist l0) a)
+++++
rewrite H0.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.
intros r l0 H a.
elim r.
intros a0 y0.
simpl in |- *.
elim (sumbool_of_bool (Neqb a0 a)).
intro H0.
rewrite H0.
rewrite (MapPut_semantics A (Map_of_alist l0) a0 y0 a).
rewrite H0.

*****
H0 : eq (N.eqb a0 a) false
y0 : A
a,a0 : ad
H : forall a : ad, eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
l0 : list (prod ad A)
r : prod ad A
l : alist
B : Type
A : Type
*****
eq (alist_semantics l0 a) (MapGet A (Map_of_alist l0) a)
+++++
apply H.
-----
Lemma Map_of_alist_semantics : forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
Proof.
unfold eqm in |- *.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma Map_of_alist_of_Map :\n   forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.

*****
B : Type
A : Type
*****
forall m : Map A, eqmap A (Map_of_alist (alist_of_Map m)) m
+++++
Proof.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.

*****
B : Type
A : Type
*****
forall m : Map A, eqmap A (Map_of_alist (alist_of_Map m)) m
+++++
unfold eqmap in |- *.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.

*****
B : Type
A : Type
*****
forall m : Map A, eqm A (MapGet A (Map_of_alist (alist_of_Map m))) (MapGet A m)
+++++
intro.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.
intro.

*****
m : Map A
B : Type
A : Type
*****
eqm A (MapGet A (Map_of_alist (alist_of_Map m))) (MapGet A m)
+++++
apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.
intro.
apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).

*****
m : Map A
B : Type
A : Type
*****
eqm A (MapGet A (Map_of_alist (alist_of_Map m))) (alist_semantics (alist_of_Map m))
+++++
apply eqm_sym.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.
intro.
apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).
apply eqm_sym.

*****
m : Map A
B : Type
A : Type
*****
eqm A (alist_semantics (alist_of_Map m)) (MapGet A (Map_of_alist (alist_of_Map m)))
+++++
apply Map_of_alist_semantics.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.
intro.
apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).

*****
m : Map A
B : Type
A : Type
*****
eqm A (alist_semantics (alist_of_Map m)) (MapGet A m)
+++++
apply eqm_sym.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.
intro.
apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).
apply eqm_sym.

*****
m : Map A
B : Type
A : Type
*****
eqm A (MapGet A m) (alist_semantics (alist_of_Map m))
+++++
apply alist_of_Map_semantics.
-----
Lemma Map_of_alist_of_Map : forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
Proof.
unfold eqmap in |- *.
intro.
apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_of_alist :\n   forall l:alist,\n     eqm A (alist_semantics (alist_of_Map (Map_of_alist l)))\n       (alist_semantics l).
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).

*****
B : Type
A : Type
*****
forall l : alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l)
+++++
Proof.
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.

*****
B : Type
A : Type
*****
forall l : alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l)
+++++
intro.
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.
intro.

*****
l : alist
B : Type
A : Type
*****
eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l)
+++++
apply eqm_trans with (f' := MapGet A (Map_of_alist l)).
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.
intro.
apply eqm_trans with (f' := MapGet A (Map_of_alist l)).

*****
l : alist
B : Type
A : Type
*****
eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (MapGet A (Map_of_alist l))
+++++
apply eqm_sym.
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.
intro.
apply eqm_trans with (f' := MapGet A (Map_of_alist l)).
apply eqm_sym.

*****
l : alist
B : Type
A : Type
*****
eqm A (MapGet A (Map_of_alist l)) (alist_semantics (alist_of_Map (Map_of_alist l)))
+++++
apply alist_of_Map_semantics.
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.
intro.
apply eqm_trans with (f' := MapGet A (Map_of_alist l)).

*****
l : alist
B : Type
A : Type
*****
eqm A (MapGet A (Map_of_alist l)) (alist_semantics l)
+++++
apply eqm_sym.
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.
intro.
apply eqm_trans with (f' := MapGet A (Map_of_alist l)).
apply eqm_sym.

*****
l : alist
B : Type
A : Type
*****
eqm A (alist_semantics l) (MapGet A (Map_of_alist l))
+++++
apply Map_of_alist_semantics.
-----
Lemma alist_of_Map_of_alist : forall l:alist, eqm A (alist_semantics (alist_of_Map (Map_of_alist l))) (alist_semantics l).
Proof.
intro.
apply eqm_trans with (f' := MapGet A (Map_of_alist l)).

*****

*****

+++++
Qed.
-----
Lemma fold_right_aapp :\n   forall (M:Type) (neutral:M) (op:M -> M -> M),\n     (forall a b c:M, op (op a b) c = op a (op b c)) ->\n     (forall a:M, op neutral a = a) ->\n     forall (f:ad -> A -> M) (l l':alist),\n       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)\n         neutral (aapp l l') =\n       op\n         (fold_right\n            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral\n            l)\n         (fold_right\n            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral\n            l').
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').

*****
B : Type
A : Type
*****
forall (M : Type) (neutral : M) (op : forall (_ : M) (_ : M), M) (_ : forall a b c : M, eq (op (op a b) c) (op a (op b c))) (_ : forall a : M, eq (op neutral a) a) (f : forall (_ : ad) (_ : A), M) (l l' : alist), eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp l l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
Proof.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.

*****
B : Type
A : Type
*****
forall (M : Type) (neutral : M) (op : forall (_ : M) (_ : M), M) (_ : forall a b c : M, eq (op (op a b) c) (op a (op b c))) (_ : forall a : M, eq (op neutral a) a) (f : forall (_ : ad) (_ : A), M) (l l' : alist), eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp l l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
simple induction l.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.

*****
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall l' : alist, eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp nil l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral nil) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
simpl in |- *.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
simpl in |- *.

*****
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall l' : alist, eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l') (op neutral (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
intro.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
simpl in |- *.
intro.

*****
l,l' : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l') (op neutral (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
rewrite H0.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
simpl in |- *.
intro.
rewrite H0.

*****
l,l' : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l') (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l')
+++++
reflexivity.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.

*****
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall l' : alist, eq (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral (aapp l l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral l) (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral l'))) (l' : alist), eq (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral (aapp (cons a l) l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral (cons a l)) (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral l'))
+++++
intros r l0 H1 l'.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
intros r l0 H1 l'.

*****
l' : alist
H1 : forall l' : alist,\neq\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral (aapp l0 l'))\n (op\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l'))
l0 : list (prod ad A)
r : prod ad A
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp (cons r l0) l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (cons r l0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
elim r.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
intros r l0 H1 l'.
elim r.

*****
l' : alist
H1 : forall l' : alist,\neq\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral (aapp l0 l'))\n (op\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l'))
l0 : list (prod ad A)
r : prod ad A
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (a : ad) (b : A), eq (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral (aapp (cons (pair a b) l0) l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral (cons (pair a b) l0)) (fold_right (fun (r : prod ad A) (m : M) => let (a0, y) := r in op (f a0 y) m) neutral l'))
+++++
intros a y.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
intros r l0 H1 l'.
elim r.
intros a y.

*****
y : A
a : ad
l' : alist
H1 : forall l' : alist,\neq\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral (aapp l0 l'))\n (op\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l'))
l0 : list (prod ad A)
r : prod ad A
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp (cons (pair a y) l0) l')) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (cons (pair a y) l0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
simpl in |- *.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
intros r l0 H1 l'.
elim r.
intros a y.
simpl in |- *.

*****
y : A
a : ad
l' : alist
H1 : forall l' : alist,\neq\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral (aapp l0 l'))\n (op\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l'))
l0 : list (prod ad A)
r : prod ad A
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (f a y) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp l0 l'))) (op (op (f a y) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))
+++++
rewrite H.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
intros r l0 H1 l'.
elim r.
intros a y.
simpl in |- *.
rewrite H.

*****
y : A
a : ad
l' : alist
H1 : forall l' : alist,\neq\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral (aapp l0 l'))\n (op\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l'))
l0 : list (prod ad A)
r : prod ad A
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (f a y) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp l0 l'))) (op (f a y) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l0) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l')))
+++++
rewrite (H1 l').
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.
intros r l0 H1 l'.
elim r.
intros a y.
simpl in |- *.
rewrite H.
rewrite (H1 l').

*****
y : A
a : ad
l' : alist
H1 : forall l' : alist,\neq\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral (aapp l0 l'))\n (op\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral l'))
l0 : list (prod ad A)
r : prod ad A
l : alist
f : forall (_ : ad) (_ : A), M
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (f a y) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l0) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l'))) (op (f a y) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l0) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral l')))
+++++
reflexivity.
-----
Lemma fold_right_aapp : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> forall (f:ad -> A -> M) (l l':alist), fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (aapp l l') = op (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l) (fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral l').
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma MapFold_as_fold_1 :\n   forall (M:Type) (neutral:M) (op:M -> M -> M),\n     (forall a b c:M, op (op a b) c = op a (op b c)) ->\n     (forall a:M, op neutral a = a) ->\n     (forall a:M, op a neutral = a) ->\n     forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad),\n       MapFold1 M neutral op f pf m =\n       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)\n         neutral\n         (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf\n            m).
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).

*****
B : Type
A : Type
*****
forall (M : Type) (neutral : M) (op : forall (_ : M) (_ : M), M) (_ : forall a b c : M, eq (op (op a b) c) (op a (op b c))) (_ : forall a : M, eq (op neutral a) a) (_ : forall a : M, eq (op a neutral) a) (f : forall (_ : ad) (_ : A), M) (m : Map A) (pf : forall _ : ad, ad), eq (MapFold1 M neutral op f pf m) (fold_right (fun (r : prod ad A) (m0 : M) => let (a, y) := r in op (f a y) m0) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf m))
+++++
Proof.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.

*****
B : Type
A : Type
*****
forall (M : Type) (neutral : M) (op : forall (_ : M) (_ : M), M) (_ : forall a b c : M, eq (op (op a b) c) (op a (op b c))) (_ : forall a : M, eq (op neutral a) a) (_ : forall a : M, eq (op a neutral) a) (f : forall (_ : ad) (_ : A), M) (m : Map A) (pf : forall _ : ad, ad), eq (MapFold1 M neutral op f pf m) (fold_right (fun (r : prod ad A) (m0 : M) => let (a, y) := r in op (f a y) m0) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf m))
+++++
simple induction m.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall pf : forall _ : ad, ad, eq (MapFold1 M neutral op f pf (M0 A)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf (M0 A)))
+++++
trivial.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad), eq (MapFold1 M neutral op f pf (M1 A a a0)) (fold_right (fun (r : prod ad A) (m : M) => let (a1, y) := r in op (f a1 y) m) neutral (MapFold1 alist anil aapp (fun (a1 : ad) (y : A) => acons (pair a1 y) anil) pf (M1 A a a0)))
+++++
intros.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (MapFold1 M neutral op f pf (M1 A a a0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf (M1 A a a0)))
+++++
simpl in |- *.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (f (pf a) a0) (op (f (pf a) a0) neutral)
+++++
rewrite H1.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite H1.

*****
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (f (pf a) a0) (f (pf a) a0)
+++++
reflexivity.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 M neutral op f pf m) (fold_right (fun (r : prod ad A) (m0 : M) => let (a, y) := r in op (f a y) m0) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf m))) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 M neutral op f pf m0) (fold_right (fun (r : prod ad A) (m1 : M) => let (a, y) := r in op (f a y) m1) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf m0))) (pf : forall _ : ad, ad), eq (MapFold1 M neutral op f pf (M2 A m m0)) (fold_right (fun (r : prod ad A) (m1 : M) => let (a, y) := r in op (f a y) m1) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf (M2 A m m0)))
+++++
intros.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m1)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m1))
m1 : Map A
H2 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (MapFold1 M neutral op f pf (M2 A m0 m1)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) pf (M2 A m0 m1)))
+++++
simpl in |- *.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m1)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m1))
m1 : Map A
H2 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (MapFold1 M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (aapp (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite (fold_right_aapp M neutral op H H0 f).
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (fold_right_aapp M neutral op H H0 f).

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m1)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m1))
m1 : Map A
H2 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (MapFold1 M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.double a0)) m0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite (H2 (fun a0:ad => pf (Ndouble a0))).
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (fold_right_aapp M neutral op H H0 f).
rewrite (H2 (fun a0:ad => pf (Ndouble a0))).

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m1)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m1))
m1 : Map A
H2 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.double a0)) m0)) (MapFold1 M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.double a0)) m0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite (H3 (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (fold_right_aapp M neutral op H H0 f).
rewrite (H2 (fun a0:ad => pf (Ndouble a0))).
rewrite (H3 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
pf : forall _ : ad, ad
H3 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m1)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m1))
m1 : Map A
H2 : forall pf : forall _ : ad, ad,\neq (MapFold1 M neutral op f pf m0)\n (fold_right\n (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m)\n neutral\n (MapFold1 alist anil aapp\n (fun (a : ad) (y : A) => acons (pair a y) anil) pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.double a0)) m0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1))) (op (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.double a0)) m0)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a : ad) (y : A) => acons (pair a y) anil) (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
reflexivity.
-----
Lemma MapFold_as_fold_1 : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad), MapFold1 M neutral op f pf m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_as_fold :\n   forall (M:Type) (neutral:M) (op:M -> M -> M),\n     (forall a b c:M, op (op a b) c = op a (op b c)) ->\n     (forall a:M, op neutral a = a) ->\n     (forall a:M, op a neutral = a) ->\n     forall (f:ad -> A -> M) (m:Map A),\n       MapFold M neutral op f m =\n       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)\n         neutral (alist_of_Map m).
-----
Lemma MapFold_as_fold : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A), MapFold M neutral op f m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map m).

*****
B : Type
A : Type
*****
forall (M : Type) (neutral : M) (op : forall (_ : M) (_ : M), M) (_ : forall a b c : M, eq (op (op a b) c) (op a (op b c))) (_ : forall a : M, eq (op neutral a) a) (_ : forall a : M, eq (op a neutral) a) (f : forall (_ : ad) (_ : A), M) (m : Map A), eq (MapFold M neutral op f m) (fold_right (fun (r : prod ad A) (m0 : M) => let (a, y) := r in op (f a y) m0) neutral (alist_of_Map m))
+++++
Proof.
-----
Lemma MapFold_as_fold : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A), MapFold M neutral op f m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map m).
Proof.

*****
B : Type
A : Type
*****
forall (M : Type) (neutral : M) (op : forall (_ : M) (_ : M), M) (_ : forall a b c : M, eq (op (op a b) c) (op a (op b c))) (_ : forall a : M, eq (op neutral a) a) (_ : forall a : M, eq (op a neutral) a) (f : forall (_ : ad) (_ : A), M) (m : Map A), eq (MapFold M neutral op f m) (fold_right (fun (r : prod ad A) (m0 : M) => let (a, y) := r in op (f a y) m0) neutral (alist_of_Map m))
+++++
intros.
-----
Lemma MapFold_as_fold : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A), MapFold M neutral op f m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map m).
Proof.
intros.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
H1 : forall a : M, eq (op a neutral) a
H0 : forall a : M, eq (op neutral a) a
H : forall a b c : M, eq (op (op a b) c) (op a (op b c))
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
B : Type
A : Type
*****
eq (MapFold M neutral op f m) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map m))
+++++
exact (MapFold_as_fold_1 M neutral op H H0 H1 f m (fun a0:ad => a0)).
-----
Lemma MapFold_as_fold : forall (M:Type) (neutral:M) (op:M -> M -> M), (forall a b c:M, op (op a b) c = op a (op b c)) -> (forall a:M, op neutral a = a) -> (forall a:M, op a neutral = a) -> forall (f:ad -> A -> M) (m:Map A), MapFold M neutral op f m = fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map m).
Proof.
intros.
exact (MapFold_as_fold_1 M neutral op H H0 H1 f m (fun a0:ad => a0)).

*****

*****

+++++
Qed.
-----
Lemma alist_MapMerge_semantics :\n   forall m m':Map A,\n     eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)))\n       (alist_semantics (alist_of_Map (MapMerge A m m'))).
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).

*****
B : Type
A : Type
*****
forall m m' : Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m')))
+++++
Proof.
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.

*****
B : Type
A : Type
*****
forall m m' : Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m')))
+++++
unfold eqm in |- *.
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.

*****
B : Type
A : Type
*****
forall (m m' : Map A) (a : ad), eq (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)) a) (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
intros.
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
m,m' : Map A
B : Type
A : Type
*****
eq (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)) a) (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite alist_semantics_app.
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.

*****
a : ad
m,m' : Map A
B : Type
A : Type
*****
eq match alist_semantics (alist_of_Map m') a with | Some y => Some y | None => alist_semantics (alist_of_Map m) a end (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite <- (alist_of_Map_semantics m a).
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).

*****
a : ad
m,m' : Map A
B : Type
A : Type
*****
eq match alist_semantics (alist_of_Map m') a with | Some y => Some y | None => MapGet A m a end (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite <- (alist_of_Map_semantics m' a).
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).

*****
a : ad
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m' a with | Some y => Some y | None => MapGet A m a end (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).

*****
a : ad
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m' a with | Some y => Some y | None => MapGet A m a end (MapGet A (MapMerge A m m') a)
+++++
rewrite (MapMerge_semantics A m m' a).
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).

*****
a : ad
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m' a with | Some y => Some y | None => MapGet A m a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
reflexivity.
-----
Lemma alist_MapMerge_semantics : forall m m':Map A, eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma alist_MapMerge_semantics_disjoint :\n   forall m m':Map A,\n     eqmap A (MapDomRestrTo A A m m') (M0 A) ->\n     eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')))\n       (alist_semantics (alist_of_Map (MapMerge A m m'))).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).

*****
B : Type
A : Type
*****
forall (m m' : Map A) (_ : eqmap A (MapDomRestrTo A A m m') (M0 A)), eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m')))
+++++
Proof.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.

*****
B : Type
A : Type
*****
forall (m m' : Map A) (_ : eqmap A (MapDomRestrTo A A m m') (M0 A)), eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m')))
+++++
unfold eqm in |- *.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.

*****
B : Type
A : Type
*****
forall (m m' : Map A) (_ : eqmap A (MapDomRestrTo A A m m') (M0 A)) (a : ad), eq (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')) a) (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
intros.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')) a) (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite alist_semantics_app.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match alist_semantics (alist_of_Map m) a with | Some y => Some y | None => alist_semantics (alist_of_Map m') a end (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite <- (alist_of_Map_semantics m a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => alist_semantics (alist_of_Map m') a end (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite <- (alist_of_Map_semantics m' a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end (alist_semantics (alist_of_Map (MapMerge A m m')) a)
+++++
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end (MapGet A (MapMerge A m m') a)
+++++
rewrite (MapMerge_semantics A m m' a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
intro H0.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.

*****
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
elim H0.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.

*****
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
intros y H1.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
rewrite H1.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
elim (option_sum _ (MapGet A m' a)).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m' a) (Some y)), eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
intro H2.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.

*****
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
elim H2.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.

*****
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall (x : A) (_ : eq (MapGet A m' a) (Some x)), eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
intros y' H3.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.

*****
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
cut (MapGet A (MapDomRestrTo A A m m') a = None).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.
cut (MapGet A (MapDomRestrTo A A m m') a = None).

*****
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : eq (MapGet A (MapDomRestrTo A A m m') a) None, eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
rewrite (MapDomRestrTo_semantics A A m m' a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.
cut (MapGet A (MapDomRestrTo A A m m') a = None).
rewrite (MapDomRestrTo_semantics A A m m' a).

*****
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : eq match MapGet A m' a with | Some _ => MapGet A m a | None => None end None, eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
rewrite H3.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.
cut (MapGet A (MapDomRestrTo A A m m') a = None).
rewrite (MapDomRestrTo_semantics A A m m' a).
rewrite H3.

*****
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : eq (MapGet A m a) None, eq (Some y) (Some y')
+++++
rewrite H1.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.
cut (MapGet A (MapDomRestrTo A A m m') a = None).
rewrite (MapDomRestrTo_semantics A A m m' a).
rewrite H3.
rewrite H1.

*****
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : eq (Some y) None, eq (Some y) (Some y')
+++++
intro.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.
cut (MapGet A (MapDomRestrTo A A m m') a = None).
rewrite (MapDomRestrTo_semantics A A m m' a).
rewrite H3.
rewrite H1.
intro.

*****
H4 : eq (Some y) None
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (Some y) (Some y')
+++++
discriminate H4.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
elim H2.
intros y' H3.
cut (MapGet A (MapDomRestrTo A A m m') a = None).

*****
H3 : eq (MapGet A m' a) (Some y')
y' : A
H2 : sig (fun y : A => eq (MapGet A m' a) (Some y))
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (MapGet A (MapDomRestrTo A A m m') a) None
+++++
exact (H a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : eq (MapGet A m' a) None, eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
intro H2.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.

*****
H2 : eq (MapGet A m' a) None
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (Some y) match MapGet A m' a with | Some y' => Some y' | None => Some y end
+++++
rewrite H2.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
elim H0.
intros y H1.
rewrite H1.
elim (option_sum _ (MapGet A m' a)).
intro H2.
rewrite H2.

*****
H2 : eq (MapGet A m' a) None
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : sig (fun y : A => eq (MapGet A m a) (Some y))
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).

*****
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall _ : eq (MapGet A m a) None, eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
intro H0.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.

*****
H0 : eq (MapGet A m a) None
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq match MapGet A m a with | Some y => Some y | None => MapGet A m' a end match MapGet A m' a with | Some y' => Some y' | None => MapGet A m a end
+++++
rewrite H0.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
rewrite H0.

*****
H0 : eq (MapGet A m a) None
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq (MapGet A m' a) match MapGet A m' a with | Some y' => Some y' | None => None end
+++++
case (MapGet A m' a).
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
rewrite H0.
case (MapGet A m' a).

*****
H0 : eq (MapGet A m a) None
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
forall a : A, eq (Some a) (Some a)
+++++
trivial.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).
intro H0.
rewrite H0.
case (MapGet A m' a).

*****
H0 : eq (MapGet A m a) None
a : ad
H : eqmap A (MapDomRestrTo A A m m') (M0 A)
m,m' : Map A
B : Type
A : Type
*****
eq None None
+++++
trivial.
-----
Lemma alist_MapMerge_semantics_disjoint : forall m m':Map A, eqmap A (MapDomRestrTo A A m m') (M0 A) -> eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m'))) (alist_semantics (alist_of_Map (MapMerge A m m'))).
Proof.
unfold eqm in |- *.
intros.
rewrite alist_semantics_app.
rewrite <- (alist_of_Map_semantics m a).
rewrite <- (alist_of_Map_semantics m' a).
rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
rewrite (MapMerge_semantics A m m' a).
elim (option_sum _ (MapGet A m a)).

*****

*****

+++++
Qed.
-----
Lemma alist_semantics_disjoint_comm :\n   forall l l':alist,\n     eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) ->\n     eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).

*****
B : Type
A : Type
*****
forall (l l' : alist) (_ : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)), eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l))
+++++
Proof.
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.

*****
B : Type
A : Type
*****
forall (l l' : alist) (_ : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)), eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l))
+++++
unfold eqm in |- *.
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.

*****
B : Type
A : Type
*****
forall (l l' : alist) (_ : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)) (a : ad), eq (alist_semantics (aapp l l') a) (alist_semantics (aapp l' l) a)
+++++
intros.
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq (alist_semantics (aapp l l') a) (alist_semantics (aapp l' l) a)
+++++
rewrite (alist_semantics_app l l' a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq match alist_semantics l a with | Some y => Some y | None => alist_semantics l' a end (alist_semantics (aapp l' l) a)
+++++
rewrite (alist_semantics_app l' l a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq match alist_semantics l a with | Some y => Some y | None => alist_semantics l' a end match alist_semantics l' a with | Some y => Some y | None => alist_semantics l a end
+++++
rewrite <- (alist_of_Map_of_alist l a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq match alist_semantics (alist_of_Map (Map_of_alist l)) a with | Some y => Some y | None => alist_semantics l' a end match alist_semantics l' a with | Some y => Some y | None => alist_semantics (alist_of_Map (Map_of_alist l)) a end
+++++
rewrite <- (alist_of_Map_of_alist l' a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).
rewrite <- (alist_of_Map_of_alist l' a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq match alist_semantics (alist_of_Map (Map_of_alist l)) a with | Some y => Some y | None => alist_semantics (alist_of_Map (Map_of_alist l')) a end match alist_semantics (alist_of_Map (Map_of_alist l')) a with | Some y => Some y | None => alist_semantics (alist_of_Map (Map_of_alist l)) a end
+++++
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l')) a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).
rewrite <- (alist_of_Map_of_alist l' a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l')) a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq (alist_semantics (aapp (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l'))) a) match alist_semantics (alist_of_Map (Map_of_alist l')) a with | Some y => Some y | None => alist_semantics (alist_of_Map (Map_of_alist l)) a end
+++++
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l')) (alist_of_Map (Map_of_alist l)) a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).
rewrite <- (alist_of_Map_of_alist l' a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l')) a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l')) (alist_of_Map (Map_of_alist l)) a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq (alist_semantics (aapp (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l'))) a) (alist_semantics (aapp (alist_of_Map (Map_of_alist l')) (alist_of_Map (Map_of_alist l))) a)
+++++
rewrite (alist_MapMerge_semantics (Map_of_alist l) (Map_of_alist l') a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).
rewrite <- (alist_of_Map_of_alist l' a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l')) a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l')) (alist_of_Map (Map_of_alist l)) a).
rewrite (alist_MapMerge_semantics (Map_of_alist l) (Map_of_alist l') a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq (alist_semantics (aapp (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l'))) a) (alist_semantics (alist_of_Map (MapMerge A (Map_of_alist l) (Map_of_alist l'))) a)
+++++
rewrite (alist_MapMerge_semantics_disjoint (Map_of_alist l) ( Map_of_alist l') H a).
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).
rewrite <- (alist_of_Map_of_alist l' a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l')) a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l')) (alist_of_Map (Map_of_alist l)) a).
rewrite (alist_MapMerge_semantics (Map_of_alist l) (Map_of_alist l') a).
rewrite (alist_MapMerge_semantics_disjoint (Map_of_alist l) ( Map_of_alist l') H a).

*****
a : ad
H : eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A)
l,l' : alist
B : Type
A : Type
*****
eq (alist_semantics (alist_of_Map (MapMerge A (Map_of_alist l) (Map_of_alist l'))) a) (alist_semantics (alist_of_Map (MapMerge A (Map_of_alist l) (Map_of_alist l'))) a)
+++++
reflexivity.
-----
Lemma alist_semantics_disjoint_comm : forall l l':alist, eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) -> eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_app l l' a).
rewrite (alist_semantics_app l' l a).
rewrite <- (alist_of_Map_of_alist l a).
rewrite <- (alist_of_Map_of_alist l' a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l)) (alist_of_Map (Map_of_alist l')) a).
rewrite <- (alist_semantics_app (alist_of_Map (Map_of_alist l')) (alist_of_Map (Map_of_alist l)) a).
rewrite (alist_MapMerge_semantics (Map_of_alist l) (Map_of_alist l') a).
rewrite (alist_MapMerge_semantics_disjoint (Map_of_alist l) ( Map_of_alist l') H a).
reflexivity.

*****

*****

+++++
Qed.
-----
End MapIter.
-----
