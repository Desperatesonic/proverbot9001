Require Import Coq.Lists.List.
-----
Set Implicit Arguments.
-----
Set Strict Implicit.
-----
Section parametric.
-----
Variable T : Type.
-----
Lemma nth_error_app_L : forall (A B : list T) n,\n    n < length A ->\n    nth_error (A ++ B) n = nth_error A n.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.

*****
T : Type
*****
forall (A B : list T) (n : nat) (_ : lt n (length A)), eq (nth_error (app A B) n) (nth_error A n)
+++++
Proof.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.

*****
T : Type
*****
forall (A B : list T) (n : nat) (_ : lt n (length A)), eq (nth_error (app A B) n) (nth_error A n)
+++++
induction A.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.

*****
T : Type
*****
forall (B : list T) (n : nat) (_ : lt n (length nil)), eq (nth_error (app nil B) n) (nth_error nil n)
+++++
destruct n.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.

*****
B : list T
T : Type
*****
forall _ : lt O (length nil), eq (nth_error (app nil B) O) (nth_error nil O)
+++++
simpl.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.

*****
B : list T
T : Type
*****
forall _ : lt O O, eq match B with | nil => None | cons x _ => Some x end None
+++++
intros.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : lt O O
B : list T
T : Type
*****
eq match B with | nil => None | cons x _ => Some x end None
+++++
auto.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.
auto.

*****
H : lt O O
B : list T
T : Type
*****
eq match B with | nil => None | cons x _ => Some x end None
+++++
inversion H.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.

*****
n : nat
B : list T
T : Type
*****
forall _ : lt (S n) (length nil), eq (nth_error (app nil B) (S n)) (nth_error nil (S n))
+++++
simpl.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.

*****
n : nat
B : list T
T : Type
*****
forall _ : lt (S n) O, eq match B with | nil => None | cons _ l => nth_error l n end None
+++++
intros.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : lt (S n) O
n : nat
B : list T
T : Type
*****
eq match B with | nil => None | cons _ l => nth_error l n end None
+++++
auto.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.
auto.

*****
H : lt (S n) O
n : nat
B : list T
T : Type
*****
eq match B with | nil => None | cons _ l => nth_error l n end None
+++++
inversion H.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.

*****
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
forall (B : list T) (n : nat) (_ : lt n (length (cons a A))), eq (nth_error (app (cons a A) B) n) (nth_error (cons a A) n)
+++++
destruct n.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.

*****
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
forall _ : lt O (length (cons a A)), eq (nth_error (app (cons a A) B) O) (nth_error (cons a A) O)
+++++
simpl.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.

*****
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
forall _ : lt O (S (length A)), eq (Some a) (Some a)
+++++
intros.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : lt O (S (length A))
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
eq (Some a) (Some a)
+++++
auto.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.

*****
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
forall _ : lt (S n) (length (cons a A)), eq (nth_error (app (cons a A) B) (S n)) (nth_error (cons a A) (S n))
+++++
simpl.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.

*****
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
forall _ : lt (S n) (S (length A)), eq (nth_error (app A B) n) (nth_error A n)
+++++
intros.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : lt (S n) (S (length A))
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
eq (nth_error (app A B) n) (nth_error A n)
+++++
auto.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.
auto.

*****
H : lt (S n) (S (length A))
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
eq (nth_error (app A B) n) (nth_error A n)
+++++
eapply IHA.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.
auto.
eapply IHA.

*****
H : lt (S n) (S (length A))
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
lt n (length A)
+++++
apply Lt.lt_S_n.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.
destruct n.
simpl.
intros.
auto.
eapply IHA.
apply Lt.lt_S_n.

*****
H : lt (S n) (S (length A))
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : lt n (length A)),\neq (nth_error (app A B) n) (nth_error A n)
A : list T
a : T
T : Type
*****
lt (S n) (S (length A))
+++++
assumption.
-----
Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n.
Proof.
induction A.

*****

*****

+++++
Qed.
-----
Lemma nth_error_app_R : forall (A B : list T) n,\n    length A <= n ->\n    nth_error (A ++ B) n = nth_error B (n - length A).
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).

*****
T : Type
*****
forall (A B : list T) (n : nat) (_ : le (length A) n), eq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
+++++
Proof.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.

*****
T : Type
*****
forall (A B : list T) (n : nat) (_ : le (length A) n), eq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
+++++
induction A.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.

*****
T : Type
*****
forall (B : list T) (n : nat) (_ : le (length nil) n), eq (nth_error (app nil B) n) (nth_error B (Nat.sub n (length nil)))
+++++
destruct n.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.

*****
B : list T
T : Type
*****
forall _ : le (length nil) O, eq (nth_error (app nil B) O) (nth_error B (Nat.sub O (length nil)))
+++++
simpl.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.

*****
B : list T
T : Type
*****
forall _ : le O O, eq match B with | nil => None | cons x _ => Some x end match B with | nil => None | cons x _ => Some x end
+++++
intros.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : le O O
B : list T
T : Type
*****
eq match B with | nil => None | cons x _ => Some x end match B with | nil => None | cons x _ => Some x end
+++++
auto.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.

*****
n : nat
B : list T
T : Type
*****
forall _ : le (length nil) (S n), eq (nth_error (app nil B) (S n)) (nth_error B (Nat.sub (S n) (length nil)))
+++++
simpl.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.

*****
n : nat
B : list T
T : Type
*****
forall _ : le O (S n), eq match B with | nil => None | cons _ l => nth_error l n end match B with | nil => None | cons _ l => nth_error l n end
+++++
intros.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : le O (S n)
n : nat
B : list T
T : Type
*****
eq match B with | nil => None | cons _ l => nth_error l n end match B with | nil => None | cons _ l => nth_error l n end
+++++
auto.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.

*****
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
forall (B : list T) (n : nat) (_ : le (length (cons a A)) n), eq (nth_error (app (cons a A) B) n) (nth_error B (Nat.sub n (length (cons a A))))
+++++
destruct n.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.

*****
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
forall _ : le (length (cons a A)) O, eq (nth_error (app (cons a A) B) O) (nth_error B (Nat.sub O (length (cons a A))))
+++++
simpl.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.

*****
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
forall _ : le (S (length A)) O, eq (Some a) match B with | nil => None | cons x _ => Some x end
+++++
intros.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : le (S (length A)) O
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
eq (Some a) match B with | nil => None | cons x _ => Some x end
+++++
auto.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.
auto.

*****
H : le (S (length A)) O
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
eq (Some a) match B with | nil => None | cons x _ => Some x end
+++++
inversion H.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.

*****
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
forall _ : le (length (cons a A)) (S n), eq (nth_error (app (cons a A) B) (S n)) (nth_error B (Nat.sub (S n) (length (cons a A))))
+++++
simpl.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.

*****
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
forall _ : le (S (length A)) (S n), eq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
+++++
intros.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.

*****
H : le (S (length A)) (S n)
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
eq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
+++++
auto.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.
auto.

*****
H : le (S (length A)) (S n)
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
eq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
+++++
apply IHA.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.
auto.
apply IHA.

*****
H : le (S (length A)) (S n)
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
le (length A) n
+++++
apply Le.le_S_n.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.
destruct n.
simpl.
intros.
auto.
apply IHA.
apply Le.le_S_n.

*****
H : le (S (length A)) (S n)
n : nat
B : list T
IHA : forall (B : list T) (n : nat) (_ : le (length A) n),\neq (nth_error (app A B) n) (nth_error B (Nat.sub n (length A)))
A : list T
a : T
T : Type
*****
le (S (length A)) (S n)
+++++
assumption.
-----
Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A).
Proof.
induction A.

*****

*****

+++++
Qed.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v,\n    nth_error ls n = Some v ->\n    nth_error (ls ++ ls') n = Some v.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.

*****
T : Type
*****
forall (ls' ls : list T) (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)), eq (nth_error (app ls ls') n) (Some v)
+++++
Proof.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.

*****
T : Type
*****
forall (ls' ls : list T) (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)), eq (nth_error (app ls ls') n) (Some v)
+++++
clear.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.

*****
T : Type
*****
forall (ls' ls : list T) (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)), eq (nth_error (app ls ls') n) (Some v)
+++++
induction ls.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.

*****
ls' : list T
T : Type
*****
forall (n : nat) (v : T) (_ : eq (nth_error nil n) (Some v)), eq (nth_error (app nil ls') n) (Some v)
+++++
destruct n.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.

*****
ls' : list T
T : Type
*****
forall (v : T) (_ : eq (nth_error nil O) (Some v)), eq (nth_error (app nil ls') O) (Some v)
+++++
simpl.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
ls' : list T
T : Type
*****
forall (v : T) (_ : eq None (Some v)), eq match ls' with | nil => None | cons x _ => Some x end (Some v)
+++++
intros.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq None (Some v)
v : T
ls' : list T
T : Type
*****
eq match ls' with | nil => None | cons x _ => Some x end (Some v)
+++++
unfold value in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.

*****
H : eq None (Some v)
v : T
ls' : list T
T : Type
*****
eq match ls' with | nil => None | cons x _ => Some x end (Some v)
+++++
unfold error in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.
unfold error in *.

*****
H : eq None (Some v)
v : T
ls' : list T
T : Type
*****
eq match ls' with | nil => None | cons x _ => Some x end (Some v)
+++++
try congruence.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.

*****
n : nat
ls' : list T
T : Type
*****
forall (v : T) (_ : eq (nth_error nil (S n)) (Some v)), eq (nth_error (app nil ls') (S n)) (Some v)
+++++
simpl.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
n : nat
ls' : list T
T : Type
*****
forall (v : T) (_ : eq None (Some v)), eq match ls' with | nil => None | cons _ l => nth_error l n end (Some v)
+++++
intros.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq None (Some v)
v : T
n : nat
ls' : list T
T : Type
*****
eq match ls' with | nil => None | cons _ l => nth_error l n end (Some v)
+++++
unfold value in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.

*****
H : eq None (Some v)
v : T
n : nat
ls' : list T
T : Type
*****
eq match ls' with | nil => None | cons _ l => nth_error l n end (Some v)
+++++
unfold error in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.
unfold error in *.

*****
H : eq None (Some v)
v : T
n : nat
ls' : list T
T : Type
*****
eq match ls' with | nil => None | cons _ l => nth_error l n end (Some v)
+++++
try congruence.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.

*****
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
forall (n : nat) (v : T) (_ : eq (nth_error (cons a ls) n) (Some v)), eq (nth_error (app (cons a ls) ls') n) (Some v)
+++++
destruct n.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.

*****
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
forall (v : T) (_ : eq (nth_error (cons a ls) O) (Some v)), eq (nth_error (app (cons a ls) ls') O) (Some v)
+++++
simpl.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
forall (v : T) (_ : eq (Some a) (Some v)), eq (Some a) (Some v)
+++++
intros.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq (Some a) (Some v)
v : T
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (Some a) (Some v)
+++++
unfold value in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.

*****
H : eq (Some a) (Some v)
v : T
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (Some a) (Some v)
+++++
unfold error in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.
unfold error in *.

*****
H : eq (Some a) (Some v)
v : T
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (Some a) (Some v)
+++++
try congruence.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.

*****
n : nat
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
forall (v : T) (_ : eq (nth_error (cons a ls) (S n)) (Some v)), eq (nth_error (app (cons a ls) ls') (S n)) (Some v)
+++++
simpl.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
n : nat
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
forall (v : T) (_ : eq (nth_error ls n) (Some v)), eq (nth_error (app ls ls') n) (Some v)
+++++
intros.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq (nth_error ls n) (Some v)
v : T
n : nat
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (nth_error (app ls ls') n) (Some v)
+++++
unfold value in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.

*****
H : eq (nth_error ls n) (Some v)
v : T
n : nat
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (nth_error (app ls ls') n) (Some v)
+++++
unfold error in *.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.
unfold error in *.

*****
H : eq (nth_error ls n) (Some v)
v : T
n : nat
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (nth_error (app ls ls') n) (Some v)
+++++
try congruence.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
unfold value in *.
unfold error in *.
try congruence.

*****
H : eq (nth_error ls n) (Some v)
v : T
n : nat
IHls : forall (n : nat) (v : T) (_ : eq (nth_error ls n) (Some v)),\neq (nth_error (app ls ls') n) (Some v)
ls : list T
a : T
ls' : list T
T : Type
*****
eq (nth_error (app ls ls') n) (Some v)
+++++
auto.
-----
Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v.
Proof.
clear.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma nth_error_nil : forall n,\n    nth_error nil n = @None T.
-----
Lemma nth_error_nil : forall n, nth_error nil n = @None T.

*****
T : Type
*****
forall n : nat, eq (nth_error nil n) None
+++++
Proof.
-----
Lemma nth_error_nil : forall n, nth_error nil n = @None T.
Proof.

*****
T : Type
*****
forall n : nat, eq (nth_error nil n) None
+++++
destruct n.
-----
Lemma nth_error_nil : forall n, nth_error nil n = @None T.
Proof.
destruct n.

*****
T : Type
*****
eq (nth_error nil O) None
+++++
reflexivity.
-----
Lemma nth_error_nil : forall n, nth_error nil n = @None T.
Proof.
destruct n.

*****
n : nat
T : Type
*****
eq (nth_error nil (S n)) None
+++++
reflexivity.
-----
Lemma nth_error_nil : forall n, nth_error nil n = @None T.
Proof.
destruct n.

*****

*****

+++++
Qed.
-----
Lemma nth_error_past_end : forall (ls : list T) n,\n    length ls <= n ->\n    nth_error ls n = None.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.

*****
T : Type
*****
forall (ls : list T) (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
+++++
Proof.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.

*****
T : Type
*****
forall (ls : list T) (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
+++++
clear.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.

*****
T : Type
*****
forall (ls : list T) (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
+++++
induction ls.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.

*****
T : Type
*****
forall (n : nat) (_ : le (length nil) n), eq (nth_error nil n) None
+++++
destruct n.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.

*****
T : Type
*****
forall _ : le (length nil) O, eq (nth_error nil O) None
+++++
simpl.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
T : Type
*****
forall _ : le O O, eq None None
+++++
intros.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : le O O
T : Type
*****
eq None None
+++++
auto.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.

*****
n : nat
T : Type
*****
forall _ : le (length nil) (S n), eq (nth_error nil (S n)) None
+++++
simpl.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
n : nat
T : Type
*****
forall _ : le O (S n), eq None None
+++++
intros.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : le O (S n)
n : nat
T : Type
*****
eq None None
+++++
auto.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.

*****
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
forall (n : nat) (_ : le (length (cons a ls)) n), eq (nth_error (cons a ls) n) None
+++++
destruct n.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.

*****
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
forall _ : le (length (cons a ls)) O, eq (nth_error (cons a ls) O) None
+++++
simpl.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
forall _ : le (S (length ls)) O, eq (Some a) None
+++++
intros.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : le (S (length ls)) O
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
eq (Some a) None
+++++
auto.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
auto.

*****
H : le (S (length ls)) O
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
eq (Some a) None
+++++
inversion H.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.

*****
n : nat
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
forall _ : le (length (cons a ls)) (S n), eq (nth_error (cons a ls) (S n)) None
+++++
simpl.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.

*****
n : nat
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
forall _ : le (S (length ls)) (S n), eq (nth_error ls n) None
+++++
intros.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.

*****
H : le (S (length ls)) (S n)
n : nat
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
eq (nth_error ls n) None
+++++
auto.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
auto.

*****
H : le (S (length ls)) (S n)
n : nat
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
eq (nth_error ls n) None
+++++
apply IHls.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
auto.
apply IHls.

*****
H : le (S (length ls)) (S n)
n : nat
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
le (length ls) n
+++++
apply Le.le_S_n.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.
destruct n.
simpl.
intros.
auto.
apply IHls.
apply Le.le_S_n.

*****
H : le (S (length ls)) (S n)
n : nat
IHls : forall (n : nat) (_ : le (length ls) n), eq (nth_error ls n) None
ls : list T
a : T
T : Type
*****
le (S (length ls)) (S n)
+++++
assumption.
-----
Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None.
Proof.
clear.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma nth_error_length : forall (ls ls' : list T) n,\n    nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.

*****
T : Type
*****
forall (ls ls' : list T) (n : nat), eq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
+++++
Proof.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.

*****
T : Type
*****
forall (ls ls' : list T) (n : nat), eq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
+++++
induction ls.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.

*****
T : Type
*****
forall (ls' : list T) (n : nat), eq (nth_error (app nil ls') (Nat.add n (length nil))) (nth_error ls' n)
+++++
simpl.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.

*****
T : Type
*****
forall (ls' : list T) (n : nat), eq (nth_error ls' (Nat.add n O)) (nth_error ls' n)
+++++
intros.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.
intros.

*****
n : nat
ls' : list T
T : Type
*****
eq (nth_error ls' (Nat.add n O)) (nth_error ls' n)
+++++
rewrite Plus.plus_0_r.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.
intros.
rewrite Plus.plus_0_r.

*****
n : nat
ls' : list T
T : Type
*****
eq (nth_error ls' n) (nth_error ls' n)
+++++
auto.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.

*****
IHls : forall (ls' : list T) (n : nat),\neq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
ls : list T
a : T
T : Type
*****
forall (ls' : list T) (n : nat), eq (nth_error (app (cons a ls) ls') (Nat.add n (length (cons a ls)))) (nth_error ls' n)
+++++
simpl.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.

*****
IHls : forall (ls' : list T) (n : nat),\neq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
ls : list T
a : T
T : Type
*****
forall (ls' : list T) (n : nat), eq (nth_error (cons a (app ls ls')) (Nat.add n (S (length ls)))) (nth_error ls' n)
+++++
intros.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.
intros.

*****
n : nat
ls' : list T
IHls : forall (ls' : list T) (n : nat),\neq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
ls : list T
a : T
T : Type
*****
eq (nth_error (cons a (app ls ls')) (Nat.add n (S (length ls)))) (nth_error ls' n)
+++++
rewrite <- Plus.plus_Snm_nSm.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.
intros.
rewrite <- Plus.plus_Snm_nSm.

*****
n : nat
ls' : list T
IHls : forall (ls' : list T) (n : nat),\neq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
ls : list T
a : T
T : Type
*****
eq (nth_error (cons a (app ls ls')) (Nat.add (S n) (length ls))) (nth_error ls' n)
+++++
simpl.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.
simpl.
intros.
rewrite <- Plus.plus_Snm_nSm.
simpl.

*****
n : nat
ls' : list T
IHls : forall (ls' : list T) (n : nat),\neq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
ls : list T
a : T
T : Type
*****
eq (nth_error (app ls ls') (Nat.add n (length ls))) (nth_error ls' n)
+++++
eapply IHls.
-----
Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n,\n    nth_error ls n = None -> length ls <= n.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.

*****
T : Type
*****
forall (T : Type) (ls : list T) (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
+++++
Proof.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.

*****
T : Type
*****
forall (T : Type) (ls : list T) (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
+++++
induction ls.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.

*****
T0 : Type
T : Type
*****
forall (n : nat) (_ : eq (nth_error nil n) None), le (length nil) n
+++++
destruct n.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.

*****
T0 : Type
T : Type
*****
forall _ : eq (nth_error nil O) None, le (length nil) O
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.

*****
T0 : Type
T : Type
*****
forall _ : eq None None, le O O
+++++
auto.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.

*****
n : nat
T0 : Type
T : Type
*****
forall _ : eq (nth_error nil (S n)) None, le (length nil) (S n)
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.

*****
n : nat
T0 : Type
T : Type
*****
forall _ : eq None None, le O (S n)
+++++
auto.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.

*****
n : nat
T0 : Type
T : Type
*****
forall _ : eq None None, le O (S n)
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.
simpl in *.

*****
n : nat
T0 : Type
T : Type
*****
forall _ : eq None None, le O (S n)
+++++
intro.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.
simpl in *.
intro.

*****
H : eq None None
n : nat
T0 : Type
T : Type
*****
le O (S n)
+++++
apply Le.le_0_n.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.

*****
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall (n : nat) (_ : eq (nth_error (cons a ls) n) None), le (length (cons a ls)) n
+++++
destruct n.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.

*****
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (nth_error (cons a ls) O) None, le (length (cons a ls)) O
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.

*****
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (Some a) None, le (S (length ls)) O
+++++
auto.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.

*****
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (Some a) None, le (S (length ls)) O
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.
simpl in *.

*****
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (Some a) None, le (S (length ls)) O
+++++
inversion 1.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.

*****
n : nat
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (nth_error (cons a ls) (S n)) None, le (length (cons a ls)) (S n)
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.

*****
n : nat
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (nth_error ls n) None, le (S (length ls)) (S n)
+++++
auto.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.

*****
n : nat
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (nth_error ls n) None, le (S (length ls)) (S n)
+++++
simpl in *.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.
simpl in *.

*****
n : nat
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall _ : eq (nth_error ls n) None, le (S (length ls)) (S n)
+++++
intros.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.
simpl in *.
intros.

*****
H : eq (nth_error ls n) None
n : nat
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
le (S (length ls)) (S n)
+++++
eapply Le.le_n_S.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.
destruct n.
simpl in *.
auto.
simpl in *.
intros.
eapply Le.le_n_S.

*****
H : eq (nth_error ls n) None
n : nat
IHls : forall (n : nat) (_ : eq (nth_error ls n) None), le (length ls) n
ls : list T0
a : T0
T0 : Type
T : Type
*****
le (length ls) n
+++++
auto.
-----
Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val,\n    nth_error ls n = Some val -> n < length ls.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.

*****
T : Type
*****
forall (T : Type) (ls : list T) (n : nat) (val : T) (_ : eq (nth_error ls n) (Some val)), lt n (length ls)
+++++
Proof.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.

*****
T : Type
*****
forall (T : Type) (ls : list T) (n : nat) (val : T) (_ : eq (nth_error ls n) (Some val)), lt n (length ls)
+++++
induction ls.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.

*****
T0 : Type
T : Type
*****
forall (n : nat) (val : T0) (_ : eq (nth_error nil n) (Some val)), lt n (length nil)
+++++
destruct n.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.

*****
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq (nth_error nil O) (Some val)), lt O (length nil)
+++++
simpl.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.

*****
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq None (Some val)), lt O O
+++++
intros.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq None (Some val)
val : T0
T0 : Type
T : Type
*****
lt O O
+++++
auto.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.
auto.

*****
H : eq None (Some val)
val : T0
T0 : Type
T : Type
*****
lt O O
+++++
inversion H.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.

*****
n : nat
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq (nth_error nil (S n)) (Some val)), lt (S n) (length nil)
+++++
simpl.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.

*****
n : nat
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq None (Some val)), lt (S n) O
+++++
intros.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq None (Some val)
val : T0
n : nat
T0 : Type
T : Type
*****
lt (S n) O
+++++
auto.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.
auto.

*****
H : eq None (Some val)
val : T0
n : nat
T0 : Type
T : Type
*****
lt (S n) O
+++++
inversion H.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.

*****
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall (n : nat) (val : T0) (_ : eq (nth_error (cons a ls) n) (Some val)), lt n (length (cons a ls))
+++++
destruct n.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.

*****
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq (nth_error (cons a ls) O) (Some val)), lt O (length (cons a ls))
+++++
simpl.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.

*****
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq (Some a) (Some val)), lt O (S (length ls))
+++++
intros.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq (Some a) (Some val)
val : T0
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
lt O (S (length ls))
+++++
auto.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.
auto.

*****
H : eq (Some a) (Some val)
val : T0
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
lt O (S (length ls))
+++++
apply Lt.lt_0_Sn.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.

*****
n : nat
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq (nth_error (cons a ls) (S n)) (Some val)), lt (S n) (length (cons a ls))
+++++
simpl.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.

*****
n : nat
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
forall (val : T0) (_ : eq (nth_error ls n) (Some val)), lt (S n) (S (length ls))
+++++
intros.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.

*****
H : eq (nth_error ls n) (Some val)
val : T0
n : nat
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
lt (S n) (S (length ls))
+++++
auto.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.
auto.

*****
H : eq (nth_error ls n) (Some val)
val : T0
n : nat
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
lt (S n) (S (length ls))
+++++
apply Lt.lt_n_S.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.
destruct n.
simpl.
intros.
auto.
apply Lt.lt_n_S.

*****
H : eq (nth_error ls n) (Some val)
val : T0
n : nat
IHls : forall (n : nat) (val : T0) (_ : eq (nth_error ls n) (Some val)),\nlt n (length ls)
ls : list T0
a : T0
T0 : Type
T : Type
*****
lt n (length ls)
+++++
eauto.
-----
Lemma nth_error_length_lt : forall {T} (ls : list T) n val, nth_error ls n = Some val -> n < length ls.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n,\n    nth_error (map f ls) n = match nth_error ls n with\n                               | None => None\n                               | Some x => Some (f x)\n                             end.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.

*****
T : Type
*****
forall (U : Type) (f : forall _ : T, U) (ls : list T) (n : nat), eq (nth_error (map f ls) n) match nth_error ls n with | Some x => Some (f x) | None => None end
+++++
Proof.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.

*****
T : Type
*****
forall (U : Type) (f : forall _ : T, U) (ls : list T) (n : nat), eq (nth_error (map f ls) n) match nth_error ls n with | Some x => Some (f x) | None => None end
+++++
induction ls.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.

*****
f : forall _ : T, U
U : Type
T : Type
*****
forall n : nat, eq (nth_error (map f nil) n) match nth_error nil n with | Some x => Some (f x) | None => None end
+++++
destruct n.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.

*****
f : forall _ : T, U
U : Type
T : Type
*****
eq (nth_error (map f nil) O) match nth_error nil O with | Some x => Some (f x) | None => None end
+++++
simpl.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.
simpl.

*****
f : forall _ : T, U
U : Type
T : Type
*****
eq None None
+++++
auto.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.

*****
n : nat
f : forall _ : T, U
U : Type
T : Type
*****
eq (nth_error (map f nil) (S n)) match nth_error nil (S n) with | Some x => Some (f x) | None => None end
+++++
simpl.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.
simpl.

*****
n : nat
f : forall _ : T, U
U : Type
T : Type
*****
eq None None
+++++
auto.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.

*****
IHls : forall n : nat,\neq (nth_error (map f ls) n)\n match nth_error ls n with\n | Some x => Some (f x)\n | None => None\n end
ls : list T
a : T
f : forall _ : T, U
U : Type
T : Type
*****
forall n : nat, eq (nth_error (map f (cons a ls)) n) match nth_error (cons a ls) n with | Some x => Some (f x) | None => None end
+++++
destruct n.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.

*****
IHls : forall n : nat,\neq (nth_error (map f ls) n)\n match nth_error ls n with\n | Some x => Some (f x)\n | None => None\n end
ls : list T
a : T
f : forall _ : T, U
U : Type
T : Type
*****
eq (nth_error (map f (cons a ls)) O) match nth_error (cons a ls) O with | Some x => Some (f x) | None => None end
+++++
simpl.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.
simpl.

*****
IHls : forall n : nat,\neq (nth_error (map f ls) n)\n match nth_error ls n with\n | Some x => Some (f x)\n | None => None\n end
ls : list T
a : T
f : forall _ : T, U
U : Type
T : Type
*****
eq (Some (f a)) (Some (f a))
+++++
auto.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.

*****
n : nat
IHls : forall n : nat,\neq (nth_error (map f ls) n)\n match nth_error ls n with\n | Some x => Some (f x)\n | None => None\n end
ls : list T
a : T
f : forall _ : T, U
U : Type
T : Type
*****
eq (nth_error (map f (cons a ls)) (S n)) match nth_error (cons a ls) (S n) with | Some x => Some (f x) | None => None end
+++++
simpl.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.
destruct n.
simpl.

*****
n : nat
IHls : forall n : nat,\neq (nth_error (map f ls) n)\n match nth_error ls n with\n | Some x => Some (f x)\n | None => None\n end
ls : list T
a : T
f : forall _ : T, U
U : Type
T : Type
*****
eq (nth_error (map f ls) n) match nth_error ls n with | Some x => Some (f x) | None => None end
+++++
auto.
-----
Theorem nth_error_map : forall U (f : T -> U) ls n, nth_error (map f ls) n = match nth_error ls n with | None => None | Some x => Some (f x) end.
Proof.
induction ls.

*****

*****

+++++
Qed.
-----
End parametric.
-----
