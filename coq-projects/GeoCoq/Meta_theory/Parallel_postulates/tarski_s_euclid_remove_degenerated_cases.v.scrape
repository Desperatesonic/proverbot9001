Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Ch05_bet_le.
-----
Section tarski_s_euclid_remove_degenerated_cases.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma tarski_s_euclid_remove_degenerated_cases :\n  (forall A B C D T,\n   A <> B ->\n   A <> C ->\n   A <> D ->\n   A <> T ->\n   B <> C ->\n   B <> D ->\n   B <> T ->\n   C <> D ->\n   C <> T ->\n   D <> T ->\n   ~ Col A B C ->\n   Bet A D T ->\n   Bet B D C ->\n   exists x y : Tpoint, Bet A B x /\ Bet A C y /\ Bet x T y) ->\n  forall A B C D T,\n  Bet A D T ->\n  Bet B D C ->\n  A <> D -> exists x y : Tpoint, Bet A B x /\ Bet A C y /\ Bet x T y.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : Bet B D C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))) (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
Proof.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : Bet B D C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))) (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HGC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.

*****
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros A B C D T HADT HBDC HAD.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.

*****
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points A B).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).

*****
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A B, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HAB.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.

*****
HAB : eq A B
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
subst.

*****
HAD : not (eq B D)
HBDC : Bet B D C
HADT : Bet B D T
B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet B B x) (and (Bet B C y) (Bet x T y))))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
subst.
exists T.

*****
HAD : not (eq B D)
HBDC : Bet B D C
HADT : Bet B D T
B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet B B T) (and (Bet B C y) (Bet T T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
subst.
exists T.
exists C.

*****
HAD : not (eq B D)
HBDC : Bet B D C
HADT : Bet B D T
B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B B T) (and (Bet B C C) (Bet T T C))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).

*****
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A B), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HAB.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.

*****
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points A C).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).

*****
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HAC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.

*****
HAC : eq A C
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
subst.

*****
HAD : not (eq C D)
HAB : not (eq C B)
HBDC : Bet B D C
HADT : Bet C D T
B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet C B x) (and (Bet C C y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
subst.
exists B.

*****
HAD : not (eq C D)
HAB : not (eq C B)
HBDC : Bet B D C
HADT : Bet C D T
B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet C B B) (and (Bet C C y) (Bet B T y)))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
subst.
exists B.
exists T.

*****
HAD : not (eq C D)
HAB : not (eq C B)
HBDC : Bet B D C
HADT : Bet C D T
B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet C B B) (and (Bet C C T) (Bet B T T))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).

*****
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HAC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.

*****
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points A T).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).

*****
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq A T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HAT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.

*****
HAT : eq A T
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exfalso.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
exfalso.

*****
HAT : eq A T
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HAD.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
exfalso.
apply HAD.

*****
HAT : eq A T
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A D
+++++
treat_equalities.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
exfalso.
apply HAD.
treat_equalities.

*****
HAC : not (eq A C)
HAB : not (eq A B)
HBDC : Bet B A C
HAD : not (eq A A)
A,B,C : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq A A
+++++
reflexivity.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).

*****
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq A T), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HAT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.

*****
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points B C).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).

*****
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq B C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HBC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.

*****
HBC : eq B C
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
subst.

*****
HAT : not (eq A T)
HAB,HAC : not (eq A C)
HAD : not (eq A D)
HBDC : Bet C D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A C x) (and (Bet A C y) (Bet x T y))))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
subst.
exists T.

*****
HAT : not (eq A T)
HAB,HAC : not (eq A C)
HAD : not (eq A D)
HBDC : Bet C D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A C T) (and (Bet A C y) (Bet T T y)))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
subst.
exists T.
exists T.

*****
HAT : not (eq A T)
HAB,HAC : not (eq A C)
HAD : not (eq A D)
HBDC : Bet C D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C T) (and (Bet A C T) (Bet T T T))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).

*****
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq B C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HBC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.

*****
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points B D).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).

*****
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq B D, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HBD.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.

*****
HBD : eq B D
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
subst.

*****
HBC : not (eq D C)
HAT : not (eq A T)
HAC : not (eq A C)
HAD,HAB : not (eq A D)
HBDC : Bet D D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A D x) (and (Bet A C y) (Bet x T y))))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
subst.
exists T.

*****
HBC : not (eq D C)
HAT : not (eq A T)
HAC : not (eq A C)
HAD,HAB : not (eq A D)
HBDC : Bet D D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A D T) (and (Bet A C y) (Bet T T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
subst.
exists T.
exists C.

*****
HBC : not (eq D C)
HAT : not (eq A T)
HAC : not (eq A C)
HAD,HAB : not (eq A D)
HBDC : Bet D D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A D T) (and (Bet A C C) (Bet T T C))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).

*****
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq B D), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HBD.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.

*****
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points B T).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).

*****
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq B T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HBT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.

*****
HBT : eq B T
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
subst.

*****
HBC : not (eq T C)
HBD : not (eq T D)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A T)
HAD : not (eq A D)
HBDC : Bet T D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A T x) (and (Bet A C y) (Bet x T y))))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
subst.
exists T.

*****
HBC : not (eq T C)
HBD : not (eq T D)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A T)
HAD : not (eq A D)
HBDC : Bet T D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A T T) (and (Bet A C y) (Bet T T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
subst.
exists T.
exists C.

*****
HBC : not (eq T C)
HBD : not (eq T D)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A T)
HAD : not (eq A D)
HBDC : Bet T D C
HADT : Bet A D T
A,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A T T) (and (Bet A C C) (Bet T T C))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).

*****
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq B T), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HBT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.

*****
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points C D).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).

*****
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq C D, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HCD.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.

*****
HCD : eq C D
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
subst.

*****
HBT : not (eq B T)
HBC,HBD : not (eq B D)
HAT : not (eq A T)
HAC : not (eq A D)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D D
HADT : Bet A D T
A,B,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A D y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
subst.
exists B.

*****
HBT : not (eq B T)
HBC,HBD : not (eq B D)
HAT : not (eq A T)
HAC : not (eq A D)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D D
HADT : Bet A D T
A,B,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A D y) (Bet B T y)))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
subst.
exists B.
exists T.

*****
HBT : not (eq B T)
HBC,HBD : not (eq B D)
HAT : not (eq A T)
HAC : not (eq A D)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D D
HADT : Bet A D T
A,B,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A D T) (Bet B T T))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).

*****
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq C D), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HCD.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.

*****
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points C T).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).

*****
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq C T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HCT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.

*****
HCT : eq C T
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
subst.

*****
HCD : not (eq T D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B T)
HAC,HAT : not (eq A T)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D T
HADT : Bet A D T
A,B,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A T y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
subst.
exists B.

*****
HCD : not (eq T D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B T)
HAC,HAT : not (eq A T)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D T
HADT : Bet A D T
A,B,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A T y) (Bet B T y)))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
subst.
exists B.
exists T.

*****
HCD : not (eq T D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B T)
HAC,HAT : not (eq A T)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D T
HADT : Bet A D T
A,B,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A T T) (Bet B T T))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).

*****
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq C T), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HCT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.

*****
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points D T).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).

*****
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq D T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HDT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.

*****
HDT : eq D T
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
subst.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
subst.

*****
HCD,HCT : not (eq C T)
HBD,HBT : not (eq B T)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HADT : Bet A T T
HBDC : Bet B T C
HAD : not (eq A T)
A,B,C,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
subst.
exists B.

*****
HCD,HCT : not (eq C T)
HBD,HBT : not (eq B T)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HADT : Bet A T T
HBDC : Bet B T C
HAD : not (eq A T)
A,B,C,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A C y) (Bet B T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
subst.
exists B.
exists C.

*****
HCD,HCT : not (eq C T)
HBD,HBT : not (eq B T)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HADT : Bet A T T
HBDC : Bet B T C
HAD : not (eq A T)
A,B,C,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A C C) (Bet B T C))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).

*****
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq D T), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HDT.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (col_dec A B C).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col A B C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.

*****
HABC : Col A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.

*****
HABC : Col A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A B C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A B C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.

*****
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H : Bet A B D) by eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A B D) by eBetween.

*****
H : Bet A B D
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (Bet A B T).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A B D) by eBetween.
assert (Bet A B T).

*****
H : Bet A B D
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B T
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A B D) by eBetween.
assert (Bet A B T).

*****
H0 : Bet A B T
H : Bet A B D
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
idtac.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A B D) by eBetween.
assert (Bet A B T).
idtac.

*****
H0 : Bet A B T
H : Bet A B D
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A B D) by eBetween.
assert (Bet A B T).
idtac.
exists T.

*****
H0 : Bet A B T
H : Bet A B D
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B T) (and (Bet A C y) (Bet T T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A B D) by eBetween.
assert (Bet A B T).
idtac.
exists T.
exists C.

*****
H0 : Bet A B T
H : Bet A B D
HABC : Bet A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B T) (and (Bet A C C) (Bet T T C))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.

*****
HABC : Col A B C
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet B C A) (Bet C A B), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet B C A) (Bet C A B), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.

*****
HABC : or (Bet B C A) (Bet C A B)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.

*****
HABC : or (Bet B C A) (Bet C A B)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B C A, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B C A, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.

*****
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H : Bet A C D) by eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A C D) by eBetween.

*****
H : Bet A C D
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (Bet A C T).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A C D) by eBetween.
assert (Bet A C T).

*****
H : Bet A C D
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C T
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A C D) by eBetween.
assert (Bet A C T).

*****
H0 : Bet A C T
H : Bet A C D
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
idtac.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A C D) by eBetween.
assert (Bet A C T).
idtac.

*****
H0 : Bet A C T
H : Bet A C D
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A C D) by eBetween.
assert (Bet A C T).
idtac.
exists B.

*****
H0 : Bet A C T
H : Bet A C D
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A C y) (Bet B T y)))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet A C D) by eBetween.
assert (Bet A C T).
idtac.
exists B.
exists T.

*****
H0 : Bet A C T
H : Bet A C D
HABC : Bet B C A
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A C T) (Bet B T T))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.

*****
HABC : or (Bet B C A) (Bet C A B)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet C A B, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet C A B, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.

*****
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H : Bet B A D \/ Bet B D A).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).

*****
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet B A D) (Bet B D A)
+++++
apply l5_3 with C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
apply l5_3 with C.

*****
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A C
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
apply l5_3 with C.

*****
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B D C
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).

*****
H : or (Bet B A D) (Bet B D A)
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
idtac.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.

*****
H : or (Bet B A D) (Bet B D A)
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim H.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.

*****
H : or (Bet B A D) (Bet B D A)
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B A D, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear H.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.

*****
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B A D, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro H.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H' : Bet A C T \/ Bet A T C).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A C T) (Bet A T C)
+++++
apply l5_2 with B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
apply l5_2 with B.

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
apply l5_2 with B.

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A C
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
apply l5_2 with B.

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A T
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).

*****
H' : or (Bet A C T) (Bet A T C)
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
idtac.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.

*****
H' : or (Bet A C T) (Bet A T C)
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.

*****
H' : or (Bet A C T) (Bet A T C)
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A C T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A C T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.

*****
H' : Bet A C T
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.

*****
H' : Bet A C T
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A C y) (Bet B T y)))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists T.

*****
H' : Bet A C T
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A C T) (Bet B T T))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.

*****
H' : or (Bet A C T) (Bet A T C)
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A T C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.

*****
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A T C, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A C y) (Bet B T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A C C) (Bet B T C))
+++++
split.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B B
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C C) (Bet B T C)
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C C) (Bet B T C)
+++++
split.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.
split.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.
split.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B T C
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A C T \\/ Bet A T C).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.
split.
try Between.

*****
H' : Bet A T C
H : Bet B A D
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B T C
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.

*****
H : or (Bet B A D) (Bet B D A)
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B D A, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear H.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.

*****
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B D A, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro H.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H' : Bet A B T \/ Bet A T B).
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B T) (Bet A T B)
+++++
apply l5_1 with D.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
apply l5_1 with D.

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
apply l5_1 with D.

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D B
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
apply l5_1 with D.

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D T
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).

*****
H' : or (Bet A B T) (Bet A T B)
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
idtac.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.

*****
H' : or (Bet A B T) (Bet A T B)
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.

*****
H' : or (Bet A B T) (Bet A T B)
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A B T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A B T, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.

*****
H' : Bet A B T
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists T.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists T.

*****
H' : Bet A B T
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B T) (and (Bet A C y) (Bet T T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists T.
exists C.

*****
H' : Bet A B T
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B T) (and (Bet A C C) (Bet T T C))
+++++
Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.

*****
H' : or (Bet A B T) (Bet A T B)
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A T B, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.

*****
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A T B, ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro H'.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists B.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun y : Tpoint => and (Bet A B B) (and (Bet A C y) (Bet B T y)))
+++++
exists C.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B B) (and (Bet A C C) (Bet B T C))
+++++
split.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B B
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C C) (Bet B T C)
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C C) (Bet B T C)
+++++
split.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.
split.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.
split.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B T C
+++++
try Between.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
elim HABC.
clear HABC.
intro HABC.
elim HABC.
clear HABC.
intro HABC.
assert (H : Bet B A D \\/ Bet B D A).
idtac.
elim H.
clear H.
intro H.
assert (H' : Bet A B T \\/ Bet A T B).
idtac.
elim H'.
clear H'.
intro H'.
exists B.
exists C.
split.
try Between.
split.
try Between.

*****
H' : Bet A T B
H : Bet B D A
HABC : Bet C A B
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B T C
+++++
eBetween.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).

*****
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col A B C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intro HABC.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
apply HGC with D.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B D)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B T)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C D)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C T)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D T)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D T
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).
intro HAB.
elim (eq_dec_points A C).
intro HAC.
elim (eq_dec_points A T).
intro HAT.
elim (eq_dec_points B C).
intro HBC.
elim (eq_dec_points B D).
intro HBD.
elim (eq_dec_points B T).
intro HBT.
elim (eq_dec_points C D).
intro HCD.
elim (eq_dec_points C T).
intro HCT.
elim (eq_dec_points D T).
intro HDT.
elim (col_dec A B C).
intro HABC.
apply HGC with D.

*****
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAC : not (eq A C)
HAB : not (eq A B)
HAD : not (eq A D)
HBDC : Bet B D C
HADT : Bet A D T
A,B,C,D,T : Tpoint
HGC : forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C))\n (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C))\n (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D))\n (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C))\n (_ : Bet A D T) (_ : Bet B D C),\nex\n (fun x : Tpoint =>\n ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B D C
+++++
assumption.
-----
Lemma tarski_s_euclid_remove_degenerated_cases : (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y) -> forall A B C D T, Bet A D T -> Bet B D C -> A <> D -> exists x y : Tpoint, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intro HGC.
intros A B C D T HADT HBDC HAD.
elim (eq_dec_points A B).

*****

*****

+++++
Qed.
-----
End tarski_s_euclid_remove_degenerated_cases.
-----
