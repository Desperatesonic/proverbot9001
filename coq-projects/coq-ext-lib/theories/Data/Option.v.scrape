Require Import Coq.Relations.Relation_Definitions.
-----
Require Import Coq.Classes.RelationClasses.
-----
Require Import Coq.Classes.Morphisms.
-----
Require Import ExtLib.Core.Type.
-----
Require Import ExtLib.Core.RelDec.
-----
Require Import ExtLib.Structures.Reducible.
-----
Require Import ExtLib.Structures.Traversable.
-----
Require Import ExtLib.Structures.Applicative.
-----
Require Import ExtLib.Structures.Functor.
-----
Require Import ExtLib.Structures.FunctorLaws.
-----
Require Import ExtLib.Structures.Proper.
-----
Require Import ExtLib.Data.Fun.
-----
Require Import ExtLib.Tactics.Injection.
-----
Require Import ExtLib.Tactics.Consider.
-----
Set Implicit Arguments.
-----
Set Strict Implicit.
-----
Global Instance Foldable_option {T} : Foldable (option T) T :=\n  fun _ f d v =>\n    match v with\n      | None => d\n      | Some x => f x d\n    end.
-----
Global Instance Traversable_option : Traversable option :=\n{| mapT := fun F _ _ _ f o =>\n  match o with\n    | None => pure None\n    | Some o => ap (pure (@Some _)) (f o)\n  end\n|}.
-----
Global Instance Applicative_option : Applicative option :=\n{| pure := @Some\n ; ap := fun _ _ f x =>\n           match f , x with\n             | Some f , Some x => Some (f x)\n             | _ , _ => None\n           end\n|}.
-----
Global Instance Functor_option : Functor option :=\n{| fmap := fun _ _ f x => match x with\n                            | None => None\n                            | Some x => Some (f x)\n                          end |}.
-----
Section relation.
-----
Context {T : Type}.
-----
Variable (R : relation T).
-----
Inductive Roption : Relation_Definitions.relation (option T) :=\n  | Roption_None : Roption None None\n  | Roption_Some : forall x y, R x y -> Roption (Some x) (Some y).
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.

*****
R : relation T
T : Type
*****
forall _ : Reflexive R, Reflexive Roption
+++++
Proof.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.

*****
R : relation T
T : Type
*****
forall _ : Reflexive R, Reflexive Roption
+++++
clear.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.
clear.

*****
R : relation T
T : Type
*****
forall _ : Reflexive R, Reflexive Roption
+++++
compute.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.
clear.
compute.

*****
R : relation T
T : Type
*****
forall (_ : forall x : T, R x x) (x : option T), Roption x x
+++++
destruct x.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.
clear.
compute.
destruct x.

*****
t : T
H : forall x : T, R x x
R : relation T
T : Type
*****
Roption (Some t) (Some t)
+++++
try constructor.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.
clear.
compute.
destruct x.
try constructor.

*****
t : T
H : forall x : T, R x x
R : relation T
T : Type
*****
R t t
+++++
auto.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.
clear.
compute.
destruct x.

*****
H : forall x : T, R x x
R : relation T
T : Type
*****
Roption None None
+++++
try constructor.
-----
Lemma Reflexive_Roption : Reflexive R -> Reflexive Roption.
Proof.
clear.
compute.
destruct x.

*****

*****

+++++
Qed.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.

*****
R : relation T
T : Type
*****
forall _ : Symmetric R, Symmetric Roption
+++++
Proof.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.

*****
R : relation T
T : Type
*****
forall _ : Symmetric R, Symmetric Roption
+++++
clear.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.

*****
R : relation T
T : Type
*****
forall _ : Symmetric R, Symmetric Roption
+++++
compute.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.
compute.

*****
R : relation T
T : Type
*****
forall (_ : forall (x y : T) (_ : R x y), R y x) (x y : option T) (_ : Roption x y), Roption y x
+++++
intros.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.
compute.
intros.

*****
H0 : Roption x y
x,y : option T
H : forall (x y : T) (_ : R x y), R y x
R : relation T
T : Type
*****
Roption y x
+++++
destruct H0.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.
compute.
intros.
destruct H0.

*****
H : forall (x y : T) (_ : R x y), R y x
R : relation T
T : Type
*****
Roption None None
+++++
constructor.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.
compute.
intros.
destruct H0.

*****
H0 : R x y
x,y : T
H : forall (x y : T) (_ : R x y), R y x
R : relation T
T : Type
*****
Roption (Some y) (Some x)
+++++
constructor.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.
compute.
intros.
destruct H0.
constructor.

*****
H0 : R x y
x,y : T
H : forall (x y : T) (_ : R x y), R y x
R : relation T
T : Type
*****
R y x
+++++
auto.
-----
Lemma Symmetric_Roption : Symmetric R -> Symmetric Roption.
Proof.
clear.
compute.
intros.
destruct H0.

*****

*****

+++++
Qed.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.

*****
R : relation T
T : Type
*****
forall _ : Transitive R, Transitive Roption
+++++
Proof.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.

*****
R : relation T
T : Type
*****
forall _ : Transitive R, Transitive Roption
+++++
clear.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.

*****
R : relation T
T : Type
*****
forall _ : Transitive R, Transitive Roption
+++++
compute.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.

*****
R : relation T
T : Type
*****
forall (_ : forall (x y z : T) (_ : R x y) (_ : R y z), R x z) (x y z : option T) (_ : Roption x y) (_ : Roption y z), Roption x z
+++++
intros.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.

*****
H1 : Roption y z
H0 : Roption x y
x,y,z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
Roption x z
+++++
destruct H0.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.

*****
H1 : Roption None z
z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
Roption None z
+++++
auto.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.

*****
H1 : Roption (Some y) z
H0 : R x y
x,y : T
z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
Roption (Some x) z
+++++
auto.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.

*****
H1 : Roption (Some y) z
H0 : R x y
x,y : T
z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
Roption (Some x) z
+++++
inversion H1.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.
inversion H1.

*****
H4 : eq (Some y0) z
H2 : eq x0 y
H3 : R y y0
x0,y0 : T
H1 : Roption (Some y) z
H0 : R x y
x,y : T
z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
Roption (Some x) (Some y0)
+++++
constructor.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.
inversion H1.
constructor.

*****
H4 : eq (Some y0) z
H2 : eq x0 y
H3 : R y y0
x0,y0 : T
H1 : Roption (Some y) z
H0 : R x y
x,y : T
z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
R x y0
+++++
auto.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.
inversion H1.
constructor.
auto.

*****
H4 : eq (Some y0) z
H2 : eq x0 y
H3 : R y y0
x0,y0 : T
H1 : Roption (Some y) z
H0 : R x y
x,y : T
z : option T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
R x y0
+++++
subst.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.
inversion H1.
constructor.
auto.
subst.

*****
H3 : R y y0
H1 : Roption (Some y) (Some y0)
y0 : T
H0 : R x y
x,y : T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
R x y0
+++++
eapply H.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.
inversion H1.
constructor.
auto.
subst.
eapply H.

*****
H3 : R y y0
H1 : Roption (Some y) (Some y0)
y0 : T
H0 : R x y
x,y : T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
R x ?y
+++++
eassumption.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.
auto.
inversion H1.
constructor.
auto.
subst.
eapply H.

*****
H3 : R y y0
H1 : Roption (Some y) (Some y0)
y0 : T
H0 : R x y
x,y : T
H : forall (x y z : T) (_ : R x y) (_ : R y z), R x z
R : relation T
T : Type
*****
R y y0
+++++
eassumption.
-----
Lemma Transitive_Roption : Transitive R -> Transitive Roption.
Proof.
clear.
compute.
intros.
destruct H0.

*****

*****

+++++
Qed.
-----
Global Instance Injective_Roption_None\n  : Injective (Roption None None).
-----
Global Instance Injective_Roption_None : Injective (Roption None None).

*****
R : relation T
T : Type
*****
Injective (Roption None None)
+++++
refine {| result := True |}.
-----
Global Instance Injective_Roption_None : Injective (Roption None None).
refine {| result := True |}.

*****
R : relation T
T : Type
*****
forall _ : Roption None None, True
+++++
auto.
-----
Global Instance Injective_Roption_None : Injective (Roption None None).
refine {| result := True |}.
auto.

*****

*****

+++++
Defined.
-----
Global Instance Injective_Roption_None_Some a\n  : Injective (Roption None (Some a)).
-----
Global Instance Injective_Roption_None_Some a : Injective (Roption None (Some a)).

*****
a : T
R : relation T
T : Type
*****
Injective (Roption None (Some a))
+++++
refine {| result := False |}.
-----
Global Instance Injective_Roption_None_Some a : Injective (Roption None (Some a)).
refine {| result := False |}.

*****
a : T
R : relation T
T : Type
*****
forall _ : Roption None (Some a), False
+++++
inversion 1.
-----
Global Instance Injective_Roption_None_Some a : Injective (Roption None (Some a)).
refine {| result := False |}.
inversion 1.

*****

*****

+++++
Defined.
-----
Global Instance Injective_Roption_Some_None a\n  : Injective (Roption (Some a) None).
-----
Global Instance Injective_Roption_Some_None a : Injective (Roption (Some a) None).

*****
a : T
R : relation T
T : Type
*****
Injective (Roption (Some a) None)
+++++
refine {| result := False |}.
-----
Global Instance Injective_Roption_Some_None a : Injective (Roption (Some a) None).
refine {| result := False |}.

*****
a : T
R : relation T
T : Type
*****
forall _ : Roption (Some a) None, False
+++++
inversion 1.
-----
Global Instance Injective_Roption_Some_None a : Injective (Roption (Some a) None).
refine {| result := False |}.
inversion 1.

*****

*****

+++++
Defined.
-----
Global Instance Injective_Roption_Some_Some a b\n  : Injective (Roption (Some a) (Some b)).
-----
Global Instance Injective_Roption_Some_Some a b : Injective (Roption (Some a) (Some b)).

*****
a,b : T
R : relation T
T : Type
*****
Injective (Roption (Some a) (Some b))
+++++
refine {| result := R a b |}.
-----
Global Instance Injective_Roption_Some_Some a b : Injective (Roption (Some a) (Some b)).
refine {| result := R a b |}.

*****
a,b : T
R : relation T
T : Type
*****
forall _ : Roption (Some a) (Some b), R a b
+++++
inversion 1.
-----
Global Instance Injective_Roption_Some_Some a b : Injective (Roption (Some a) (Some b)).
refine {| result := R a b |}.
inversion 1.

*****
H1 : eq y b
H0 : eq x a
H2 : R a b
x,y : T
H : Roption (Some a) (Some b)
a,b : T
R : relation T
T : Type
*****
R a b
+++++
auto.
-----
Global Instance Injective_Roption_Some_Some a b : Injective (Roption (Some a) (Some b)).
refine {| result := R a b |}.
inversion 1.
auto.

*****

*****

+++++
Defined.
-----
Global Instance Injective_Proper_Roption_Some x\n  : Injective (Proper Roption (Some x)).
-----
Global Instance Injective_Proper_Roption_Some x : Injective (Proper Roption (Some x)).

*****
x : T
R : relation T
T : Type
*****
Injective (Proper Roption (Some x))
+++++
refine {| result := R x x |}.
-----
Global Instance Injective_Proper_Roption_Some x : Injective (Proper Roption (Some x)).
refine {| result := R x x |}.

*****
x : T
R : relation T
T : Type
*****
forall _ : Proper Roption (Some x), R x x
+++++
abstract (inversion 1; assumption).
-----
Global Instance Injective_Proper_Roption_Some x : Injective (Proper Roption (Some x)).
refine {| result := R x x |}.
abstract (inversion 1; assumption).

*****

*****

+++++
Defined.
-----
End relation.
-----
Section type.
-----
Variable T : Type.
-----
Variable tT : type T.
-----
Global Instance type_option : type (option T) :=\n  { equal := Roption equal\n  ; proper := fun x => match x with\n                         | None => True\n                         | Some y => proper y\n                       end }.
-----
Variable tTOk : typeOk tT.
-----
Global Instance typeOk_option : typeOk type_option.
-----
Global Instance typeOk_option : typeOk type_option.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
typeOk type_option
+++++
Proof.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
typeOk type_option
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
forall (x y : option T) (_ : equal x y), and (proper x) (proper y)
+++++
inversion 1.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.

*****
H1 : eq None y
H0 : eq None x
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
and (proper None) (proper None)
+++++
split.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.

*****
H1 : eq None y
H0 : eq None x
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper None
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.

*****
H1 : eq None y
H0 : eq None x
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper None
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
and (proper (Some x0)) (proper (Some y0))
+++++
split.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper (Some x0)
+++++
simpl.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper x0
+++++
eapply only_proper.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.
eapply only_proper.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
typeOk tT
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.
eapply only_proper.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal ?x x0
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.
eapply only_proper.
eauto.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal ?x x0
+++++
symmetry.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.
eapply only_proper.
eauto.
symmetry.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal x0 ?x
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper (Some y0)
+++++
simpl.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper y0
+++++
eapply only_proper.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.
eapply only_proper.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
typeOk tT
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
inversion 1.
split.
simpl.
eapply only_proper.

*****
H2 : eq (Some y0) y
H1 : eq (Some x0) x
H0 : equal x0 y0
x0,y0 : T
H : equal x y
x,y : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal ?x y0
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
PReflexive proper equal
+++++
red.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
forall (x : option T) (_ : proper x), equal x x
+++++
destruct x.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.

*****
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
forall _ : proper (Some t), equal (Some t) (Some t)
+++++
simpl.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.

*****
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
forall _ : proper t, Roption equal (Some t) (Some t)
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.
constructor.

*****
H : proper t
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal t t
+++++
eapply preflexive.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.
constructor.
eapply preflexive.

*****
H : proper t
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
PReflexive ?wf equal
+++++
idtac.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.
constructor.
eapply preflexive.
idtac.

*****
H : proper t
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
PReflexive ?wf equal
+++++
eapply equiv_prefl.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.
constructor.
eapply preflexive.
idtac.
eapply equiv_prefl.

*****
H : proper t
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
typeOk tT
+++++
auto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.
constructor.
eapply preflexive.

*****
H : proper t
t : T
tTOk : typeOk tT
tT : type T
T : Type
*****
proper t
+++++
eapply H.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
forall _ : proper None, equal None None
+++++
simpl.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct x.
simpl.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
forall _ : True, Roption equal None None
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
Symmetric equal
+++++
red.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
forall (x y : option T) (_ : equal x y), equal y x
+++++
destruct 1.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
equal None None
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.

*****
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal (Some y) (Some x)
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
constructor.

*****
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal y x
+++++
symmetry.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
constructor.
symmetry.

*****
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal x y
+++++
assumption.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
Transitive equal
+++++
red.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
forall (x y z : option T) (_ : equal x y) (_ : equal y z), equal x z
+++++
destruct 1.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.

*****
z : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
forall _ : equal None z, equal None z
+++++
inversion 1.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.

*****
H1 : eq None z
H : equal None z
z : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal None None
+++++
subst.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.
subst.

*****
H : equal None None
tTOk : typeOk tT
tT : type T
T : Type
*****
equal None None
+++++
assumption.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.

*****
H : equal x y
x,y : T
z : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
forall _ : equal (Some y) z, equal (Some x) z
+++++
inversion 1.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.

*****
H3 : eq (Some y0) z
H1 : eq x0 y
H2 : equal y y0
x0,y0 : T
H0 : equal (Some y) z
H : equal x y
x,y : T
z : option T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal (Some x) (Some y0)
+++++
subst.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.
subst.

*****
H2 : equal y y0
H0 : equal (Some y) (Some y0)
y0 : T
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal (Some x) (Some y0)
+++++
constructor.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.
subst.
constructor.

*****
H2 : equal y y0
H0 : equal (Some y) (Some y0)
y0 : T
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal x y0
+++++
etransitivity.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.
subst.
constructor.
etransitivity.

*****
H2 : equal y y0
H0 : equal (Some y) (Some y0)
y0 : T
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal x ?y
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.
red.
destruct 1.
inversion 1.
subst.
constructor.
etransitivity.

*****
H2 : equal y y0
H0 : equal (Some y) (Some y0)
y0 : T
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal y y0
+++++
eauto.
-----
Global Instance typeOk_option : typeOk type_option.
Proof.
constructor.

*****

*****

+++++
Qed.
-----
Global Instance proper_Some : proper (@Some T).
-----
Global Instance proper_Some : proper (@Some T).

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
proper Some
+++++
Proof.
-----
Global Instance proper_Some : proper (@Some T).
Proof.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
proper Some
+++++
constructor.
-----
Global Instance proper_Some : proper (@Some T).
Proof.
constructor.

*****
H : equal x y
x,y : T
tTOk : typeOk tT
tT : type T
T : Type
*****
equal x y
+++++
assumption.
-----
Global Instance proper_Some : proper (@Some T).
Proof.
constructor.
assumption.

*****

*****

+++++
Qed.
-----
Global Instance proper_None : proper (@None T).
-----
Global Instance proper_None : proper (@None T).

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
proper None
+++++
Proof.
-----
Global Instance proper_None : proper (@None T).
Proof.

*****
tTOk : typeOk tT
tT : type T
T : Type
*****
proper None
+++++
constructor.
-----
Global Instance proper_None : proper (@None T).
Proof.
constructor.

*****

*****

+++++
Qed.
-----
End type.
-----
Global Instance Injective_Some (T : Type) (a b : T) : Injective (Some a = Some b) :=\n{ result := a = b\n; injection := \n    fun P : Some a = Some b =>\n      match P with \n      | eq_refl => eq_refl\n      end\n}.
-----
Require ExtLib.Core.EquivDec.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).

*****
EDT : EquivDec.EqDec T eq
T : Type
*****
EquivDec.EqDec (option T) eq
+++++
Proof.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.

*****
EDT : EquivDec.EqDec T eq
T : Type
*****
EquivDec.EqDec (option T) eq
+++++
red.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.

*****
EDT : EquivDec.EqDec T eq
T : Type
*****
forall x y : option T, sumbool (Equivalence.equiv x y) (complement Equivalence.equiv x y)
+++++
unfold Equivalence.equiv.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.
unfold Equivalence.equiv.

*****
EDT : EquivDec.EqDec T eq
T : Type
*****
forall x y : option T, sumbool (eq x y) (complement eq x y)
+++++
unfold RelationClasses.complement.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.
unfold Equivalence.equiv.
unfold RelationClasses.complement.

*****
EDT : EquivDec.EqDec T eq
T : Type
*****
forall x y : option T, sumbool (eq x y) (forall _ : eq x y, False)
+++++
intros.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.
unfold Equivalence.equiv.
unfold RelationClasses.complement.
intros.

*****
x,y : option T
EDT : EquivDec.EqDec T eq
T : Type
*****
sumbool (eq x y) (forall _ : eq x y, False)
+++++
change (x = y -> False) with (x <> y).
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.
unfold Equivalence.equiv.
unfold RelationClasses.complement.
intros.
change (x = y -> False) with (x <> y).

*****
x,y : option T
EDT : EquivDec.EqDec T eq
T : Type
*****
sumbool (eq x y) (not (eq x y))
+++++
decide equality.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.
unfold Equivalence.equiv.
unfold RelationClasses.complement.
intros.
change (x = y -> False) with (x <> y).
decide equality.

*****
a,t : T
x,y : option T
EDT : EquivDec.EqDec T eq
T : Type
*****
sumbool (eq a t) (not (eq a t))
+++++
apply EDT.
-----
Global Instance EqDec_option (T : Type) (EDT : EquivDec.EqDec T (@eq T)) : EquivDec.EqDec (option T) (@eq _).
Proof.
red.
unfold Equivalence.equiv.
unfold RelationClasses.complement.
intros.
change (x = y -> False) with (x <> y).
decide equality.
apply EDT.

*****

*****

+++++
Qed.
-----
Section OptionEq.
-----
Variable T : Type.
-----
Variable EDT : RelDec (@eq T).
-----
Global Instance RelDec_eq_option : RelDec (@eq (option T)) :=\n  { rel_dec := fun x y =>\n    match x , y with\n      | None , None => true\n      | Some x , Some y => eq_dec x y\n      | _ , _ => false\n    end }.
-----
Variable EDCT : RelDec_Correct EDT.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
RelDec_Correct RelDec_eq_option
+++++
Proof.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
RelDec_Correct RelDec_eq_option
+++++
constructor.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall x y : option T, iff (eq (rel_dec x y) true) (eq x y)
+++++
destruct x.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall y : option T, iff (eq (rel_dec (Some t) y) true) (eq (Some t) y)
+++++
destruct y.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.

*****
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
iff (eq (rel_dec (Some t) (Some t0)) true) (eq (Some t) (Some t0))
+++++
split.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (rel_dec (Some t) (Some t0)) true, eq (Some t) (Some t0)
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (eq_dec t t0) true, eq (Some t) (Some t0)
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq (eq_dec t t0) true
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq (Some t) (Some t0)
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.

*****
H : eq (eq_dec t t0) true
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq (Some t) (Some t0)
+++++
f_equal.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.
f_equal.

*****
H : eq (eq_dec t t0) true
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq t t0
+++++
try match goal with | [ H : context [ eq_dec ?X ?Y ] |- _ ] => consider (eq_dec X Y) | [ |- context [ eq_dec ?X ?Y ] ] => consider (eq_dec X Y) end.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.
f_equal.
try match goal with | [ H : context [ eq_dec ?X ?Y ] |- _ ] => consider (eq_dec X Y) | [ |- context [ eq_dec ?X ?Y ] ] => consider (eq_dec X Y) end.

*****
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq t t0, eq t t0
+++++
auto.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (Some t) (Some t0), eq (rel_dec (Some t) (Some t0)) true
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (Some t) (Some t0), eq (eq_dec t t0) true
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq (Some t) (Some t0)
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq (eq_dec t t0) true
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.

*****
H : eq (Some t) (Some t0)
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq (eq_dec t t0) true
+++++
f_equal.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.
f_equal.

*****
H : eq (Some t) (Some t0)
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq (eq_dec t t0) true
+++++
try match goal with | [ H : context [ eq_dec ?X ?Y ] |- _ ] => consider (eq_dec X Y) | [ |- context [ eq_dec ?X ?Y ] ] => consider (eq_dec X Y) end.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.
f_equal.
try match goal with | [ H : context [ eq_dec ?X ?Y ] |- _ ] => consider (eq_dec X Y) | [ |- context [ eq_dec ?X ?Y ] ] => consider (eq_dec X Y) end.

*****
H : eq (Some t) (Some t0)
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq t t0, eq true true
+++++
auto.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.
f_equal.
try match goal with | [ H : context [ eq_dec ?X ?Y ] |- _ ] => consider (eq_dec X Y) | [ |- context [ eq_dec ?X ?Y ] ] => consider (eq_dec X Y) end.

*****
H : eq (Some t) (Some t0)
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : not (eq t t0), eq false true
+++++
auto.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.
try congruence.
f_equal.
try match goal with | [ H : context [ eq_dec ?X ?Y ] |- _ ] => consider (eq_dec X Y) | [ |- context [ eq_dec ?X ?Y ] ] => consider (eq_dec X Y) end.
auto.

*****
H : eq (Some t) (Some t0)
t,t0 : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : not (eq t t0), eq false true
+++++
congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
iff (eq (rel_dec (Some t) None) true) (eq (Some t) None)
+++++
split.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (rel_dec (Some t) None) true, eq (Some t) None
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq false true, eq (Some t) None
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq false true
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq (Some t) None
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (Some t) None, eq (rel_dec (Some t) None) true
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (Some t) None, eq false true
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq (Some t) None
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq false true
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall y : option T, iff (eq (rel_dec None y) true) (eq None y)
+++++
destruct y.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
iff (eq (rel_dec None (Some t)) true) (eq None (Some t))
+++++
split.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (rel_dec None (Some t)) true, eq None (Some t)
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq false true, eq None (Some t)
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq false true
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq None (Some t)
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq None (Some t), eq (rel_dec None (Some t)) true
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq None (Some t), eq false true
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq None (Some t)
t : T
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq false true
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
iff (eq (rel_dec None None) true) (eq None None)
+++++
split.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq (rel_dec None None) true, eq None None
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq true true, eq None None
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq true true
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq None None
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq None None, eq (rel_dec None None) true
+++++
simpl in *.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.

*****
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
forall _ : eq None None, eq true true
+++++
intros.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.
destruct y.
split.
simpl in *.
intros.

*****
H : eq None None
EDCT : RelDec_Correct EDT
EDT : RelDec eq
T : Type
*****
eq true true
+++++
try congruence.
-----
Global Instance RelDec_Correct_eq_option : RelDec_Correct RelDec_eq_option.
Proof.
constructor.
destruct x.

*****

*****

+++++
Qed.
-----
End OptionEq.
-----
Lemma eq_option_eq\n: forall T (a b : T) (pf : a = b) (F : _ -> Type) val,\n    match pf in _ = x return option (F x) with\n      | eq_refl => val\n    end = match val with\n            | None => None\n            | Some val => Some match pf in _ = x return F x with\n                                 | eq_refl => val\n                               end\n          end.
-----
Lemma eq_option_eq : forall T (a b : T) (pf : a = b) (F : _ -> Type) val, match pf in _ = x return option (F x) with | eq_refl => val end = match val with | None => None | Some val => Some match pf in _ = x return F x with | eq_refl => val end end.

*****

*****
forall (T : Type) (a b : T) (pf : eq a b) (F : forall _ : T, Type) (val : option (F a)), eq match pf in (eq _ x) return (option (F x)) with | eq_refl => val end match val with | Some val0 => Some match pf in (eq _ x) return (F x) with | eq_refl => val0 end | None => None end
+++++
Proof.
-----
Lemma eq_option_eq : forall T (a b : T) (pf : a = b) (F : _ -> Type) val, match pf in _ = x return option (F x) with | eq_refl => val end = match val with | None => None | Some val => Some match pf in _ = x return F x with | eq_refl => val end end.
Proof.

*****

*****
forall (T : Type) (a b : T) (pf : eq a b) (F : forall _ : T, Type) (val : option (F a)), eq match pf in (eq _ x) return (option (F x)) with | eq_refl => val end match val with | Some val0 => Some match pf in (eq _ x) return (F x) with | eq_refl => val0 end | None => None end
+++++
destruct pf.
-----
Lemma eq_option_eq : forall T (a b : T) (pf : a = b) (F : _ -> Type) val, match pf in _ = x return option (F x) with | eq_refl => val end = match val with | None => None | Some val => Some match pf in _ = x return F x with | eq_refl => val end end.
Proof.
destruct pf.

*****
a : T
T : Type
*****
forall (F : forall _ : T, Type) (val : option (F a)), eq val match val with | Some val0 => Some val0 | None => None end
+++++
destruct val.
-----
Lemma eq_option_eq : forall T (a b : T) (pf : a = b) (F : _ -> Type) val, match pf in _ = x return option (F x) with | eq_refl => val end = match val with | None => None | Some val => Some match pf in _ = x return F x with | eq_refl => val end end.
Proof.
destruct pf.
destruct val.

*****
f : F a
F : forall _ : T, Type
a : T
T : Type
*****
eq (Some f) (Some f)
+++++
reflexivity.
-----
Lemma eq_option_eq : forall T (a b : T) (pf : a = b) (F : _ -> Type) val, match pf in _ = x return option (F x) with | eq_refl => val end = match val with | None => None | Some val => Some match pf in _ = x return F x with | eq_refl => val end end.
Proof.
destruct pf.
destruct val.

*****
F : forall _ : T, Type
a : T
T : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma eq_option_eq : forall T (a b : T) (pf : a = b) (F : _ -> Type) val, match pf in _ = x return option (F x) with | eq_refl => val end = match val with | None => None | Some val => Some match pf in _ = x return F x with | eq_refl => val end end.
Proof.
destruct pf.
destruct val.

*****

*****

+++++
Defined.
-----
Hint Rewrite eq_option_eq : eq_rw.
-----
