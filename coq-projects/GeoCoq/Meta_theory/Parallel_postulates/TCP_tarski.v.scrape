Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Meta_theory.Parallel_postulates.tarski_s_euclid_remove_degenerated_cases.
-----
Require Import GeoCoq.Tarski_dev.Annexes.perp_bisect.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section TCP_tarski.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma impossible_case_1 :\n  forall A B C D T x y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  C <> D ->\n  C <> T ->\n  D <> T ->\n  x <> y ->\n  ~ Col A B C ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Bet A B x ->\n  Bet C y A ->\n  Bet x T y ->\n  Par_strict B C x y ->\n  False.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet A B x) (_ : Bet C y A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
Proof.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet A B x) (_ : Bet C y A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
intros A B C D T x y.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.

*****
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet A B x) (_ : Bet C y A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

*****
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet A B x) (_ : Bet C y A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.

*****
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet A B x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply between_symmetry in HABx.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.

*****
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet x B A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HI := inner_pasch x C A B y HABx HACy).
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.
assert (HI := inner_pasch x C A B y HABx HACy).

*****
HI : ex (fun X : Tpoint => and (Bet B X C) (Bet y X x))
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet x B A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HI as [I [HBCI HIxy]].
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.
assert (HI := inner_pasch x C A B y HABx HACy).
destruct HI as [I [HBCI HIxy]].

*****
HIxy : Bet y I x
HBCI : Bet B I C
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet x B A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HPar.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.
assert (HI := inner_pasch x C A B y HABx HACy).
destruct HI as [I [HBCI HIxy]].
apply HPar.

*****
HIxy : Bet y I x
HBCI : Bet B I C
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet x B A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X B C) (Col X x y))
+++++
exists I.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.
assert (HI := inner_pasch x C A B y HABx HACy).
destruct HI as [I [HBCI HIxy]].
apply HPar.
exists I.

*****
HIxy : Bet y I x
HBCI : Bet B I C
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet x B A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col I B C) (Col I x y)
+++++
assert_cols.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.
assert (HI := inner_pasch x C A B y HABx HACy).
destruct HI as [I [HBCI HIxy]].
apply HPar.
exists I.
assert_cols.

*****
H5 : Col A D T
H4 : Col B D C
H3 : Col x B A
H2 : Col C y A
H1 : Col x T y
H0 : Col B I C
H : Col y I x
HIxy : Bet y I x
HBCI : Bet B I C
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HACy : Bet C y A
HABx : Bet x B A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col I B C) (Col I x y)
+++++
Col.
-----
Lemma impossible_case_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A B x -> Bet C y A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HACy HxTy HPar.
apply between_symmetry in HABx.
assert (HI := inner_pasch x C A B y HABx HACy).
destruct HI as [I [HBCI HIxy]].
apply HPar.
exists I.
assert_cols.
Col.

*****

*****

+++++
Qed.
-----
Lemma impossible_case_2 :\n  forall A B C D T x y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  C <> D ->\n  C <> T ->\n  D <> T ->\n  x <> y ->\n  ~ Col A B C ->\n  Col A B x ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Bet y A C ->\n  Bet x T y ->\n  False.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A B x) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet y A C) (_ : Bet x T y), False
+++++
Proof.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A B x) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet y A C) (_ : Bet x T y), False
+++++
intros A B C D T x y.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.

*****
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A B x) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet y A C) (_ : Bet x T y), False
+++++
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

*****
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Col A B x) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet y A C) (_ : Bet x T y), False
+++++
intros HABC HABx HADT HBCT HBDC HACy HxTy.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.

*****
HxTy : Bet x T y
HACy : Bet y A C
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply between_symmetry in HACy.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.

*****
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].

*****
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).

*****
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.

*****
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HTS; apply one_side_transitivity with D.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.

*****
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B C D
+++++
assert (HABB : Col A B B) by Col.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.

*****
HABB : Col A B B
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B C D
+++++
assert (HBDC' : Col C D B) by (assert_cols; Col).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).

*****
HBDC' : Col C D B
HABB : Col A B B
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B C D
+++++
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.

*****
H : iff (OS A B C D) (and (Out B C D) (not (Col A B C)))
HBDC' : Col C D B
HABB : Col A B B
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out B C D) (not (Col A B C))
+++++
split; try (intro; apply HABC; Col).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).

*****
H : iff (OS A B C D) (and (Out B C D) (not (Col A B C)))
HBDC' : Col C D B
HABB : Col A B B
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B C D
+++++
repeat (split; Between).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).

*****
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B D T
+++++
assert (HABA : Col A B A) by Col.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HABA : Col A B A) by Col.

*****
HABA : Col A B A
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B D T
+++++
assert (HDTA : Col D T A) by (assert_cols; Col).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HABA : Col A B A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).

*****
HDTA : Col D T A
HABA : Col A B A
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A B D T
+++++
assert (H := l9_19 A B D T A HABA HDTA); rewrite H.
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HABA : Col A B A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).
assert (H := l9_19 A B D T A HABA HDTA); rewrite H.

*****
H : iff (OS A B D T) (and (Out A D T) (not (Col A B D)))
HDTA : Col D T A
HABA : Col A B A
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A D T) (not (Col A B D))
+++++
split; try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HABA : Col A B A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).
assert (H := l9_19 A B D T A HABA HDTA); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).

*****
H : iff (OS A B D T) (and (Out A D T) (not (Col A B D)))
HDTA : Col D T A
HABA : Col A B A
HTS : not (OS A B C T)
HAx : not (eq A x)
HICT : Bet T I C
HAIx : Bet A I x
I : Tpoint
HxTy : Bet x T y
HACy : Bet C A y
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABx : Col A B x
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D T
+++++
repeat (split; Between).
-----
Lemma impossible_case_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A B x -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet y A C -> Bet x T y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HABx HADT HBCT HBDC HACy HxTy.
apply between_symmetry in HACy.
assert (HI := inner_pasch C x y A T HACy HxTy); destruct HI as [I [HAIx HICT]].
assert (HAx : A <> x) by (intro; treat_equalities; apply HABC; assert_cols; ColR).
assert (HTS : TS A B C T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists I; split; Between; assert_cols; ColR); apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HABB : Col A B B) by Col.
assert (HBDC' : Col C D B) by (assert_cols; Col).
assert (H := l9_19 A B C D B HABB HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HABA : Col A B A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).
assert (H := l9_19 A B D T A HABA HDTA); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).
repeat (split; Between).

*****

*****

+++++
Qed.
-----
Lemma impossible_case_3 :\n  forall A B C D T x y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  C <> D ->\n  C <> T ->\n  D <> T ->\n  x <> y ->\n  ~ Col A B C ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Bet B x A ->\n  Bet x T y ->\n  Par_strict B C x y ->\n  False.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B x A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
Proof.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B x A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
intros A B C D T x y.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.

*****
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B x A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

*****
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B x A) (_ : Bet x T y) (_ : Par_strict B C x y), False
+++++
intros HABC HADT HBCT HBDC HABx HxTy HPar.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.

*****
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply between_symmetry in HADT.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.

*****
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HI := inner_pasch B T A x D HABx HADT).
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).

*****
HI : ex (fun X : Tpoint => and (Bet x X T) (Bet D X B))
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HI as [I [HITx HBDI]].
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].

*****
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTx : T <> x).
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).

*****
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T x)
+++++
intro.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
intro.

*****
H : eq T x
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
intro.
subst.

*****
HBDI : Bet D I B
HITx : Bet x I x
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x x y
HABx : Bet B x A
HBDC : Bet B D C
HADT : Bet x D A
HBCT : not (Col B C x)
HABC : not (Col A B C)
Hxy : not (eq x y)
HCT : not (eq C x)
HDT : not (eq D x)
HCD : not (eq C D)
HBT : not (eq B x)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A x)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
intro.
subst.
apply HABC.

*****
HBDI : Bet D I B
HITx : Bet x I x
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x x y
HABx : Bet B x A
HBDC : Bet B D C
HADT : Bet x D A
HBCT : not (Col B C x)
HABC : not (Col A B C)
Hxy : not (eq x y)
HCT : not (eq C x)
HDT : not (eq D x)
HCD : not (eq C D)
HBT : not (eq B x)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A x)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
intro.
subst.
apply HABC.
assert_cols.

*****
H4 : Col x D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x x y
H0 : Col x I x
H : Col D I B
HBDI : Bet D I B
HITx : Bet x I x
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x x y
HABx : Bet B x A
HBDC : Bet B D C
HADT : Bet x D A
HBCT : not (Col B C x)
HABC : not (Col A B C)
Hxy : not (eq x y)
HCT : not (eq C x)
HDT : not (eq D x)
HCD : not (eq C D)
HBT : not (eq B x)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A x)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).

*****
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.

*****
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HPar' : Par_strict B D x T).
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).

*****
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B D x T
+++++
apply par_strict_col_par_strict with y.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.

*****
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x T)
+++++
assert_cols.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x T)
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.

*****
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B D x y
+++++
assert_cols.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B D x y
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.
Col.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B D x y
+++++
apply par_strict_symmetry.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.
Col.
apply par_strict_symmetry.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict x y B D
+++++
apply par_strict_col_par_strict with C.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.
Col.
apply par_strict_symmetry.
apply par_strict_col_par_strict with C.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B D)
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.
Col.
apply par_strict_symmetry.
apply par_strict_col_par_strict with C.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict x y B C
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.
Col.
apply par_strict_symmetry.
apply par_strict_col_par_strict with C.
Col.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict x y B C
+++++
Par...
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.
Col.
apply par_strict_symmetry.
apply par_strict_col_par_strict with C.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B C D
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.

*****
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col x y T
+++++
assert_cols.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
apply par_strict_col_par_strict with y.
assert_cols.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col x y T
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).

*****
HPar' : Par_strict B D x T
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
idtac.

*****
HPar' : Par_strict B D x T
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HPar'.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
idtac.
apply HPar'.

*****
HPar' : Par_strict B D x T
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X B D) (Col X x T))
+++++
exists I.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
idtac.
apply HPar'.
exists I.

*****
HPar' : Par_strict B D x T
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col I B D) (Col I x T)
+++++
assert_cols.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).
idtac.
assert (HPar' : Par_strict B D x T).
idtac.
apply HPar'.
exists I.
assert_cols.

*****
H4 : Col T D A
H3 : Col B D C
H2 : Col B x A
H1 : Col x T y
H0 : Col x I T
H : Col D I B
HPar' : Par_strict B D x T
HTx : not (eq T x)
HBDI : Bet D I B
HITx : Bet x I T
I : Tpoint
HPar : Par_strict B C x y
HxTy : Bet x T y
HABx : Bet B x A
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet T D A
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col I B D) (Col I x T)
+++++
Col.
-----
Lemma impossible_case_3 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B x A -> Bet x T y -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HADT HBCT HBDC HABx HxTy HPar.
apply between_symmetry in HADT.
assert (HI := inner_pasch B T A x D HABx HADT).
destruct HI as [I [HITx HBDI]].
assert (HTx : T <> x).

*****

*****

+++++
Qed.
-----
Lemma impossible_case_4_1 :\n  forall A B C D T x y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  C <> D ->\n  C <> T ->\n  D <> T ->\n  x <> y ->\n  ~ Col A B C ->\n  Col A C y ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Bet A x B \/ Bet A B x ->\n  Bet T y x ->\n  False.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : or (Bet A x B) (Bet A B x)) (_ : Bet T y x), False
+++++
Proof.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : or (Bet A x B) (Bet A B x)) (_ : Bet T y x), False
+++++
intros A B C D T x y.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.

*****
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : or (Bet A x B) (Bet A B x)) (_ : Bet T y x), False
+++++
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

*****
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : or (Bet A x B) (Bet A B x)) (_ : Bet T y x), False
+++++
intros HABC HACy HADT HBCT HBDC HABx HTyx.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.

*****
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).

*****
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).

*****
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HOS : OS A C x B).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).

*****
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C x B
+++++
assert (HACA : Col A C A) by Col.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HACA : Col A C A) by Col.

*****
HACA : Col A C A
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C x B
+++++
assert (HABx' : Col x B A) by (induction HABx; assert_cols; Col).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HACA : Col A C A) by Col.
assert (HABx' : Col x B A) by (induction HABx; assert_cols; Col).

*****
HABx' : Col x B A
HACA : Col A C A
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C x B
+++++
assert (H := l9_19 A C x B A HACA HABx'); rewrite H.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HACA : Col A C A) by Col.
assert (HABx' : Col x B A) by (induction HABx; assert_cols; Col).
assert (H := l9_19 A C x B A HACA HABx'); rewrite H.

*****
H : iff (OS A C x B) (and (Out A x B) (not (Col A C x)))
HABx' : Col x B A
HACA : Col A C A
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A x B) (not (Col A C x))
+++++
split; try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HACA : Col A C A) by Col.
assert (HABx' : Col x B A) by (induction HABx; assert_cols; Col).
assert (H := l9_19 A C x B A HACA HABx'); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).

*****
H : iff (OS A C x B) (and (Out A x B) (not (Col A C x)))
HABx' : Col x B A
HACA : Col A C A
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A x B
+++++
repeat (split; auto).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).

*****
HOS : OS A C x B
HAx : not (eq A x)
HTS : TS A C x T
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.

*****
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HTS; apply one_side_transitivity with D.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.

*****
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
assert (HACC : Col A C C) by Col.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.

*****
HACC : Col A C C
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
assert (HBDC' : Col B D C) by (assert_cols; Col).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).

*****
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out C B D) (not (Col A C B))
+++++
split; try (intro; apply HABC; Col).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C B D
+++++
repeat (split; Between).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).

*****
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
assert (HACA : Col A C A) by Col.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HACA : Col A C A) by Col.

*****
HACA : Col A C A
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
assert (HDTA : Col D T A) by (assert_cols; Col).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HACA : Col A C A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).

*****
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
assert (H := l9_19 A C D T A HACA HDTA); rewrite H.
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HACA : Col A C A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).
assert (H := l9_19 A C D T A HACA HDTA); rewrite H.

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A D T) (not (Col A C D))
+++++
split; try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HACA : Col A C A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).
assert (H := l9_19 A C D T A HACA HDTA); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HAx : not (eq A x)
HTyx : Bet T y x
HABx : or (Bet A x B) (Bet A B x)
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D T
+++++
repeat (split; Between).
-----
Lemma impossible_case_4_1 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet A x B \\/ Bet A B x -> Bet T y x -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx.
assert (HTS : TS A C x T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists y; split; assert_cols; Col; Between).
assert (HAx : A <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HOS : OS A C x B).
assert (HTS' : TS A C B T) by (apply l9_8_2 with x; assumption); clear HTS; clear HOS; rename HTS' into HTS; apply l9_9 in HTS.
apply HTS; apply one_side_transitivity with D.
assert (HACC : Col A C C) by Col.
assert (HBDC' : Col B D C) by (assert_cols; Col).
assert (H := l9_19 A C B D C HACC HBDC'); rewrite H.
split; try (intro; apply HABC; Col).
repeat (split; Between).
assert (HACA : Col A C A) by Col.
assert (HDTA : Col D T A) by (assert_cols; Col).
assert (H := l9_19 A C D T A HACA HDTA); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).
repeat (split; Between).

*****

*****

+++++
Qed.
-----
Lemma impossible_case_4_2 :\n  forall A B C D T x y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  C <> D ->\n  C <> T ->\n  D <> T ->\n  x <> y ->\n  ~ Col A B C ->\n  Col A C y ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Bet B A x ->\n  Bet T y x ->\n  Par_strict B C x y ->\n  False.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B A x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
Proof.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B A x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
intros A B C D T x y.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.

*****
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B A x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

*****
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B A x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).

*****
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HOS : OS B C A x).
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).

*****
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B C A x
+++++
assert (HBCB : Col B C B) by Col.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HBCB : Col B C B) by Col.

*****
HBCB : Col B C B
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B C A x
+++++
assert (HABx' : Col A x B) by Col.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HBCB : Col B C B) by Col.
assert (HABx' : Col A x B) by Col.

*****
HABx' : Col A x B
HBCB : Col B C B
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS B C A x
+++++
assert (H := l9_19 B C A x B HBCB HABx'); rewrite H.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HBCB : Col B C B) by Col.
assert (HABx' : Col A x B) by Col.
assert (H := l9_19 B C A x B HBCB HABx'); rewrite H.

*****
H : iff (OS B C A x) (and (Out B A x) (not (Col B C A)))
HABx' : Col A x B
HBCB : Col B C B
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out B A x) (not (Col B C A))
+++++
split; try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HBCB : Col B C B) by Col.
assert (HABx' : Col A x B) by Col.
assert (H := l9_19 B C A x B HBCB HABx'); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).

*****
H : iff (OS B C A x) (and (Out B A x) (not (Col B C A)))
HABx' : Col A x B
HBCB : Col B C B
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A x
+++++
repeat (split; Between).
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HBCB : Col B C B) by Col.
assert (HABx' : Col A x B) by Col.
assert (H := l9_19 B C A x B HBCB HABx'); rewrite H.
split; try (intro; apply HABC; assert_cols; ColR).
repeat (split; Between).

*****
H : iff (OS B C A x) (and (Out B A x) (not (Col B C A)))
HABx' : Col A x B
HBCB : Col B C B
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x B)
+++++
intro; treat_equalities; intuition.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).

*****
HOS : OS B C A x
HTS : TS B C A T
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS' : TS B C x T) by (apply l9_8_2 with A; assumption); clear HTS; clear HOS; destruct HTS' as [Hclear [Hclear' [I [HBCI HITx]]]]; clear Hclear; clear Hclear'.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HTS' : TS B C x T) by (apply l9_8_2 with A; assumption); clear HTS; clear HOS; destruct HTS' as [Hclear [Hclear' [I [HBCI HITx]]]]; clear Hclear; clear Hclear'.

*****
HITx : Bet x I T
HBCI : Col I B C
I : Tpoint
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTx : T <> x) by (intro; subst; apply HABC; assert_cols; ColR).
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HTS' : TS B C x T) by (apply l9_8_2 with A; assumption); clear HTS; clear HOS; destruct HTS' as [Hclear [Hclear' [I [HBCI HITx]]]]; clear Hclear; clear Hclear'.
assert (HTx : T <> x) by (intro; subst; apply HABC; assert_cols; ColR).

*****
HTx : not (eq T x)
HITx : Bet x I T
HBCI : Col I B C
I : Tpoint
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HPar' : Par_strict B C x T) by (apply par_strict_col_par_strict with y; assert_cols; Col).
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HTS' : TS B C x T) by (apply l9_8_2 with A; assumption); clear HTS; clear HOS; destruct HTS' as [Hclear [Hclear' [I [HBCI HITx]]]]; clear Hclear; clear Hclear'.
assert (HTx : T <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HPar' : Par_strict B C x T) by (apply par_strict_col_par_strict with y; assert_cols; Col).

*****
HPar' : Par_strict B C x T
HTx : not (eq T x)
HITx : Bet x I T
HBCI : Col I B C
I : Tpoint
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Bet B A x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HPar'; exists I; assert_cols; Col.
-----
Lemma impossible_case_4_2 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B A x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
assert (HTS : TS B C A T) by (repeat (split; Col); try (intro; apply HBCT; assert_cols; ColR); exists D; split; assert_cols; Col; Between).
assert (HOS : OS B C A x).
assert (HTS' : TS B C x T) by (apply l9_8_2 with A; assumption); clear HTS; clear HOS; destruct HTS' as [Hclear [Hclear' [I [HBCI HITx]]]]; clear Hclear; clear Hclear'.
assert (HTx : T <> x) by (intro; subst; apply HABC; assert_cols; ColR).
assert (HPar' : Par_strict B C x T) by (apply par_strict_col_par_strict with y; assert_cols; Col).
apply HPar'; exists I; assert_cols; Col.

*****

*****

+++++
Qed.
-----
Lemma impossible_case_4 :\n  forall A B C D T x y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  C <> D ->\n  C <> T ->\n  D <> T ->\n  x <> y ->\n  ~ Col A B C ->\n  Col A C y ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Col A B x ->\n  Bet T y x ->\n  Par_strict B C x y ->\n  False.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col A B x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
Proof.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T x y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col A B x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
intros A B C D T x y.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.

*****
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (eq x y)) (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col A B x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.

*****
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Col A C y) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col A B x) (_ : Bet T y x) (_ : Par_strict B C x y), False
+++++
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Col A B x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
elim HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Col A B x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A B x, False
+++++
clear HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet A B x, False
+++++
intro HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_4_1 with A B C D T x y.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B D)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B T)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C D)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C T)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D T)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x y)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C y
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D T
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C T)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B D C
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A x B) (Bet A B x)
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet A B x
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet T y x
+++++
Col.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HABx : Col A B x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet B x A) (Bet x A B), False
+++++
clear HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet B x A) (Bet x A B), False
+++++
intro HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.

*****
HABx : or (Bet B x A) (Bet x A B)
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
elim HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.

*****
HABx : or (Bet B x A) (Bet x A B)
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B x A, False
+++++
clear HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B x A, False
+++++
intro HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_4_1 with A B C D T x y.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B D)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C D)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x y)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C y
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D T
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B D C
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A x B) (Bet A B x)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_1 with A B C D T x y.

*****
HABx : Bet B x A
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet T y x
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.

*****
HABx : or (Bet B x A) (Bet x A B)
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet x A B, False
+++++
clear HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.

*****
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet x A B, False
+++++
intro HABx.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_4_2 with A B C D T x y.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A D)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B D)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C D)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x y)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C y
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D T
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C T)
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B D C
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A x
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet T y x
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.
clear HABx.
intro HABx.
elim HABx.
clear HABx.
intro HABx.
apply impossible_case_4_2 with A B C D T x y.

*****
HABx : Bet x A B
HPar : Par_strict B C x y
HTyx : Bet T y x
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACy : Col A C y
HABC : not (Col A B C)
Hxy : not (eq x y)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,x,y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B C x y
+++++
Between.
-----
Lemma impossible_case_4 : forall A B C D T x y, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> x <> y -> ~ Col A B C -> Col A C y -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col A B x -> Bet T y x -> Par_strict B C x y -> False.
Proof.
intros A B C D T x y.
intros HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT Hxy.
intros HABC HACy HADT HBCT HBDC HABx HTyx HPar.
elim HABx.

*****

*****

+++++
Qed.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y,\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  A <> Y ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  B <> Y ->\n  C <> D ->\n  C <> T ->\n  C <> Y ->\n  D <> T ->\n  T <> Y ->\n  ~ Col A B C ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Bet B Y T ->\n  ~ Col A C Y.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T Y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq A Y)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq B Y)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq C Y)) (_ : not (eq D T)) (_ : not (eq T Y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B Y T), not (Col A C Y)
+++++
Proof.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T Y : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq A Y)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq B Y)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq C Y)) (_ : not (eq D T)) (_ : not (eq T Y)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B Y T), not (Col A C Y)
+++++
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.

*****
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Bet B Y T), not (Col A C Y)
+++++
intros HABC HADT HBCT HBDC HBYT.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.

*****
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C Y)
+++++
intro HACY.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS : TS A C B T).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A C B T
+++++
repeat (split; Col).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
repeat (split; Col).

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col T A C)
+++++
try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
repeat (split; Col).

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T0 : Tpoint => and (Col T0 A C) (Bet B T0 T))
+++++
try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
repeat (split; Col).
try (intro; apply HABC; assert_cols; ColR).

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T0 : Tpoint => and (Col T0 A C) (Bet B T0 T))
+++++
exists Y.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
repeat (split; Col).
try (intro; apply HABC; assert_cols; ColR).
exists Y.

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col Y A C) (Bet B Y T)
+++++
split.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
repeat (split; Col).
try (intro; apply HABC; assert_cols; ColR).
exists Y.
split.

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Y A C
+++++
Col.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
repeat (split; Col).
try (intro; apply HABC; assert_cols; ColR).
exists Y.
split.

*****
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B Y T
+++++
Col.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).

*****
HTS : TS A C B T
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.

*****
HTS : TS A C B T
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply l9_9 in HTS.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.

*****
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HTS.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.

*****
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B T
+++++
apply one_side_transitivity with D.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.

*****
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
assert (HACC : Col A C C).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).

*****
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C C
+++++
Col.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).

*****
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
idtac.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.

*****
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
assert (HBDC' : Col B D C).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).

*****
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B D C
+++++
assert_cols.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
assert_cols.

*****
H1 : Col A D T
H0 : Col B D C
H : Col B Y T
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B D C
+++++
Col.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).

*****
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
idtac.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
idtac.

*****
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
assert (H := l9_19 A C B D C HACC HBDC').
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
idtac.
assert (H := l9_19 A C B D C HACC HBDC').

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C B D
+++++
rewrite H.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
idtac.
assert (H := l9_19 A C B D C HACC HBDC').
rewrite H.

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out C B D) (not (Col A C B))
+++++
split.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
idtac.
assert (H := l9_19 A C B D C HACC HBDC').
rewrite H.
split.

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C B D
+++++
try (intro; apply HABC; Col).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
idtac.
assert (H := l9_19 A C B D C HACC HBDC').
rewrite H.
split.
try (intro; apply HABC; Col).

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C B D
+++++
repeat (split; Between).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACC : Col A C C).
idtac.
assert (HBDC' : Col B D C).
idtac.
assert (H := l9_19 A C B D C HACC HBDC').
rewrite H.
split.

*****
H : iff (OS A C B D) (and (Out C B D) (not (Col A C B)))
HBDC' : Col B D C
HACC : Col A C C
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C B)
+++++
try (intro; apply HABC; Col).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.

*****
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
assert (HACA : Col A C A).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).

*****
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C A
+++++
Col.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).

*****
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
idtac.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.

*****
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
assert (HDTA : Col D T A).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).

*****
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D T A
+++++
assert_cols.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
assert_cols.

*****
H1 : Col A D T
H0 : Col B D C
H : Col B Y T
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col D T A
+++++
Col.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).

*****
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
idtac.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
idtac.

*****
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
assert (H := l9_19 A C D T A HACA HDTA).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
idtac.
assert (H := l9_19 A C D T A HACA HDTA).

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C D T
+++++
rewrite H.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
idtac.
assert (H := l9_19 A C D T A HACA HDTA).
rewrite H.

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A D T) (not (Col A C D))
+++++
split.
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
idtac.
assert (H := l9_19 A C D T A HACA HDTA).
rewrite H.
split.

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D T
+++++
try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
idtac.
assert (H := l9_19 A C D T A HACA HDTA).
rewrite H.
split.
try (intro; apply HABC; assert_cols; ColR).

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D T
+++++
repeat (split; Between).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with D.
assert (HACA : Col A C A).
idtac.
assert (HDTA : Col D T A).
idtac.
assert (H := l9_19 A C D T A HACA HDTA).
rewrite H.
split.

*****
H : iff (OS A C D T) (and (Out A D T) (not (Col A C D)))
HDTA : Col D T A
HACA : Col A C A
HTS : not (OS A C B T)
HACY : Col A C Y
HBYT : Bet B Y T
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HABC : not (Col A B C)
HTY : not (eq T Y)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T,Y : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C D)
+++++
try (intro; apply HABC; assert_cols; ColR).
-----
Lemma impossible_two_sides_not_col : forall A B C D T Y, A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> Y -> ~ Col A B C -> Bet A D T -> ~ Col B C T -> Bet B D C -> Bet B Y T -> ~ Col A C Y.
Proof.
intros A B C D T Y HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTY.
intros HABC HADT HBCT HBDC HBYT.
intro HACY.
assert (HTS : TS A C B T).

*****

*****

+++++
Qed.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux :\n  forall A B C D T X Y Z M1 Z1 M2 Z2,\n  triangle_circumscription_principle ->\n  A <> B ->\n  A <> C ->\n  A <> D ->\n  A <> T ->\n  A <> Y ->\n  B <> C ->\n  B <> D ->\n  B <> T ->\n  B <> Y ->\n  C <> D ->\n  C <> T ->\n  C <> Y ->\n  D <> T ->\n  T <> X ->\n  T <> Y ->\n  X <> Y ->\n  Y <> Z1 ->\n  Y <> Z2 ->\n  ~ Col A B C ->\n  Col A B M1 ->\n  Col A C M2 ->\n  Bet A D T ->\n  ~ Col B C T ->\n  Bet B D C ->\n  Col T Y Z ->\n  Bet Y T X ->\n  Bet Y M1 Z1 ->\n  Bet Y M2 Z2 ->\n  Cong Y T T X ->\n  Cong Y M1 M1 Z1 ->\n  Cong Y M2 M2 Z2 ->\n  Perp B C T Z ->\n  Perp A B Y Z1 ->\n  Perp A C Y Z2 ->\n  exists x, exists y, Bet A B x /\ Bet A C y /\ Bet x T y.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T X Y Z M1 Z1 M2 Z2 : Tpoint) (_ : triangle_circumscription_principle) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq A Y)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq B Y)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq C Y)) (_ : not (eq D T)) (_ : not (eq T X)) (_ : not (eq T Y)) (_ : not (eq X Y)) (_ : not (eq Y Z1)) (_ : not (eq Y Z2)) (_ : not (Col A B C)) (_ : Col A B M1) (_ : Col A C M2) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col T Y Z) (_ : Bet Y T X) (_ : Bet Y M1 Z1) (_ : Bet Y M2 Z2) (_ : Cong Y T T X) (_ : Cong Y M1 M1 Z1) (_ : Cong Y M2 M2 Z2) (_ : Perp B C T Z) (_ : Perp A B Y Z1) (_ : Perp A C Y Z2), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
Proof.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T X Y Z M1 Z1 M2 Z2 : Tpoint) (_ : triangle_circumscription_principle) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq A Y)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq B Y)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq C Y)) (_ : not (eq D T)) (_ : not (eq T X)) (_ : not (eq T Y)) (_ : not (eq X Y)) (_ : not (eq Y Z1)) (_ : not (eq Y Z2)) (_ : not (Col A B C)) (_ : Col A B M1) (_ : Col A C M2) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col T Y Z) (_ : Bet Y T X) (_ : Bet Y M1 Z1) (_ : Bet Y M2 Z2) (_ : Cong Y T T X) (_ : Cong Y M1 M1 Z1) (_ : Cong Y M2 M2 Z2) (_ : Perp B C T Z) (_ : Perp A B Y Z1) (_ : Perp A C Y Z2), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.

*****
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq A Y)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq B Y)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq C Y)) (_ : not (eq D T)) (_ : not (eq T X)) (_ : not (eq T Y)) (_ : not (eq X Y)) (_ : not (eq Y Z1)) (_ : not (eq Y Z2)) (_ : not (Col A B C)) (_ : Col A B M1) (_ : Col A C M2) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col T Y Z) (_ : Bet Y T X) (_ : Bet Y M1 Z1) (_ : Bet Y M2 Z2) (_ : Cong Y T T X) (_ : Cong Y M1 M1 Z1) (_ : Cong Y M2 M2 Z2) (_ : Perp B C T Z) (_ : Perp A B Y Z1) (_ : Perp A C Y Z2), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.

*****
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not (Col A B C)) (_ : Col A B M1) (_ : Col A C M2) (_ : Bet A D T) (_ : not (Col B C T)) (_ : Bet B D C) (_ : Col T Y Z) (_ : Bet Y T X) (_ : Bet Y M1 Z1) (_ : Bet Y M2 Z2) (_ : Cong Y T T X) (_ : Cong Y M1 M1 Z1) (_ : Cong Y M2 M2 Z2) (_ : Perp B C T Z) (_ : Perp A B Y Z1) (_ : Perp A C Y Z2), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.

*****
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Bet Y M2 Z2) (_ : Cong Y T T X) (_ : Cong Y M1 M1 Z1) (_ : Cong Y M2 M2 Z2) (_ : Perp B C T Z) (_ : Perp A B Y Z1) (_ : Perp A C Y Z2), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.

*****
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exfalso; apply HABC; apply par_id.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B A C
+++++
apply l12_9 with Y Z1; Perp.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Y Z1 A A
+++++
exists A; right; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Y Z1 A C
+++++
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Y Z1 B A
+++++
Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Y Z1 B C
+++++
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C Y Z1
+++++
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.

*****
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exfalso; apply HABC; apply par_id_1.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.

*****
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B A B C
+++++
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).

*****
H : Coplanar B C Y Z1
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B A B C
+++++
apply l12_9 with Y Z1; [Cop..| |Perp|].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].

*****
H : Coplanar B C Y Z1
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Y Z1 A C
+++++
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].

*****
H : Coplanar B C Y Z1
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Y
+++++
assert_diffs; apply col_cop__cop with Z; Col; Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.

*****
H : Coplanar B C Y Z1
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Z1
+++++
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.

*****
H : Coplanar B C Y Z1
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T A
+++++
exists D; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.

*****
H : Coplanar B C Y Z1
HXYZ2 : not (Col X Y Z2)
HXYZ1 : Col X Y Z1
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp B C Y Z1
+++++
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exfalso; apply HABC; apply par_id_2.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.

*****
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par C A C B
+++++
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).

*****
H : Coplanar B C Y Z2
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par C A C B
+++++
apply l12_9 with Y Z2; [Cop..| |Perp|].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].

*****
H : Coplanar B C Y Z2
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar Y Z2 A B
+++++
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].

*****
H : Coplanar B C Y Z2
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Y
+++++
assert_diffs; apply col_cop__cop with Z; Col; Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.

*****
H : Coplanar B C Y Z2
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Z2
+++++
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.

*****
H : Coplanar B C Y Z2
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T A
+++++
exists D; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.

*****
H : Coplanar B C Y Z2
HXYZ2 : Col X Y Z2
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp C B Y Z2
+++++
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.

*****
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.

*****
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).

*****
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).

*****
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).

*****
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopB : Coplanar B C T B) by Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.

*****
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopC : Coplanar B C T C) by Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.

*****
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopT : Coplanar B C T T) by Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.

*****
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopZ : Coplanar B C T Z) by Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.

*****
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).

*****
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).

*****
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopZ1 : Coplanar B C T Z1).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).

*****
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Z1
+++++
assert (~ Col A B Y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (~ Col A B Y).

*****
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B Y)
+++++
intro; destruct (perp_not_col2 A B Y Z1) as [|HNCol]; Perp; apply HNCol; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (~ Col A B Y).
intro; destruct (perp_not_col2 A B Y Z1) as [|HNCol]; Perp; apply HNCol; ColR.

*****
H : not (Col A B Y)
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Z1
+++++
apply coplanar_pseudo_trans with A B Y; [| |apply coplanar_pseudo_trans with B C T..|]; Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).

*****
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopZ2 : Coplanar B C T Z2).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).

*****
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Z2
+++++
assert (~ Col A C Y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (~ Col A C Y).

*****
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A C Y)
+++++
intro; destruct (perp_not_col2 A C Y Z2) as [|HNCol]; Perp; apply HNCol; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (~ Col A C Y).
intro; destruct (perp_not_col2 A C Y Z2) as [|HNCol]; Perp; apply HNCol; ColR.

*****
H : not (Col A C Y)
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T Z2
+++++
apply coplanar_pseudo_trans with A C Y; [|apply coplanar_pseudo_trans with B C T| |apply coplanar_pseudo_trans with B C T|]; Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).

*****
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopx : Coplanar B C T x).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).

*****
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T x
+++++
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.

*****
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCopy : Coplanar B C T y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).

*****
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B C T y
+++++
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.

*****
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HCop : Coplanar X Y x y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).

*****
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X Y x y
+++++
apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.

*****
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HABx : Col A B x).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B x
+++++
elim (eq_dec_points A M1); intro HAM1; subst.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M1
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M1 B Y Z1
HPerp3 : Perp M1 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M1 B C)
HABM1 : Col M1 B M1
HACM2 : Col M1 C M2
HADT : Bet M1 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M1 B)
HAC : not (eq M1 C)
HAD : not (eq M1 D)
HAT : not (eq M1 T)
HAY : not (eq M1 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M1 B x
+++++
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z1; trivial.

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M1
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M1 B Y Z1
HPerp3 : Perp M1 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M1 B C)
HABM1 : Col M1 B M1
HACM2 : Col M1 C M2
HADT : Bet M1 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M1 B)
HAC : not (eq M1 C)
HAD : not (eq M1 D)
HAT : not (eq M1 T)
HAY : not (eq M1 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar M1 x Y Z1
+++++
exists M1; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M1
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M1 B Y Z1
HPerp3 : Perp M1 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M1 B C)
HABM1 : Col M1 B M1
HACM2 : Col M1 C M2
HADT : Bet M1 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M1 B)
HAC : not (eq M1 C)
HAD : not (eq M1 D)
HAT : not (eq M1 T)
HAY : not (eq M1 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B x Y Z1
+++++
apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M1
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M1 B Y Z1
HPerp3 : Perp M1 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M1 B C)
HABM1 : Col M1 B M1
HACM2 : Col M1 C M2
HADT : Bet M1 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M1 B)
HAC : not (eq M1 C)
HAD : not (eq M1 D)
HAT : not (eq M1 T)
HAY : not (eq M1 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong x Y x Z1
+++++
apply cong_transitivity with X x; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.
apply cong_transitivity with X x; Cong.

*****
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M1
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M1 B Y Z1
HPerp3 : Perp M1 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M1 B C)
HABM1 : Col M1 B M1
HACM2 : Col M1 C M2
HADT : Bet M1 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M1 B)
HAC : not (eq M1 C)
HAD : not (eq M1 D)
HAT : not (eq M1 T)
HAY : not (eq M1 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp_bisect M1 B Y Z1
+++++
apply perp_mid_perp_bisect; try split; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B x
+++++
assert (Col M1 A x).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M1 A x
+++++
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).
apply cong_cop2_perp_bisect_col with Y Z1; trivial.

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar M1 x Y Z1
+++++
exists M1; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A x Y Z1
+++++
apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong x Y x Z1
+++++
apply cong_transitivity with X x; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.
apply cong_transitivity with X x; Cong.

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp_bisect M1 A Y Z1
+++++
apply perp_mid_perp_bisect; try split; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).
apply cong_cop2_perp_bisect_col with Y Z1; trivial.
exists M1; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.
apply cong_transitivity with X x; Cong.
apply perp_mid_perp_bisect; try split; Cong.

*****
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp M1 A Y Z1
+++++
apply perp_left_comm; apply perp_col with B; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
elim (eq_dec_points A M1); intro HAM1; subst.
assert (Col M1 A x).

*****
H : Col M1 A x
HAM1 : not (eq A M1)
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B x
+++++
ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).

*****
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HACy : Col A C y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).

*****
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C y
+++++
elim (eq_dec_points A M2); intro HAM1; subst.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.

*****
HABx : Col M2 B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M2
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M2 B Y Z1
HPerp3 : Perp M2 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M2 B C)
HABM1 : Col M2 B M1
HACM2 : Col M2 C M2
HADT : Bet M2 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M2 B)
HAC : not (eq M2 C)
HAD : not (eq M2 D)
HAT : not (eq M2 T)
HAY : not (eq M2 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M2 C y
+++++
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z2; trivial.

*****
HABx : Col M2 B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M2
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M2 B Y Z1
HPerp3 : Perp M2 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M2 B C)
HABM1 : Col M2 B M1
HACM2 : Col M2 C M2
HADT : Bet M2 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M2 B)
HAC : not (eq M2 C)
HAD : not (eq M2 D)
HAT : not (eq M2 T)
HAY : not (eq M2 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar M2 y Y Z2
+++++
exists M2; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.

*****
HABx : Col M2 B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M2
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M2 B Y Z1
HPerp3 : Perp M2 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M2 B C)
HABM1 : Col M2 B M1
HACM2 : Col M2 C M2
HADT : Bet M2 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M2 B)
HAC : not (eq M2 C)
HAD : not (eq M2 D)
HAT : not (eq M2 T)
HAY : not (eq M2 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C y Y Z2
+++++
apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.

*****
HABx : Col M2 B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M2
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M2 B Y Z1
HPerp3 : Perp M2 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M2 B C)
HABM1 : Col M2 B M1
HACM2 : Col M2 C M2
HADT : Bet M2 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M2 B)
HAC : not (eq M2 C)
HAD : not (eq M2 D)
HAT : not (eq M2 T)
HAY : not (eq M2 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong y Y y Z2
+++++
apply cong_transitivity with X y; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.
apply cong_transitivity with X y; Cong.

*****
HABx : Col M2 B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T M2
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp2 : Perp M2 B Y Z1
HPerp3 : Perp M2 C Y Z2
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HABC : not (Col M2 B C)
HABM1 : Col M2 B M1
HACM2 : Col M2 C M2
HADT : Bet M2 D T
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAB : not (eq M2 B)
HAC : not (eq M2 C)
HAD : not (eq M2 D)
HAT : not (eq M2 T)
HAY : not (eq M2 Y)
HTC : triangle_circumscription_principle
B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp_bisect M2 C Y Z2
+++++
apply perp_mid_perp_bisect; try split; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C y
+++++
assert (Col M2 A y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M2 A y
+++++
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).
apply cong_cop2_perp_bisect_col with Y Z2; trivial.

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar M2 y Y Z2
+++++
exists M2; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A y Y Z2
+++++
apply coplanar_pseudo_trans with B C T; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong y Y y Z2
+++++
apply cong_transitivity with X y; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.
apply cong_transitivity with X y; Cong.

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp_bisect M2 A Y Z2
+++++
apply perp_mid_perp_bisect; try split; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).
apply cong_cop2_perp_bisect_col with Y Z2; trivial.
exists M2; left; split; Col.
apply coplanar_pseudo_trans with B C T; assumption.
apply cong_transitivity with X y; Cong.
apply perp_mid_perp_bisect; try split; Cong.

*****
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp M2 A Y Z2
+++++
apply perp_left_comm; apply perp_col with C; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
elim (eq_dec_points A M2); intro HAM1; subst.
assert (Col M2 A y).

*****
H : Col M2 A y
HAM1 : not (eq A M2)
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C y
+++++
ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).

*****
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (Hxy : x <> y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).

*****
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq x y)
+++++
intro; treat_equalities.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.

*****
HACy : Col A C x
HABx : Col A B x
HCop : Coplanar X Y x x
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong4 : Cong X x Z2 x
HCop2 : Coplanar X Y Z2 x
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.

*****
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (H : Par B C A T).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).

*****
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B C A T
+++++
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).

*****
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp B C X Y
+++++
apply perp_sym; apply perp_col2 with Z T; Perp; assert_cols; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).
apply perp_sym; apply perp_col2 with Z T; Perp; assert_cols; ColR.

*****
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A T X Y
+++++
apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).
apply perp_sym; apply perp_col2 with Z T; Perp; assert_cols; ColR.
apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong.

*****
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A T X Y
+++++
exists T; left; split; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).

*****
H : Par B C A T
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
elim H; clear H; intro H.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).
elim H; clear H; intro H.

*****
H : Par_strict B C A T
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H; exists D; assert_cols; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
intro; treat_equalities.
assert (A = x) by (apply l6_21 with A B C A; Col); treat_equalities.
assert (H : Par B C A T).
elim H; clear H; intro H.
apply H; exists D; assert_cols; Col.

*****
H : and (not (eq B C)) (and (not (eq A T)) (and (Col B A T) (Col C A T)))
HCop : Coplanar X Y A A
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCong1 : Cong X A Y A
HCong2 : Cong X A Z1 A
HCop1 : Coplanar X Y Z1 A
HCop2 : Coplanar X Y Z2 A
HCong4 : Cong X A Z2 A
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
spliter; apply HABC; assert_cols; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).

*****
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HPar : Par B C x y).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).

*****
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B C x y
+++++
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).

*****
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp B C X Y
+++++
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
apply l12_9 with X Y; try (apply coplanar_pseudo_trans with B C T; assumption).
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.

*****
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp x y X Y
+++++
apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).

*****
HPar : Par B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HPerp3 : Perp A C Y Z2
HPerp2 : Perp A B Y Z1
HPerp1 : Perp B C T Z
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
clear HPerp1; clear HPerp2; clear HPerp3.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.

*****
HPar : Par B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
HCong4 : Cong X y Z2 y
HCong3 : Cong X y Y y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
HCong2 : Cong X x Z1 x
HCong1 : Cong X x Y x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.

*****
HPar : Par B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.

*****
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HxTy : Col x T y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
elim HxTy; clear HxTy; intro HxTy.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.

*****
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
elim HABx; clear HABx; intro HABx.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.

*****
HABx : Bet A B x
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
elim HACy; clear HACy; intro HACy; auto.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.

*****
HACy : or (Bet C y A) (Bet y A C)
HABx : Bet A B x
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
elim HACy; clear HACy; intro HACy.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.

*****
HACy : Bet C y A
HABx : Bet A B x
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.

*****
HACy : Bet y A C
HABx : Bet A B x
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.

*****
HABx : or (Bet B x A) (Bet x A B)
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
elim HABx; clear HABx; intro HABx.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
elim HABx; clear HABx; intro HABx.

*****
HABx : Bet B x A
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
exfalso; apply impossible_case_3 with A B C D T x y; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
elim HABx; clear HABx; intro HABx.
exfalso; apply impossible_case_3 with A B C D T x y; assumption.

*****
HABx : Bet x A B
HxTy : Bet x T y
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
exfalso; apply impossible_case_2 with A C B D T y x; assert_cols; Col; Between.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
elim HABx; clear HABx; intro HABx.
exfalso; apply impossible_case_3 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A C B D T y x; assert_cols; Col; Between.

*****
HxTy : or (Bet T y x) (Bet y x T)
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
elim HxTy; clear HxTy; intro HxTy.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
elim HABx; clear HABx; intro HABx.
exfalso; apply impossible_case_3 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A C B D T y x; assert_cols; Col; Between.
elim HxTy; clear HxTy; intro HxTy.

*****
HxTy : Bet T y x
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
exfalso; apply impossible_case_4 with A B C D T x y; assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
elim HABx; clear HABx; intro HABx.
exfalso; apply impossible_case_3 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A C B D T y x; assert_cols; Col; Between.
elim HxTy; clear HxTy; intro HxTy.
exfalso; apply impossible_case_4 with A B C D T x y; assumption.

*****
HxTy : Bet y x T
HPar : Par_strict B C x y
Hxy : not (eq x y)
HACy : Col A C y
HABx : Col A B x
HCop : Coplanar X Y x y
HCopy : Coplanar B C T y
HCopx : Coplanar B C T x
HCopZ2 : Coplanar B C T Z2
HCopZ1 : Coplanar B C T Z1
HCopX : Coplanar B C T X
HCopY : Coplanar B C T Y
HCopZ : Coplanar B C T Z
HCopT : Coplanar B C T T
HCopC : Coplanar B C T C
HCopB : Coplanar B C T B
HCopA : Coplanar B C T A
HYM2 : not (eq Y M2)
HYM1 : not (eq Y M1)
HCop2 : Coplanar X Y Z2 y
y : Tpoint
HCop1 : Coplanar X Y Z1 x
x : Tpoint
HXYZ2 : not (Col X Y Z2)
HXYZ1 : not (Col X Y Z1)
HCong7 : Cong Y M2 M2 Z2
HCong6 : Cong Y M1 M1 Z1
HCong5 : Cong Y T T X
HYM2Z2 : Bet Y M2 Z2
HYM1Z1 : Bet Y M1 Z1
HYTX : Bet Y T X
HTYZ : Col T Y Z
HBDC : Bet B D C
HBCT : not (Col B C T)
HADT : Bet A D T
HACM2 : Col A C M2
HABM1 : Col A B M1
HABC : not (Col A B C)
HYZ2 : not (eq Y Z2)
HYZ1 : not (eq Y Z1)
HXY : not (eq X Y)
HTY : not (eq T Y)
HTX : not (eq T X)
HDT : not (eq D T)
HCY : not (eq C Y)
HCT : not (eq C T)
HCD : not (eq C D)
HBY : not (eq B Y)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAY : not (eq A Y)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
HTC : triangle_circumscription_principle
A,B,C,D,T,X,Y,Z,M1,Z1,M2,Z2 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B x) (and (Bet A C y) (Bet x T y))
+++++
exfalso; apply impossible_case_4 with A C B D T y x; Between; Col; Par.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid_aux : forall A B C D T X Y Z M1 Z1 M2 Z2, triangle_circumscription_principle -> A <> B -> A <> C -> A <> D -> A <> T -> A <> Y -> B <> C -> B <> D -> B <> T -> B <> Y -> C <> D -> C <> T -> C <> Y -> D <> T -> T <> X -> T <> Y -> X <> Y -> Y <> Z1 -> Y <> Z2 -> ~ Col A B C -> Col A B M1 -> Col A C M2 -> Bet A D T -> ~ Col B C T -> Bet B D C -> Col T Y Z -> Bet Y T X -> Bet Y M1 Z1 -> Bet Y M2 Z2 -> Cong Y T T X -> Cong Y M1 M1 Z1 -> Cong Y M2 M2 Z2 -> Perp B C T Z -> Perp A B Y Z1 -> Perp A C Y Z2 -> exists x, exists y, Bet A B x /\\ Bet A C y /\\ Bet x T y.
Proof.
intros A B C D T X Y Z M1 Z1 M2 Z2; intro HTC.
intros HAB HAC HAD HAT HAY HBC HBD HBT HBY HCD HCT HCY HDT HTX HTY HXY HYZ1 HYZ2.
intros HABC HABM1 HACM2 HADT HBCT HBDC HTYZ HYTX HYM1Z1.
intros HYM2Z2 HCong5 HCong6 HCong7 HPerp1 HPerp2 HPerp3.
elim (col_dec X Y Z1); intro HXYZ1; elim (col_dec X Y Z2); intro HXYZ2.
exfalso; apply HABC; apply par_id.
apply l12_9 with Y Z1; Perp.
exists A; right; left; split; Col.
apply coplanar_perm_16, col_cop__cop with Z2; Cop; ColR.
Cop.
assert_diffs; apply coplanar_perm_16, col2_cop__cop with T Z; Cop; ColR.
apply perp_col1 with Z2; assert_diffs; Perp; ColR.
exfalso; apply HABC; apply par_id_1.
assert (Coplanar B C Y Z1) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z1; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
exfalso; apply HABC; apply par_id_2.
assert (Coplanar B C Y Z2) by (assert_diffs; apply col2_cop__cop with T Z; Cop; ColR).
apply l12_9 with Y Z2; [Cop..| |Perp|].
apply coplanar_pseudo_trans with B C T; [assumption|..|Cop].
assert_diffs; apply col_cop__cop with Z; Col; Cop.
assert_diffs; apply col_cop__cop with Z; Cop; ColR.
exists D; left; split; Col.
apply perp_sym; apply perp_col2 with T Z; Perp; assert_cols; ColR.
assert (H := HXYZ1); apply HTC in H; destruct H as [x [HCong1 [HCong2 HCop1]]]; exists x; assert (H := HXYZ2); apply HTC in H; destruct H as [y [HCong3 [HCong4 HCop2]]]; exists y.
assert (HYM1 : Y <> M1) by (intro; treat_equalities; auto).
assert (HYM2 : Y <> M2) by (intro; treat_equalities; auto).
assert (HCopA : Coplanar B C T A) by (exists D; left; split; Col).
assert (HCopB : Coplanar B C T B) by Cop.
assert (HCopC : Coplanar B C T C) by Cop.
assert (HCopT : Coplanar B C T T) by Cop.
assert (HCopZ : Coplanar B C T Z) by Cop.
assert (HCopY : Coplanar B C T Y) by (assert_diffs; apply col_cop__cop with Z; Col).
assert (HCopX : Coplanar B C T X) by (apply col_cop__cop with Y; Col).
assert (HCopZ1 : Coplanar B C T Z1).
assert (HCopZ2 : Coplanar B C T Z2).
assert (HCopx : Coplanar B C T x).
apply coplanar_pseudo_trans with X Y Z1; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCopy : Coplanar B C T y).
apply coplanar_pseudo_trans with X Y Z2; trivial; apply coplanar_pseudo_trans with B C T; assumption.
assert (HCop : Coplanar X Y x y).
apply coplanar_pseudo_trans with B C T; assumption.
assert (HxTy : Col x T y) by (elim (eq_dec_points T x); intro; elim (eq_dec_points T y); intro; try (subst; Col); apply col_permutation_4; apply cop_perp2__col with X Y; trivial; apply perp_bisect_perp; apply cong_cop_perp_bisect; Cong; Cop).
assert (HABx : Col A B x).
assert (HACy : Col A C y).
assert (Hxy : x <> y).
assert (HPar : Par B C x y).
clear HPerp1; clear HPerp2; clear HPerp3.
clear HCong1; clear HCong2; clear HCong3; clear HCong4.
assert (HPar' : Par_strict B C x y) by (elim HPar; clear HPar; intro HPar; try assumption; spliter; exfalso; apply HABC; assert_cols; ColR); clear HPar; rename HPar' into HPar.
elim HxTy; clear HxTy; intro HxTy.
elim HABx; clear HABx; intro HABx.
elim HACy; clear HACy; intro HACy; auto.
elim HACy; clear HACy; intro HACy.
exfalso; apply impossible_case_1 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A B C D T x y; assert_cols; Col.
elim HABx; clear HABx; intro HABx.
exfalso; apply impossible_case_3 with A B C D T x y; assumption.
exfalso; apply impossible_case_2 with A C B D T y x; assert_cols; Col; Between.
elim HxTy; clear HxTy; intro HxTy.
exfalso; apply impossible_case_4 with A B C D T x y; assumption.
exfalso; apply impossible_case_4 with A C B D T y x; Between; Col; Par.

*****

*****

+++++
Qed.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid :\n  triangle_circumscription_principle ->\n  tarski_s_parallel_postulate.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : triangle_circumscription_principle, tarski_s_parallel_postulate
+++++
Proof.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : triangle_circumscription_principle, tarski_s_parallel_postulate
+++++
unfold tarski_s_parallel_postulate.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : triangle_circumscription_principle) (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Bet A B X) (and (Bet A C Y) (Bet X T Y))))
+++++
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.

*****
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : Bet B D C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).

*****
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].

*****
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.

*****
HBCT : not (Col C C T)
HPerp : Perp C C T C
HADT : Bet A C T
HABC : not (Col A C C)
HBD : not (eq C C)
HBT : not (eq C T)
HAT : not (eq A T)
HAB : not (eq A C)
A,C,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A C x) (and (Bet A C y) (Bet x T y))))
+++++
exfalso; apply HBCT; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.

*****
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].

*****
HY : Midpoint Y B T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).

*****
HAY : not (eq A Y)
HY : Midpoint Y B T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.

*****
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HY : Midpoint Y B T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).

*****
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HY : Midpoint Y B T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HY as [HBTY HBYTY].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].

*****
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).

*****
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].

*****
HX : Midpoint T Y X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.

*****
HXY : not (eq T X)
HTX : not (eq X Y)
HX : Midpoint T Y X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HX as [HXTY HXTYT].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].

*****
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].

*****
HZ1 : Reflect Z1 Y A B
Z1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.

*****
HZ1 : ReflectL Z1 Y A B
Z1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].

*****
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].

*****
HZ2 : Reflect Z2 Y A C
Z2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.

*****
HZ2 : ReflectL Z2 Y A C
Z2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].

*****
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.

*****
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Y) (eq Y Y)
HABM1 : Col A B Y
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HFalse : Col A B C) by (assert_cols; ColR); contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.

*****
HYZ1 : not (eq Y Z1)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ1; clear HZ1; intro HZ1; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.
elim HZ1; clear HZ1; intro HZ1; try contradiction.

*****
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.
elim HZ1; clear HZ1; intro HZ1; try contradiction.
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.

*****
HYZ2 : not (eq Y Z2)
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ2; clear HZ2; intro HZ2; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.
elim HZ1; clear HZ1; intro HZ1; try contradiction.
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.
elim HZ2; clear HZ2; intro HZ2; try contradiction.

*****
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y B M1 Z1 M2 Z2; try assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence B T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y B T HBT HY); destruct H as [HBY HTY]; apply not_eq_sym in HBY; apply not_eq_sym in HTY.
assert (HCY : C <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HBTY HBYTY].
assert (HACY : ~ Col A C Y) by (apply impossible_two_sides_not_col with B D T; assumption).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities.
elim HZ1; clear HZ1; intro HZ1; try contradiction.
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.
elim HZ2; clear HZ2; intro HZ2; try contradiction.
apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y B M1 Z1 M2 Z2; try assumption.

*****
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A C Y)
HCY : not (eq C Y)
HTY : not (eq T Y)
HBY : not (eq B Y)
HAY : not (eq A Y)
HBYTY : Cong B Y Y T
HBTY : Bet B Y T
Y : Tpoint
HPerp : Perp B C T B
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T Y B
+++++
assert_cols; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.

*****
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].

*****
HY : Midpoint Y C T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).

*****
HAY : not (eq A Y)
HY : Midpoint Y C T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.

*****
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HY : Midpoint Y C T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).

*****
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HY : Midpoint Y C T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HY as [HCTY HCYTY].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].

*****
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).

*****
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].

*****
HX : Midpoint T Y X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.

*****
HXY : not (eq T X)
HTX : not (eq X Y)
HX : Midpoint T Y X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HX as [HXTY HXTYT].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].

*****
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].

*****
HZ1 : Reflect Z1 Y A B
Z1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.

*****
HZ1 : ReflectL Z1 Y A B
Z1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].

*****
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].

*****
HZ2 : Reflect Z2 Y A C
Z2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.

*****
HZ2 : ReflectL Z2 Y A C
Z2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].

*****
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.

*****
HZ2 : or (Perp A C Y Y) (eq Y Y)
HACM2 : Col A C Y
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HFalse : Col A B C) by (assert_cols; ColR); contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.

*****
HYZ2 : not (eq Y Z2)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ2; clear HZ2; intro HZ2; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.
elim HZ2; clear HZ2; intro HZ2; try contradiction.

*****
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.
elim HZ2; clear HZ2; intro HZ2; try contradiction.
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.

*****
HYZ1 : not (eq Y Z1)
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ1; clear HZ1; intro HZ1; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.
elim HZ2; clear HZ2; intro HZ2; try contradiction.
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
elim HZ1; clear HZ1; intro HZ1; try contradiction.

*****
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y C M1 Z1 M2 Z2; try assumption.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HY := midpoint_existence C T); destruct HY as [Y HY].
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (H := midpoint_distinct_1 Y C T HCT HY); destruct H as [HCY HTY]; apply not_eq_sym in HCY; apply not_eq_sym in HTY.
assert (HBY : B <> Y) by (intro; subst; apply HBCT; assert_cols; Col).
destruct HY as [HCTY HCYTY].
assert (HACY : ~ Col A B Y) by (apply impossible_two_sides_not_col with C D T; Between; Col).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities.
elim HZ2; clear HZ2; intro HZ2; try contradiction.
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
elim HZ1; clear HZ1; intro HZ1; try contradiction.
apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y C M1 Z1 M2 Z2; try assumption.

*****
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HACY : not (Col A B Y)
HBY : not (eq B Y)
HTY : not (eq T Y)
HCY : not (eq C Y)
HAY : not (eq A Y)
HCYTY : Cong C Y Y T
HCTY : Bet C Y T
Y : Tpoint
HPerp : Perp B C T C
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T Y C
+++++
assert_cols; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.

*****
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).

*****
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].

*****
HX : Midpoint T Y X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.

*****
HTY : not (eq T Y)
HX : Midpoint T Y X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.

*****
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HX : Midpoint T Y X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HX as [HXTY HXTYT].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].

*****
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].

*****
HZ1 : Reflect Z1 Y A B
Z1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.

*****
HZ1 : ReflectL Z1 Y A B
Z1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].

*****
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].

*****
HZ2 : Reflect Z2 Y A C
Z2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.

*****
HZ2 : ReflectL Z2 Y A C
Z2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].

*****
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).

*****
HABY : not (Col A B Y)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).
assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).

*****
HACY : not (Col A C Y)
HABY : not (Col A B Y)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).
assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.

*****
HYZ1 : not (eq Y Z1)
HACY : not (Col A C Y)
HABY : not (Col A B Y)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HZ1 : or (Perp A B Y Z1) (eq Y Z1)
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ1; clear HZ1; intro HZ1; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).
assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
elim HZ1; clear HZ1; intro HZ1; try contradiction.

*****
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HACY : not (Col A C Y)
HABY : not (Col A B Y)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).
assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
elim HZ1; clear HZ1; intro HZ1; try contradiction.
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.

*****
HYZ2 : not (eq Y Z2)
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HACY : not (Col A C Y)
HABY : not (Col A B Y)
HZ2 : or (Perp A C Y Z2) (eq Y Z2)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
elim HZ2; clear HZ2; intro HZ2; try contradiction.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.
assert (HAY : A <> Y) by (intro; treat_equalities; assert_cols; apply HABC; ColR).
assert (HX := symmetric_point_construction Y T); destruct HX as [X HX].
assert (H := perp_distinct B C T Y HPerp); destruct H as [Hclear HTY]; clear Hclear.
assert (H := midpoint_distinct_2 T Y X HTY HX); destruct H as [HTX HXY]; apply not_eq_sym in HTX.
destruct HX as [HXTY HXTYT].
assert (HZ1 := l10_2_existence A B Y); destruct HZ1 as [Z1 HZ1].
elim HZ1; clear HZ1; intro HZ1; destruct HZ1 as [Hclear HZ1]; try contradiction; clear Hclear.
destruct HZ1 as [[M1 [[HXM1Z1 HM1XM1Z1] HABM1]] HZ1].
assert (HZ2 := l10_2_existence A C Y); destruct HZ2 as [Z2 HZ2].
elim HZ2; clear HZ2; intro HZ2; destruct HZ2 as [Hclear HZ2]; try contradiction; clear Hclear.
destruct HZ2 as [[M2 [[HXM2Z2 HM2XM2Z2] HACM2]] HZ2].
assert (HABY : ~ Col A B Y) by (intro; apply HBY; apply l6_21 with A B C B; assert_cols; Col).
assert (HACY : ~ Col A C Y) by (intro; apply HCY; apply l6_21 with A C B C; assert_cols; Col).
elim (eq_dec_points Y Z1); intro HYZ1; treat_equalities; try contradiction.
elim HZ1; clear HZ1; intro HZ1; try contradiction.
elim (eq_dec_points Y Z2); intro HYZ2; treat_equalities; try contradiction.
elim HZ2; clear HZ2; intro HZ2; try contradiction.

*****
HZ2 : Perp A C Y Z2
HYZ2 : not (eq Y Z2)
HZ1 : Perp A B Y Z1
HYZ1 : not (eq Y Z1)
HACY : not (Col A C Y)
HABY : not (Col A B Y)
HACM2 : Col A C M2
HM2XM2Z2 : Cong Y M2 M2 Z2
HXM2Z2 : Bet Y M2 Z2
Z2,M2 : Tpoint
HABM1 : Col A B M1
HM1XM1Z1 : Cong Y M1 M1 Z1
HXM1Z1 : Bet Y M1 Z1
Z1,M1 : Tpoint
HXY : not (eq T X)
HTX : not (eq X Y)
HTY : not (eq T Y)
HXTYT : Cong Y T T X
HXTY : Bet Y T X
X : Tpoint
HAY : not (eq A Y)
HCY : not (eq C Y)
HBY : not (eq B Y)
HPerp : Perp B C T Y
HBCY : Col B C Y
Y : Tpoint
HBCT : not (Col B C T)
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HTC : triangle_circumscription_principle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
apply triangle_circumscription_implies_tarski_s_euclid_aux with D X Y Y M1 Z1 M2 Z2; Col.
-----
Lemma triangle_circumscription_implies_tarski_s_euclid : triangle_circumscription_principle -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HTC; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC; assert (HBCT : ~ Col B C T) by (intro; apply HABC; assert_cols; ColR).
assert (HY := l8_18_existence B C T HBCT); destruct HY as [Y [HBCY HPerp]].
elim (eq_dec_points B Y); intro HBY; elim (eq_dec_points C Y); intro HCY; treat_equalities.

*****

*****

+++++
Qed.
-----
End TCP_tarski.
-----
